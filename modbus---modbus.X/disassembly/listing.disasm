Disassembly Listing for VAR_C_NEW
Generated From:
C:/work_Git/VAR_C_NEW/VAR_C_NEW.X/dist/default/production/VAR_C_NEW.X.production.elf
19.03.2024 15:50:31

---  C:/work_Git/VAR_C_NEW/VAR_C_NEW.X/main.c  ----------------------------------------------------------
1:             
2:             
3:             /* 1.01 - добавлен пункт меню с компенсацией фазы 
4:               
5:              */
6:             
7:             /*Инструкция по настройке: 
8:             -Подключить к стенду
9:             -Открыть вкладку ВАР-СИ
10:            -Подать питание 24В
11:            -Запустится проверка сегментов 
12:            -Проверить кнопки 
13:            -Когда программа запросит первую точку подать 100В, 1А, cos = 1
14:            
15:             *Навигация
16:            + след. пункт, увеличить значение 
17:            - пред. пункт, уменьшить значение
18:            ввод - вход в пункт, подтвердить значение
19:            выход - выход из пункта, вернутся на главный
20:            удержание ввод 6 секунд - сброс энергии 
21:            
22:             *пункты меню:
23:             - главный: отображаются два выбранных параметра (U и A по умолчанию)
24:             - настройка индикатора 1: U - напряжение/A - сила тока/P - активная мощность/S - полная мощность/Pr - реактивная мощность/PF - угол м/у током и напряжением/F - частота/E - энергия
25:             - настройка индикатора 2: U/A/P/Pr/F
26:             - tr 5A (настройка первичной обмотки трансформатора): 5А - 1000А (5 по умолчанию) 
27:             - addr (настройка адреса устройства): 1-247 (1 по умолчанию)
28:             - br (настройка скорости передачи данных): 9600/14400/19200(по умолчанию)/28800/38400/57600/76800/115200
29:             
30:             *регистры:
31:              r, 200 напряжение LSB (unsigned int32)                 
32:              r, 201 напряжение MSB   
33:              r, 202 частота LSB(usigned int32)      
34:              r, 203 частота MSB             
35:              r, 204 сила тока LSB (unsigned int32)            
36:              r, 205 сила тока MSB       
37:              r, 206 активная мощность LSB (signed int32)      
38:              r, 207 активная мощность MSB     
39:              r, 208 реактивная мощность LSB (signed int32)    
40:              r, 209 реактивная мощность MSB    
41:             *r - только чтение
42:             *rw - чтение и запись
43:            
44:             *единицы измерения:
45:              ModBus:
46:              - Напряжение - 0.1В
47:              - Сила тока - 0.001А 
48:              - Мощность - 0.001кВт 
49:              - Частота - 0.1Гц
50:              Показометр:
51:              - Напряжение - 1В, 1 знак после запятой
52:              - Сила тока - 1А, 3-0 
53:              - Мощность - 1кВт, 3-0  
54:              - Частота - 1Гц, 1 
55:             */
56:            #define MAIN_C_DATA
57:            #include "main.h"
58:            
59:            // CONFIG1
60:            #pragma config FOSC = HS        // Oscillator Selection (HS Oscillator, High-speed crystal/resonator connected between OSC1 and OSC2 pins)
61:            #pragma config WDTE = ON       // Watchdog Timer Enable (WDT enabled)
62:            #pragma config PWRTE = OFF      // Power-up Timer Enable (PWRT disabled)
63:            #pragma config MCLRE = OFF      // MCLR Pin Function Select (MCLR/VPP pin function is digital input)
64:            #pragma config CP = ON         // Flash Program Memory Code Protection (Program memory code protection is disabled)
65:            #pragma config CPD = OFF        // Data Memory Code Protection (Data memory code protection is disabled)
66:            #pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
67:            #pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
68:            #pragma config IESO = OFF       // Internal/External Switchover (Internal/External Switchover mode is disabled)
69:            #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)
70:            
71:            // CONFIG2
72:            #pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
73:            #pragma config PLLEN = ON      // PLL Enable (4x PLL enabled)
74:            #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
75:            #pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
76:            #pragma config LVP = OFF        // Low-Voltage Programming Enable (High-voltage on MCLR/VPP must be used for programming)
77:            
78:            cal_const cal_const_y;
79:            const cal_const cal_const_x = {100, 1000, 1000, 500};
80:            UINT8 error_cal = 0;
81:            UINT16 phase_correct = 0;
82:            UINT16 index_ind1 = 0;
83:            UINT16 index_ind2 = 0;
84:            UINT16 tr_type = 0;
85:            UINT16 Timer_Interrupt_3;
86:            
87:            __EEPROM_DATA("M", "e", "a", "n", "d", "r", " ", " ");
88:            __EEPROM_DATA("M", "o", "d", " ", "V", "A", "R", "C");
89:            #if DEBUG
90:            __EEPROM_DATA("D", "E", "B", "U", "G", "v", "e", "r");
91:            #else
92:            __EEPROM_DATA("V", "e", "r", " ", soft_ver_S0 + 48, ".", soft_ver_S1 + 48, soft_ver_S2 + 48);
93:            #endif
94:            
95:            void main(void) {
090C  3084     MOVLW 0x84
090D  0022     MOVLB 0x2
090E  009D     MOVWF APFCON0
090F  0021     MOVLB 0x1
0910  0195     CLRF OPTION_REG
0911  0024     MOVLB 0x4
0912  018C     CLRF WPUA
0913  0027     MOVLB 0x7
0914  018C     CLRF INLVLA
0915  0024     MOVLB 0x4
0916  018D     CLRF WPUB
0917  0027     MOVLB 0x7
0918  018D     CLRF INLVLB
0919  0024     MOVLB 0x4
091A  018E     CLRF WPUC
091B  0027     MOVLB 0x7
091C  018E     CLRF INLVLC
091D  0022     MOVLB 0x2
091E  018C     CLRF LATA
091F  018D     CLRF LATB
0920  018E     CLRF LATC
0921  3017     MOVLW 0x17
0922  0023     MOVLB 0x3
0923  008C     MOVWF ANSELA
0924  30F0     MOVLW 0xF0
0925  008D     MOVWF ANSELB
0926  30CF     MOVLW 0xCF
0927  008E     MOVWF ANSELC
0928  303F     MOVLW 0x3F
0929  0021     MOVLB 0x1
092A  008C     MOVWF TRISA
092B  30F0     MOVLW 0xF0
092C  008D     MOVWF TRISB
092D  30FF     MOVLW 0xFF
092E  008E     MOVWF TRISC
96:            #include "reset_per_1829.c"
97:                OPTION_REGbits.PS = 0b111; //делитель частоты для таймера0 1/256
092F  3007     MOVLW 0x7
0930  0495     IORWF OPTION_REG, F
98:                WPUA3 = 1;
0931  0024     MOVLB 0x4
0932  158C     BSF WPUA, 0x3
99:                WPUC6 = 1;
0933  170E     BSF WPUC, 0x6
100:               WPUA1 = 1;
0934  148C     BSF WPUA, 0x1
101:               WPUA0 = 1;
0935  140C     BSF WPUA, 0x0
102:               TRISC4 = OUT; //Tx UART
0936  0021     MOVLB 0x1
0937  120E     BCF TRISC, 0x4
103:               LATC4 = 1;
0938  0022     MOVLB 0x2
0939  160E     BSF LATC, 0x4
104:           
105:               ANSB5 = DIG; //Rx UART
093A  0023     MOVLB 0x3
093B  128D     BCF ANSELB, 0x5
106:           
107:               TRISB7 = OUT; //Tx UART
093C  0021     MOVLB 0x1
093D  138D     BCF TRISB, 0x7
108:               LATB7 = 1;
093E  0022     MOVLB 0x2
093F  178D     BSF LATB, 0x7
109:           
110:               TRISC3 = OUT;
0940  0021     MOVLB 0x1
0941  118E     BCF TRISC, 0x3
111:               TRISC2 = OUT;
0942  110E     BCF TRISC, 0x2
112:               TRISB6 = OUT;
0943  130D     BCF TRISB, 0x6
113:               TRISC7 = OUT;
0944  138E     BCF TRISC, 0x7
114:           
115:               TRISC0 = OUT;
0945  100E     BCF TRISC, 0x0
116:           
117:               ANSC6 = DIG;
0946  0023     MOVLB 0x3
0947  130E     BCF ANSELC, 0x6
118:               ANSA0 = DIG;
0948  100C     BCF ANSELA, 0x0
119:               ANSA1 = DIG;
0949  108C     BCF ANSELA, 0x1
120:           
121:           #if 0
122:           #define GET_BYTE(numb, data) (*(((UINT8*)&data) + numb))
123:           #define GET_WORD(numb, data) (*(((UINT16*)&data) + numb))
124:           #define EEPR_WRITE(add, data) for (UINT8 index = 0; index < sizeof (data); index++){eeprom_write(add - index, GET_BYTE(index, data));}
125:           #define EEPR_READ(add, data) for (UINT8 index = 0; index < sizeof (data); index++){GET_BYTE(index, data) = eeprom_read(add - index);}
126:               INT32 temp = 0;
127:               INT32 *p = &temp;
128:               //U_Value_LSB = 0xCD;
129:               //U_Value_MSB = 0xAF;
130:               UINT8 a = 0xAB;
131:               UINT8 b = 0xEF;
132:               GET_BYTE(0, *p) = a;
133:               GET_BYTE(1, *p) = b;
134:               //   temp = (((INT32)(Space[2].data)) << 16) | (INT32)Space[1].data;
135:               // EEPR_WRITE(45, temp);
136:               //UINT32 temp2;
137:               //EEPR_READ(7, b);
138:               if (temp || a || b)
139:               {
140:                   NOP();
141:               }
142:           #endif
143:           
144:               SSP1CON1bits.SSPM = 0b1010;
094A  0024     MOVLB 0x4
094B  0815     MOVF SSP1CON1, W
094C  39F0     ANDLW 0xF0
094D  380A     IORLW 0xA
094E  0095     MOVWF SSP1CON1
145:               SSP1CON1bits.CKP = 0;
094F  1215     BCF SSP1CON1, 0x4
146:               SSP1STATbits.CKE = 1;
0950  1714     BSF SSP1STAT, 0x6
147:               SSP1CON1bits.SSPEN = 1;
0951  1695     BSF SSP1CON1, 0x5
148:               SSP1ADD = 0x4F; // 100 KGz
0952  304F     MOVLW 0x4F
0953  0092     MOVWF SSP1ADD
149:               SSP1BUF = 0;
0954  0191     CLRF SSP1BUF
150:               while (!SSP1IF);
0955  0020     MOVLB 0x0
0956  1D91     BTFSS PIR1, 0x3
0957  2955     GOTO 0x155
151:               RLAT = 1;
0958  0022     MOVLB 0x2
0959  150E     BSF LATC, 0x2
152:               __delay_us(1);
095A  3200     BRA 0x95B
095B  3200     BRA 0x95C
095C  3200     BRA 0x95D
095D  3200     BRA 0x95E
153:               RLAT = 0;
095E  0022     MOVLB 0x2
095F  110E     BCF LATC, 0x2
154:           
155:               CCP4CONbits.CCP4M = 0b1011;
0960  0026     MOVLB 0x6
0961  081A     MOVF CCP4CON, W
0962  39F0     ANDLW 0xF0
0963  380B     IORLW 0xB
0964  009A     MOVWF CCP4CON
156:               CCPR4 = PERIOD_INTERRUPT_MKS * CCP_FREQ_MGZ - 1;
0965  3004     MOVLW 0x4
0966  0099     MOVWF CCPR4H
0967  30FF     MOVLW 0xFF
0968  0098     MOVWF CCPR4
157:               CCP4IF = 0;
0969  0020     MOVLB 0x0
096A  1293     BCF PIR3, 0x5
158:               CCP4IE = 1;
096B  0021     MOVLB 0x1
096C  1693     BSF PIE3, 0x5
159:           
160:               if (eeprom_read(FIRST_RUN_BIT_ADD))
096D  3020     MOVLW 0x20
096E  2265     CALL 0x265
096F  3188     MOVLP 0x8
0970  3A00     XORLW 0x0
0971  1903     BTFSC STATUS, 0x2
0972  2979     GOTO 0x179
161:               {
162:                   func_reset_all();
0973  227C     CALL 0x27C
0974  3188     MOVLP 0x8
163:                   eeprom_write(FIRST_RUN_BIT_ADD, 0);
0975  3020     MOVLW 0x20
0976  01A0     CLRF __pcstackBANK1
0977  2357     CALL 0x357
0978  3188     MOVLP 0x8
164:               }
165:               //ResetAdress();
166:               func_initialization();
0979  21B9     CALL 0x1B9
167:               set_baud_rate();
097A  319E     MOVLP 0x1E
097B  26FE     CALL 0x6FE
097C  3188     MOVLP 0x8
168:           
169:               BRGH = 1;
097D  0023     MOVLB 0x3
097E  151E     BSF TXSTA, 0x2
170:               BRG16 = 1;
097F  159F     BSF BAUDCON, 0x3
171:               SPEN = 1;
0980  179D     BSF RCSTA, 0x7
172:               SYNC = 0;
0981  121E     BCF TXSTA, 0x4
173:               CREN = 1;
0982  161D     BSF RCSTA, 0x4
174:               TXEN = 1;
0983  169E     BSF TXSTA, 0x5
175:               TX9 = 1;
0984  171E     BSF TXSTA, 0x6
176:               RX9 = 1;
0985  171D     BSF RCSTA, 0x6
177:               RCIE = 1;
0986  0021     MOVLB 0x1
0987  1691     BSF PIE1, 0x5
178:               __delay_us(10);
0988  301A     MOVLW 0x1A
0989  0B89     DECFSZ WREG, F
098A  2989     GOTO 0x189
098B  3200     BRA 0x98C
179:               TranssmitOrRecieve = Recive;
098C  0022     MOVLB 0x2
098D  118E     BCF LATC, 0x3
180:               GIE = 1; //разрешение прерываний от всего
098E  178B     BSF INTCON, 0x7
181:               PEIE = 1; //разрешение прерываний от периферии
098F  170B     BSF INTCON, 0x6
182:               init_menu();
0990  3183     MOVLP 0x3
0991  2310     CALL 0x310
0992  3188     MOVLP 0x8
183:               func_init_symbols();
0993  2756     CALL 0x756
0994  3188     MOVLP 0x8
184:               __delay_ms(500);
0995  3015     MOVLW 0x15
0996  0020     MOVLB 0x0
0997  00E5     MOVWF 0x65
0998  304B     MOVLW 0x4B
0999  00E4     MOVWF 0x64
099A  30BE     MOVLW 0xBE
099B  0B89     DECFSZ WREG, F
099C  299B     GOTO 0x19B
099D  0BE4     DECFSZ 0x64, F
099E  299B     GOTO 0x19B
099F  0BE5     DECFSZ 0x65, F
09A0  299B     GOTO 0x19B
09A1  0000     NOP
185:               T1CON = 1;
09A2  3001     MOVLW 0x1
09A3  0020     MOVLB 0x0
09A4  0098     MOVWF T1CON
186:               //LED_GREEN = 1;
187:               while (1)
188:               {
189:                   set_ind_mod_chip();
09A9  3191     MOVLP 0x11
09AA  218D     CALL 0x18D
09AB  3188     MOVLP 0x8
190:                   CLRWDT();
09AC  0064     CLRWDT
191:                   ModBusTxRxFunc();
09AD  2374     CALL 0x374
09AE  3188     MOVLP 0x8
192:           #if !DEBUG
193:                   if (eeprom_read(TEST_MOD_NOT_OK_ADD))
09A5  29A9     GOTO 0x1A9
09AF  302C     MOVLW 0x2C
09B0  2265     CALL 0x265
09B1  3188     MOVLP 0x8
09B2  3A00     XORLW 0x0
09B3  1D03     BTFSS STATUS, 0x2
09B4  29A6     GOTO 0x1A6
194:                       test_mode();
09A6  3190     MOVLP 0x10
09A7  2025     CALL 0x25
09A8  3188     MOVLP 0x8
195:                   else
196:                       indicator_func();
09B5  3184     MOVLP 0x4
09B6  243D     CALL 0x43D
09B7  3188     MOVLP 0x8
09B8  29A9     GOTO 0x1A9
197:           #else
198:                   //INT32 temp;
199:                   //GET_WORD(0, temp) = DEBUG_REG(7);
200:                   //GET_WORD(1, temp) = DEBUG_REG(8);
201:                   //Symbol_Latch.indicator[0] = func_Calcul_Numeral_Ind(temp, DEBUG_REG(9));
202:                   indicator_func();
203:           #endif
204:               }
205:           }
206:           
207:           void set_ind_mod_chip() {
208:               static UINT8 show_data = 0;
209:               static UINT16 Timer_2 = 0;
210:               Timer_2 += hundler_Timers(&Timer_Interrupt_3);
118D  30E8     MOVLW 0xE8
118E  318E     MOVLP 0xE
118F  2658     CALL 0x658
1190  3190     MOVLP 0x10
1191  0820     MOVF __pcstackBANK0, W
1192  0023     MOVLB 0x3
1193  07E5     ADDWF Timer_2, F
1194  0020     MOVLB 0x0
1195  0821     MOVF addr, W
1196  0023     MOVLB 0x3
1197  3DE6     ADDWFC 0x1E6, F
211:               if (Timer_2 >= TIME_OUTDATA_IND_MKS / PERIOD_INTERRUPT_MKS)
1198  3030     MOVLW 0x30
1199  0266     SUBWF 0x1E6, W
119A  30D4     MOVLW 0xD4
119B  1903     BTFSC STATUS, 0x2
119C  0265     SUBWF Timer_2, W
119D  1C03     BTFSS STATUS, 0x0
119E  29AC     GOTO 0x1AC
212:               {
213:                   if (!exchange_MCP_completed)
119F  0022     MOVLB 0x2
11A0  0862     MOVF exchange_MCP_completed, W
11A1  1D03     BTFSS STATUS, 0x2
11A2  29A6     GOTO 0x1A6
214:                       exchange_chip();
11A3  3180     MOVLP 0x0
11A4  20C8     CALL 0xC8
11A5  3190     MOVLP 0x10
215:                   show_data = 1;
11A6  0022     MOVLB 0x2
11A7  01D7     CLRF show_data
11A8  0AD7     INCF show_data, F
216:                   Timer_2 = 0;
11A9  0023     MOVLB 0x3
11AA  01E5     CLRF Timer_2
11AB  01E6     CLRF 0x1E6
217:               }
218:           #if 0
219:               exchange_MCP_completed = 1;
220:               show_data = 1;
221:               reg_chip[0] = 0xFFFF;
222:               reg_chip[1] = 0xFFFA;
223:               reg_chip[2] = 0xFFAF;
224:               reg_chip[3] = 0xFAFF;
225:               reg_chip[4] = 0xAFFF;
226:               tr_type = 500;
227:           #endif
228:               if (exchange_MCP_completed)
11AC  0022     MOVLB 0x2
11AD  0862     MOVF exchange_MCP_completed, W
11AE  1903     BTFSC STATUS, 0x2
11AF  2AF6     GOTO 0x2F6
229:               {
230:                   UINT8 multy = tr_type / 5;
11B0  3005     MOVLW 0x5
11B1  0020     MOVLB 0x0
11B2  00A0     MOVWF __pcstackBANK0
11B3  01A1     CLRF addr
11B4  0022     MOVLB 0x2
11B5  0864     MOVF 0x164, W
11B6  0020     MOVLB 0x0
11B7  00A3     MOVWF size_Tx
11B8  0022     MOVLB 0x2
11B9  0863     MOVF tr_type, W
11BA  0020     MOVLB 0x0
11BB  00A2     MOVWF multiplicand
11BC  3182     MOVLP 0x2
11BD  2243     CALL 0x243
11BE  3190     MOVLP 0x10
11BF  0820     MOVF __pcstackBANK0, W
11C0  0022     MOVLB 0x2
11C1  00BC     MOVWF multy
231:                   INT32 temp;
232:                   temp = ((reg_chip[0] >> RESOL) * cal_const_x.P + (cal_const_y.P >> 1)) / cal_const_y.P; //активная мощность
11C2  2706     CALL 0x706
11C3  3190     MOVLP 0x10
11C4  0820     MOVF __pcstackBANK2, W
11C5  0020     MOVLB 0x0
11C6  00DF     MOVWF 0x5F
11C7  0023     MOVLB 0x3
11C8  0821     MOVF 0x1A1, W
11C9  0020     MOVLB 0x0
11CA  00E0     MOVWF 0x60
11CB  0023     MOVLB 0x3
11CC  0822     MOVF 0x1A2, W
11CD  0020     MOVLB 0x0
11CE  00E1     MOVWF 0x61
11CF  0023     MOVLB 0x3
11D0  0823     MOVF 0x1A3, W
11D1  0020     MOVLB 0x0
11D2  00E2     MOVWF 0x62
11D3  300A     MOVLW 0xA
11D4  00E3     MOVWF 0x63
11D5  27F6     CALL 0x7F6
11D6  3190     MOVLP 0x10
11D7  0BE3     DECFSZ 0x63, F
11D8  29D5     GOTO 0x1D5
11D9  2776     CALL 0x776
11DA  3190     MOVLP 0x10
11DB  3050     MOVLW 0x50
11DC  0084     MOVWF FSR0
11DD  3098     MOVLW 0x98
11DE  2730     CALL 0x730
11DF  3190     MOVLP 0x10
11E0  2644     CALL 0x644
11E1  3190     MOVLP 0x10
11E2  26F5     CALL 0x6F5
11E3  3185     MOVLP 0x5
11E4  258D     CALL 0x58D
11E5  3190     MOVLP 0x10
11E6  26A8     CALL 0x6A8
11E7  3190     MOVLP 0x10
233:                   temp *= multy;
11E8  2644     CALL 0x644
11E9  3190     MOVLP 0x10
11EA  273A     CALL 0x73A
11EB  3190     MOVLP 0x10
234:                   Active_P_Value_LSB = GET_WORD(0, temp);
11EC  3032     MOVLW 0x32
11ED  27AD     CALL 0x7AD
11EE  3190     MOVLP 0x10
235:                   Active_P_Value_MSB = GET_WORD(1, temp);
11EF  3037     MOVLW 0x37
11F0  27DF     CALL 0x7DF
11F1  3190     MOVLP 0x10
11F2  2706     CALL 0x706
11F3  3190     MOVLP 0x10
236:                   temp = ((reg_chip[1] >> RESOL) * cal_const_x.P + (cal_const_y.P >> 1)) / cal_const_y.P; //реактивная мощность
11F4  0824     MOVF size_Buff, W
11F5  0020     MOVLB 0x0
11F6  00DF     MOVWF 0x5F
11F7  0023     MOVLB 0x3
11F8  0825     MOVF 0x1A5, W
11F9  0020     MOVLB 0x0
11FA  00E0     MOVWF 0x60
11FB  0023     MOVLB 0x3
11FC  0826     MOVF 0x1A6, W
11FD  0020     MOVLB 0x0
11FE  00E1     MOVWF 0x61
11FF  0023     MOVLB 0x3
1200  0827     MOVF 0x1A7, W
1201  0020     MOVLB 0x0
1202  00E2     MOVWF 0x62
1203  300A     MOVLW 0xA
1204  00E3     MOVWF 0x63
1205  27F6     CALL 0x7F6
1206  3190     MOVLP 0x10
1207  0BE3     DECFSZ 0x63, F
1208  2A05     GOTO 0x205
1209  2776     CALL 0x776
120A  3190     MOVLP 0x10
120B  3050     MOVLW 0x50
120C  0084     MOVWF FSR0
120D  3098     MOVLW 0x98
120E  2730     CALL 0x730
120F  3190     MOVLP 0x10
1210  2644     CALL 0x644
1211  3190     MOVLP 0x10
1212  26F5     CALL 0x6F5
1213  3185     MOVLP 0x5
1214  258D     CALL 0x58D
1215  3190     MOVLP 0x10
1216  26A8     CALL 0x6A8
1217  3190     MOVLP 0x10
237:                   temp *= multy;
1218  2644     CALL 0x644
1219  3190     MOVLP 0x10
121A  273A     CALL 0x73A
121B  3190     MOVLP 0x10
238:                   Reactive_P_Value_LSB = GET_WORD(0, temp);
121C  303C     MOVLW 0x3C
121D  27AD     CALL 0x7AD
121E  3190     MOVLP 0x10
239:                   Reactive_P_Value_MSB = GET_WORD(1, temp);
121F  3041     MOVLW 0x41
1220  27DF     CALL 0x7DF
1221  3190     MOVLP 0x10
240:                   temp = (cal_const_y.F * cal_const_x.F + (reg_chip[2] >> 1)) / reg_chip[2]; //частота
1222  3008     MOVLW 0x8
1223  3EA0     ADDLW 0xA0
1224  2768     CALL 0x768
1225  3190     MOVLP 0x10
1226  0828     MOVF add, W
1227  0020     MOVLB 0x0
1228  00DA     MOVWF 0x5A
1229  0023     MOVLB 0x3
122A  0829     MOVF 0x1A9, W
122B  0020     MOVLB 0x0
122C  00DB     MOVWF 0x5B
122D  0023     MOVLB 0x3
122E  082A     MOVF 0x1AA, W
122F  0020     MOVLB 0x0
1230  00DC     MOVWF 0x5C
1231  0023     MOVLB 0x3
1232  082B     MOVF 0x1AB, W
1233  0020     MOVLB 0x0
1234  00DD     MOVWF 0x5D
1235  3001     MOVLW 0x1
1236  00DE     MOVWF 0x5E
1237  27C9     CALL 0x7C9
1238  3190     MOVLP 0x10
1239  0BDE     DECFSZ 0x5E, F
123A  2A37     GOTO 0x237
123B  300C     MOVLW 0xC
123C  3EB4     ADDLW 0xB4
123D  0086     MOVWF FSR1
123E  3001     MOVLW 0x1
123F  0087     MOVWF FSR1H
1240  3F40     MOVIW 0[FSR1]
1241  00A0     MOVWF __pcstackBANK0
1242  3F41     MOVIW 1[FSR1]
1243  00A1     MOVWF addr
1244  3F42     MOVIW 2[FSR1]
1245  00A2     MOVWF multiplicand
1246  3F43     MOVIW 3[FSR1]
1247  00A3     MOVWF size_Tx
1248  305C     MOVLW 0x5C
1249  0084     MOVWF FSR0
124A  3098     MOVLW 0x98
124B  2730     CALL 0x730
124C  3190     MOVLP 0x10
124D  2644     CALL 0x644
124E  3190     MOVLP 0x10
124F  26F5     CALL 0x6F5
1250  3185     MOVLP 0x5
1251  258D     CALL 0x58D
1252  3190     MOVLP 0x10
1253  082F     MOVF sizebuff, W
1254  26CE     CALL 0x6CE
1255  3190     MOVLP 0x10
241:                   Frequence_LSB = GET_WORD(0, temp);
1256  3152     ADDFSR 1, 18
1257  2795     CALL 0x795
1258  3190     MOVLP 0x10
242:                   Frequence_MSB = GET_WORD(1, temp);
1259  3157     ADDFSR 1, 23
125A  0849     MOVF 0x49, W
125B  3FC0     MOVWI 0[FSR1]
125C  084A     MOVF temp_SPBRG, W
125D  3FC1     MOVWI 1[FSR1]
243:                   temp = ((reg_chip[3] >> RESOL) * cal_const_x.I + (cal_const_y.I >> 1)) / cal_const_y.I; //ток
125E  3008     MOVLW 0x8
125F  3EB4     ADDLW 0xB4
1260  2768     CALL 0x768
1261  3190     MOVLP 0x10
1262  083C     MOVF i, W
1263  0020     MOVLB 0x0
1264  00DA     MOVWF 0x5A
1265  0023     MOVLB 0x3
1266  083D     MOVF 0x1BD, W
1267  0020     MOVLB 0x0
1268  00DB     MOVWF 0x5B
1269  0023     MOVLB 0x3
126A  083E     MOVF 0x1BE, W
126B  0020     MOVLB 0x0
126C  00DC     MOVWF 0x5C
126D  0023     MOVLB 0x3
126E  083F     MOVF 0x1BF, W
126F  0020     MOVLB 0x0
1270  00DD     MOVWF 0x5D
1271  3001     MOVLW 0x1
1272  00DE     MOVWF 0x5E
1273  27C9     CALL 0x7C9
1274  3190     MOVLP 0x10
1275  0BDE     DECFSZ 0x5E, F
1276  2A73     GOTO 0x273
1277  0023     MOVLB 0x3
1278  082C     MOVF 0x1AC, W
1279  0020     MOVLB 0x0
127A  00DF     MOVWF 0x5F
127B  0023     MOVLB 0x3
127C  082D     MOVF 0x1AD, W
127D  0020     MOVLB 0x0
127E  00E0     MOVWF 0x60
127F  0023     MOVLB 0x3
1280  082E     MOVF 0x1AE, W
1281  0020     MOVLB 0x0
1282  00E1     MOVWF 0x61
1283  0023     MOVLB 0x3
1284  082F     MOVF 0x1AF, W
1285  0020     MOVLB 0x0
1286  00E2     MOVWF 0x62
1287  300A     MOVLW 0xA
1288  00E3     MOVWF 0x63
1289  27F6     CALL 0x7F6
128A  3190     MOVLP 0x10
128B  0BE3     DECFSZ 0x63, F
128C  2A89     GOTO 0x289
128D  2776     CALL 0x776
128E  3190     MOVLP 0x10
128F  3058     MOVLW 0x58
1290  0084     MOVWF FSR0
1291  3098     MOVLW 0x98
1292  2730     CALL 0x730
1293  3190     MOVLP 0x10
1294  2644     CALL 0x644
1295  3190     MOVLP 0x10
1296  26F5     CALL 0x6F5
1297  3185     MOVLP 0x5
1298  258D     CALL 0x58D
1299  3190     MOVLP 0x10
129A  26A8     CALL 0x6A8
129B  3190     MOVLP 0x10
244:                   temp *= multy;
129C  2644     CALL 0x644
129D  3190     MOVLP 0x10
129E  273A     CALL 0x73A
129F  3190     MOVLP 0x10
245:                   I_Value_LSB = GET_WORD(0, temp);
12A0  27E5     CALL 0x7E5
12A1  3190     MOVLP 0x10
12A2  0847     MOVF 0x47, W
12A3  3FC0     MOVWI 0[FSR1]
12A4  0848     MOVF Timer_1, W
12A5  3FC1     MOVWI 1[FSR1]
246:                   I_Value_MSB = GET_WORD(1, temp);
12A6  302D     MOVLW 0x2D
12A7  0086     MOVWF FSR1
12A8  3023     MOVLW 0x23
12A9  0087     MOVWF FSR1H
12AA  0849     MOVF 0x49, W
12AB  3FC0     MOVWI 0[FSR1]
12AC  084A     MOVF temp_SPBRG, W
12AD  3FC1     MOVWI 1[FSR1]
247:                   temp = ((reg_chip[4] >> RESOL) * cal_const_x.U + (cal_const_y.U >> 1)) / cal_const_y.U; //напряжение
12AE  3004     MOVLW 0x4
12AF  3EB4     ADDLW 0xB4
12B0  2768     CALL 0x768
12B1  3190     MOVLP 0x10
12B2  0838     MOVF 0x38, W
12B3  0020     MOVLB 0x0
12B4  00DA     MOVWF 0x5A
12B5  0023     MOVLB 0x3
12B6  0839     MOVF 0x1B9, W
12B7  0020     MOVLB 0x0
12B8  00DB     MOVWF 0x5B
12B9  0023     MOVLB 0x3
12BA  083A     MOVF 0x1BA, W
12BB  0020     MOVLB 0x0
12BC  00DC     MOVWF 0x5C
12BD  0023     MOVLB 0x3
12BE  083B     MOVF 0x1BB, W
12BF  0020     MOVLB 0x0
12C0  00DD     MOVWF 0x5D
12C1  3001     MOVLW 0x1
12C2  00DE     MOVWF 0x5E
12C3  27C9     CALL 0x7C9
12C4  3190     MOVLP 0x10
12C5  0BDE     DECFSZ 0x5E, F
12C6  2AC3     GOTO 0x2C3
12C7  0023     MOVLB 0x3
12C8  0830     MOVF 0x1B0, W
12C9  0020     MOVLB 0x0
12CA  00DF     MOVWF 0x5F
12CB  0023     MOVLB 0x3
12CC  0831     MOVF 0x1B1, W
12CD  0020     MOVLB 0x0
12CE  00E0     MOVWF 0x60
12CF  0023     MOVLB 0x3
12D0  0832     MOVF 0x1B2, W
12D1  0020     MOVLB 0x0
12D2  00E1     MOVWF 0x61
12D3  0023     MOVLB 0x3
12D4  0833     MOVF 0x1B3, W
12D5  0020     MOVLB 0x0
12D6  00E2     MOVWF 0x62
12D7  300A     MOVLW 0xA
12D8  00E3     MOVWF 0x63
12D9  27F6     CALL 0x7F6
12DA  3190     MOVLP 0x10
12DB  0BE3     DECFSZ 0x63, F
12DC  2AD9     GOTO 0x2D9
12DD  2776     CALL 0x776
12DE  3190     MOVLP 0x10
12DF  3054     MOVLW 0x54
12E0  0084     MOVWF FSR0
12E1  3098     MOVLW 0x98
12E2  2730     CALL 0x730
12E3  3190     MOVLP 0x10
12E4  2644     CALL 0x644
12E5  3190     MOVLP 0x10
12E6  26F5     CALL 0x6F5
12E7  3185     MOVLP 0x5
12E8  258D     CALL 0x58D
12E9  3190     MOVLP 0x10
12EA  082F     MOVF sizebuff, W
12EB  26CE     CALL 0x6CE
12EC  3190     MOVLP 0x10
248:                   U_Value_LSB = GET_WORD(0, temp);
12ED  3148     ADDFSR 1, 8
12EE  2795     CALL 0x795
12EF  3190     MOVLP 0x10
249:                   U_Value_MSB = GET_WORD(1, temp);
12F0  314D     ADDFSR 1, 13
12F1  0849     MOVF 0x49, W
12F2  3FC0     MOVWI 0[FSR1]
12F3  084A     MOVF temp_SPBRG, W
12F4  3FC1     MOVWI 1[FSR1]
250:                   exchange_MCP_completed = 0;
12F5  01E2     CLRF 0x62
251:               }
252:               static indicator_t data_indicator[5];
253:               if (show_data)
12F6  0857     MOVF 0x57, W
12F7  1903     BTFSC STATUS, 0x2
12F8  2B8E     GOTO 0x38E
254:               {
255:                   INT32 temp = 0;
12FA  01C3     CLRF 0x43
12FB  01C4     CLRF temp_limit_ind
12FC  01C5     CLRF 0x45
12FD  01C6     CLRF 0x46
256:                   GET_WORD(0, temp) = U_Value_LSB;
12F9  300C     MOVLW 0xC
12FE  0086     MOVWF FSR1
12FF  3023     MOVLW 0x23
1300  0087     MOVWF FSR1H
1301  3148     ADDFSR 1, 8
1302  3F40     MOVIW 0[FSR1]
1303  00C3     MOVWF 0x43
1304  3F41     MOVIW 1[FSR1]
1305  00C4     MOVWF temp_limit_ind
1306  27B5     CALL 0x7B5
1307  3190     MOVLP 0x10
257:                   GET_WORD(1, temp) = U_Value_MSB;
1308  26E1     CALL 0x6E1
1309  3190     MOVLP 0x10
258:                   data_indicator[0] = func_Calcul_Numeral_Ind(temp, 1);
130A  01BE     CLRF shift_pos
130B  0ABE     INCF shift_pos, F
130C  2533     CALL 0x533
130D  3190     MOVLP 0x10
130E  303A     MOVLW 0x3A
130F  0086     MOVWF FSR1
1310  3000     MOVLW 0x0
1311  0087     MOVWF FSR1H
1312  3020     MOVLW 0x20
1313  0084     MOVWF FSR0
1314  3002     MOVLW 0x2
1315  0085     MOVWF FSR0H
1316  3006     MOVLW 0x6
1317  00DA     MOVWF 0x5A
1318  0016     MOVIW FSR1++
1319  001A     MOVWI FSR0++
131A  0BDA     DECFSZ 0x5A, F
131B  2B18     GOTO 0x318
259:                   data_indicator[0].S6 = U__;
131C  0022     MOVLB 0x2
131D  0861     MOVF U__, W
131E  0024     MOVLB 0x4
131F  00A5     MOVWF 0x225
260:                   data_indicator[0].S5 = Space_;
1320  0022     MOVLB 0x2
1321  0860     MOVF Space_, W
1322  0024     MOVLB 0x4
1323  00A4     MOVWF 0x224
1324  27E5     CALL 0x7E5
1325  3190     MOVLP 0x10
261:                   GET_WORD(0, temp) = I_Value_LSB;
1326  279E     CALL 0x79E
1327  3190     MOVLP 0x10
262:                   GET_WORD(1, temp) = I_Value_MSB;
1328  302D     MOVLW 0x2D
1329  0086     MOVWF FSR1L
132A  3023     MOVLW 0x23
132B  0087     MOVWF FSR1H
132C  26E1     CALL 0x6E1
132D  3190     MOVLP 0x10
263:                   data_indicator[1] = func_Calcul_Numeral_Ind(temp, 3);
132E  3003     MOVLW 0x3
132F  00BE     MOVWF Rx_Tx_data
1330  2533     CALL 0x533
1331  3190     MOVLP 0x10
1332  303A     MOVLW 0x3A
1333  0086     MOVWF FSR1L
1334  3000     MOVLW 0x0
1335  0087     MOVWF FSR1H
1336  3006     MOVLW 0x6
1337  274A     CALL 0x74A
1338  3190     MOVLP 0x10
264:                   data_indicator[1].S6 = A__;
1339  085F     MOVF 0x25F, W
133A  0024     MOVLB 0x4
133B  00AB     MOVWF 0x22B
265:                   data_indicator[1].S5 = Space_;
133C  0022     MOVLB 0x2
133D  0860     MOVF Space_, W
133E  0024     MOVLB 0x4
133F  00AA     MOVWF 0x22A
266:                   GET_WORD(0, temp) = Active_P_Value_LSB;
1340  3032     MOVLW 0x32
1341  278C     CALL 0x78C
1342  3190     MOVLP 0x10
267:                   GET_WORD(1, temp) = Active_P_Value_MSB;
1343  3037     MOVLW 0x37
1344  0086     MOVWF FSR1L
1345  26E1     CALL 0x6E1
1346  3190     MOVLP 0x10
268:                   data_indicator[2] = func_Calcul_Numeral_Ind(temp, 3);
1347  3003     MOVLW 0x3
1348  00BE     MOVWF Rx_Tx_data
1349  2533     CALL 0x533
134A  3190     MOVLP 0x10
134B  303A     MOVLW 0x3A
134C  0086     MOVWF FSR1L
134D  3000     MOVLW 0x0
134E  0087     MOVWF FSR1H
134F  300C     MOVLW 0xC
1350  274A     CALL 0x74A
1351  3190     MOVLP 0x10
269:                   data_indicator[2].S6 = P__;
1352  085E     MOVF 0x25E, W
1353  0024     MOVLB 0x4
1354  00B1     MOVWF 0x231
270:                   data_indicator[2].S5 = Space_;
1355  0022     MOVLB 0x2
1356  0860     MOVF Space_, W
1357  0024     MOVLB 0x4
1358  00B0     MOVWF 0x230
271:                   GET_WORD(0, temp) = Reactive_P_Value_LSB;
1359  303C     MOVLW 0x3C
135A  278C     CALL 0x78C
135B  3190     MOVLP 0x10
272:                   GET_WORD(1, temp) = Reactive_P_Value_MSB;
135C  3041     MOVLW 0x41
135D  0086     MOVWF FSR1L
135E  26E1     CALL 0x6E1
135F  3190     MOVLP 0x10
273:                   data_indicator[3] = func_Calcul_Numeral_Ind(temp, 3);
1360  3003     MOVLW 0x3
1361  00BE     MOVWF Rx_Tx_data
1362  2533     CALL 0x533
1363  3190     MOVLP 0x10
1364  27F1     CALL 0x7F1
1365  3190     MOVLP 0x10
1366  274A     CALL 0x74A
1367  3190     MOVLP 0x10
274:                   data_indicator[3].S6 = P__;
1368  085E     MOVF 0x25E, W
1369  0024     MOVLB 0x4
136A  00B7     MOVWF 0x237
275:                   data_indicator[3].S5 = r__;
136B  0022     MOVLB 0x2
136C  085D     MOVF r__, W
136D  0024     MOVLB 0x4
136E  00B6     MOVWF 0x236
276:                   GET_WORD(0, temp) = Frequence_LSB;
136F  300C     MOVLW 0xC
1370  0086     MOVWF FSR1L
1371  3023     MOVLW 0x23
1372  0087     MOVWF FSR1H
1373  3152     ADDFSR 1, 18
1374  279E     CALL 0x79E
1375  3190     MOVLP 0x10
277:                   GET_WORD(1, temp) = Frequence_MSB;
1376  300C     MOVLW 0xC
1377  0086     MOVWF FSR1L
1378  3023     MOVLW 0x23
1379  0087     MOVWF FSR1H
137A  3157     ADDFSR 1, 23
137B  26E1     CALL 0x6E1
137C  3190     MOVLP 0x10
278:                   data_indicator[4] = func_Calcul_Numeral_Ind(temp, 1);
137D  01BE     CLRF Rx_Tx_data
137E  0ABE     INCF Rx_Tx_data, F
137F  2533     CALL 0x533
1380  3190     MOVLP 0x10
1381  27D4     CALL 0x7D4
1382  3190     MOVLP 0x10
1383  274A     CALL 0x74A
1384  3190     MOVLP 0x10
279:                   data_indicator[4].S6 = F__;
1385  085C     MOVF Symbol_Latch, W
1386  0024     MOVLB 0x4
1387  00BD     MOVWF 0x23D
280:                   data_indicator[4].S5 = Space_;
1388  0022     MOVLB 0x2
1389  0860     MOVF Space_, W
138A  0024     MOVLB 0x4
138B  00BC     MOVWF 0x23C
281:                   show_data = 0;
138C  0022     MOVLB 0x2
138D  01D7     CLRF show_data
282:               }
283:           
284:               menu_data_ind1[0] = data_indicator[index_ind1];
138E  27CE     CALL 0x7CE
138F  318D     MOVLP 0xD
1390  259C     CALL 0x59C
1391  3190     MOVLP 0x10
1392  3E20     ADDLW 0x20
1393  0086     MOVWF FSR1L
1394  3002     MOVLW 0x2
1395  0087     MOVWF FSR1H
1396  30A0     MOVLW 0xA0
1397  0084     MOVWF FSR0L
1398  3002     MOVLW 0x2
1399  0085     MOVWF FSR0H
139A  3006     MOVLW 0x6
139B  00DA     MOVWF b__
139C  0016     MOVIW FSR1++
139D  001A     MOVWI FSR0++
139E  0BDA     DECFSZ b__, F
139F  2B9C     GOTO 0x39C
285:               menu_data_ind2[0] = data_indicator[index_ind2];
13A0  27FB     CALL 0x7FB
13A1  318D     MOVLP 0xD
13A2  259C     CALL 0x59C
13A3  3190     MOVLP 0x10
13A4  3E20     ADDLW 0x20
13A5  0086     MOVWF FSR1L
13A6  3002     MOVLW 0x2
13A7  0087     MOVWF FSR1H
13A8  3020     MOVLW 0x20
13A9  0084     MOVWF FSR0L
13AA  3003     MOVLW 0x3
13AB  0085     MOVWF FSR0H
13AC  3006     MOVLW 0x6
13AD  00DA     MOVWF b__
13AE  0016     MOVIW FSR1++
13AF  001A     MOVWI FSR0++
13B0  0BDA     DECFSZ b__, F
13B1  2BAE     GOTO 0x3AE
286:               indicator_t temp;
287:               temp.S1 = temp.S2 = temp.S3 = temp.S4 = temp.S5 = temp.S6 = Space_;
13B2  303E     MOVLW 0x3E
13B3  0086     MOVWF FSR1L
13B4  3001     MOVLW 0x1
13B5  0087     MOVWF FSR1H
13B6  3002     MOVLW 0x2
13B7  3E3D     ADDLW 0x3D
13B8  0084     MOVWF FSR0L
13B9  3001     MOVLW 0x1
13BA  0085     MOVWF FSR0H
13BB  0022     MOVLB 0x2
13BC  0860     MOVF Space_, W
13BD  00C2     MOVWF 0x142
13BE  00C1     MOVWF 0x141
13BF  00C0     MOVWF 0x140
13C0  3F80     MOVWI 0[FSR0]
13C1  3FC0     MOVWI 0[FSR1]
13C2  00BD     MOVWF temp
13C3  27CE     CALL 0x7CE
288:           
289:               menu_data_ind1[1] = data_indicator[index_ind1];
13C4  318D     MOVLP 0xD
13C5  259C     CALL 0x59C
13C6  3190     MOVLP 0x10
13C7  3E20     ADDLW 0x20
13C8  0086     MOVWF FSR1L
13C9  3002     MOVLW 0x2
13CA  0087     MOVWF FSR1H
13CB  3006     MOVLW 0x6
13CC  27BB     CALL 0x7BB
13CD  3190     MOVLP 0x10
13CE  0016     MOVIW FSR1++
13CF  001A     MOVWI FSR0++
13D0  0BDA     DECFSZ b__, F
13D1  2BCE     GOTO 0x3CE
290:               menu_data_ind2[1] = temp;
13D2  303D     MOVLW 0x3D
13D3  0086     MOVWF FSR1L
13D4  3001     MOVLW 0x1
13D5  0087     MOVWF FSR1H
13D6  3006     MOVLW 0x6
13D7  3E20     ADDLW 0x20
13D8  2762     CALL 0x762
13D9  3190     MOVLP 0x10
13DA  0016     MOVIW FSR1++
13DB  001A     MOVWI FSR0++
13DC  0BDA     DECFSZ b__, F
13DD  2BDA     GOTO 0x3DA
291:               menu_data_ind1[2] = temp;
13DE  303D     MOVLW 0x3D
13DF  0086     MOVWF FSR1L
13E0  3001     MOVLW 0x1
13E1  0087     MOVWF FSR1H
13E2  300C     MOVLW 0xC
13E3  27BB     CALL 0x7BB
13E4  3190     MOVLP 0x10
13E5  0016     MOVIW FSR1++
13E6  001A     MOVWI FSR0++
13E7  0BDA     DECFSZ b__, F
13E8  2BE5     GOTO 0x3E5
13E9  27FB     CALL 0x7FB
292:               menu_data_ind2[2] = data_indicator[index_ind2];
13EA  318D     MOVLP 0xD
13EB  259C     CALL 0x59C
13EC  3190     MOVLP 0x10
13ED  3E20     ADDLW 0x20
13EE  0086     MOVWF FSR1L
13EF  3002     MOVLW 0x2
13F0  0087     MOVWF FSR1H
13F1  300C     MOVLW 0xC
13F2  2756     CALL 0x756
13F3  3190     MOVLP 0x10
293:           
294:               menu_data_ind1[3].S6 = A__;
13F4  085F     MOVF A__, W
13F5  0025     MOVLB 0x5
13F6  00B7     MOVWF 0x2B7
295:               menu_data_ind1[3].S5 = d__;
13F7  0022     MOVLB 0x2
13F8  085B     MOVF d__, W
13F9  0025     MOVLB 0x5
13FA  00B6     MOVWF 0x2B6
296:               menu_data_ind1[3].S4 = d__;
13FB  0022     MOVLB 0x2
13FC  085B     MOVF d__, W
13FD  0025     MOVLB 0x5
13FE  00B5     MOVWF 0x2B5
297:               menu_data_ind1[3].S3 = r__;
13FF  0022     MOVLB 0x2
1400  085D     MOVF r__, W
1401  0025     MOVLB 0x5
1402  00B4     MOVWF 0x2B4
298:               menu_data_ind1[3].S2 = Space_;
1403  0022     MOVLB 0x2
1404  0860     MOVF Space_, W
1405  0025     MOVLB 0x5
1406  00B3     MOVWF 0x2B3
299:               menu_data_ind1[3].S1 = Space_;
1407  0022     MOVLB 0x2
1408  0860     MOVF Space_, W
1409  0025     MOVLB 0x5
140A  00B2     MOVWF 0x2B2
300:               menu_data_ind2[3] = func_Calcul_Numeral_Ind(addres_device, 0);
140B  0022     MOVLB 0x2
140C  086D     MOVF addres_device, W
140D  0020     MOVLB 0x0
140E  00BA     MOVWF S_Number
140F  0022     MOVLB 0x2
1410  086E     MOVF 0x16E, W
1411  27EB     CALL 0x7EB
1412  3190     MOVLP 0x10
1413  2533     CALL 0x533
1414  3190     MOVLP 0x10
1415  27F1     CALL 0x7F1
1416  3190     MOVLP 0x10
1417  2756     CALL 0x756
1418  3190     MOVLP 0x10
301:           
302:               menu_data_ind1[4].S6 = b__;
1419  085A     MOVF b__, W
141A  0025     MOVLB 0x5
141B  00BD     MOVWF 0x2BD
303:               menu_data_ind1[4].S5 = r__;
141C  0022     MOVLB 0x2
141D  085D     MOVF r__, W
141E  0025     MOVLB 0x5
141F  00BC     MOVWF 0x2BC
304:               menu_data_ind1[4].S4 = Space_;
1420  0022     MOVLB 0x2
1421  0860     MOVF Space_, W
1422  0025     MOVLB 0x5
1423  00BB     MOVWF 0x2BB
305:               menu_data_ind1[4].S3 = Space_;
1424  0022     MOVLB 0x2
1425  0860     MOVF Space_, W
1426  0025     MOVLB 0x5
1427  00BA     MOVWF 0x2BA
306:               menu_data_ind1[4].S2 = Space_;
1428  0022     MOVLB 0x2
1429  0860     MOVF Space_, W
142A  0025     MOVLB 0x5
142B  00B9     MOVWF 0x2B9
307:               menu_data_ind1[4].S1 = Space_;
142C  0022     MOVLB 0x2
142D  0860     MOVF Space_, W
142E  0025     MOVLB 0x5
142F  00B8     MOVWF 0x2B8
308:               menu_data_ind2[4] = func_Calcul_Numeral_Ind(CALCUL_SPEED_DEV_BIT_S(speed_device) / 100, 1);
1430  0022     MOVLB 0x2
1431  086B     MOVF speed_device, W
1432  046C     IORWF 0x16C, W
1433  1903     BTFSC STATUS, 0x2
1434  2CAA     GOTO 0x4AA
1435  036B     DECF speed_device, W
1436  046C     IORWF 0x16C, W
1437  1903     BTFSC STATUS, 0x2
1438  2C9C     GOTO 0x49C
1439  3002     MOVLW 0x2
143A  066B     XORWF speed_device, W
143B  046C     IORWF 0x16C, W
143C  1903     BTFSC STATUS, 0x2
143D  2C8F     GOTO 0x48F
143E  3003     MOVLW 0x3
143F  066B     XORWF speed_device, W
1440  046C     IORWF 0x16C, W
1441  1903     BTFSC STATUS, 0x2
1442  2C80     GOTO 0x480
1443  3004     MOVLW 0x4
1444  066B     XORWF speed_device, W
1445  046C     IORWF 0x16C, W
1446  1903     BTFSC STATUS, 0x2
1447  2C73     GOTO 0x473
1448  3005     MOVLW 0x5
1449  066B     XORWF speed_device, W
144A  046C     IORWF 0x16C, W
144B  1903     BTFSC STATUS, 0x2
144C  2C65     GOTO 0x465
144D  3006     MOVLW 0x6
144E  066B     XORWF speed_device, W
144F  046C     IORWF 0x16C, W
1450  3001     MOVLW 0x1
1451  1903     BTFSC STATUS, 0x2
1452  2C57     GOTO 0x457
1453  01BB     CLRF 0x13B
1454  00BA     MOVWF 0x13A
1455  30C2     MOVLW 0xC2
1456  2C5A     GOTO 0x45A
1457  01BB     CLRF 0x13B
1458  00BA     MOVWF 0x13A
1459  302C     MOVLW 0x2C
145A  00B9     MOVWF 0x139
145B  01B8     CLRF 0x138
145C  083B     MOVF 0x13B, W
145D  00B7     MOVWF 0x137
145E  083A     MOVF 0x13A, W
145F  00B6     MOVWF 0x136
1460  0839     MOVF 0x139, W
1461  00B5     MOVWF 0x135
1462  0838     MOVF 0x138, W
1463  00B4     MOVWF 0x134
1464  2C6A     GOTO 0x46A
1465  30E1     MOVLW 0xE1
1466  01B7     CLRF 0x137
1467  01B6     CLRF 0x136
1468  00B5     MOVWF 0x135
1469  01B4     CLRF 0x134
146A  0837     MOVF 0x137, W
146B  00B3     MOVWF 0x133
146C  0836     MOVF 0x136, W
146D  00B2     MOVWF 0x132
146E  0835     MOVF 0x135, W
146F  00B1     MOVWF 0x131
1470  0834     MOVF 0x134, W
1471  00B0     MOVWF 0x130
1472  2C78     GOTO 0x478
1473  3096     MOVLW 0x96
1474  01B3     CLRF 0x133
1475  01B2     CLRF 0x132
1476  00B1     MOVWF 0x131
1477  01B0     CLRF 0x130
1478  0833     MOVF 0x133, W
1479  00AF     MOVWF 0x12F
147A  0832     MOVF 0x132, W
147B  00AE     MOVWF 0x12E
147C  0831     MOVF 0x131, W
147D  00AD     MOVWF 0x12D
147E  0830     MOVF 0x130, W
147F  2C85     GOTO 0x485
1480  3070     MOVLW 0x70
1481  01AF     CLRF 0x12F
1482  01AE     CLRF 0x12E
1483  00AD     MOVWF 0x12D
1484  3080     MOVLW 0x80
1485  00AC     MOVWF 0x12C
1486  082F     MOVF 0x12F, W
1487  00AB     MOVWF 0x12B
1488  082E     MOVF 0x12E, W
1489  00AA     MOVWF 0x12A
148A  082D     MOVF 0x12D, W
148B  00A9     MOVWF 0x129
148C  082C     MOVF 0x12C, W
148D  00A8     MOVWF 0x128
148E  2C94     GOTO 0x494
148F  304B     MOVLW 0x4B
1490  01AB     CLRF 0x12B
1491  01AA     CLRF 0x12A
1492  00A9     MOVWF 0x129
1493  01A8     CLRF 0x128
1494  082B     MOVF 0x12B, W
1495  00A7     MOVWF 0x127
1496  082A     MOVF 0x12A, W
1497  00A6     MOVWF 0x126
1498  0829     MOVF 0x129, W
1499  00A5     MOVWF 0x125
149A  0828     MOVF 0x128, W
149B  2CA1     GOTO 0x4A1
149C  3038     MOVLW 0x38
149D  01A7     CLRF 0x127
149E  01A6     CLRF 0x126
149F  00A5     MOVWF 0x125
14A0  3040     MOVLW 0x40
14A1  00A4     MOVWF 0x124
14A2  0827     MOVF 0x127, W
14A3  00A3     MOVWF 0x123
14A4  0826     MOVF 0x126, W
14A5  00A2     MOVWF 0x122
14A6  0825     MOVF 0x125, W
14A7  00A1     MOVWF 0x121
14A8  0824     MOVF 0x124, W
14A9  2CAF     GOTO 0x4AF
14AA  3025     MOVLW 0x25
14AB  01A3     CLRF 0x123
14AC  01A2     CLRF 0x122
14AD  00A1     MOVWF 0x121
14AE  3080     MOVLW 0x80
14AF  00A0     MOVWF __pcstackBANK2
14B0  3064     MOVLW 0x64
14B1  0020     MOVLB 0x0
14B2  00AC     MOVWF divisor
14B3  01AD     CLRF cnt_i
14B4  01AE     CLRF buff_read
14B5  01AF     CLRF sizebuff
14B6  0022     MOVLB 0x2
14B7  0823     MOVF 0x123, W
14B8  0020     MOVLB 0x0
14B9  00B3     MOVWF command
14BA  0022     MOVLB 0x2
14BB  0822     MOVF 0x122, W
14BC  0020     MOVLB 0x0
14BD  00B2     MOVWF wr_rd
14BE  0022     MOVLB 0x2
14BF  0821     MOVF 0x121, W
14C0  0020     MOVLB 0x0
14C1  00B1     MOVWF 0x31
14C2  0022     MOVLB 0x2
14C3  0820     MOVF __pcstackBANK2, W
14C4  0020     MOVLB 0x0
14C5  00B0     MOVWF ad_current
14C6  3185     MOVLP 0x5
14C7  258D     CALL 0x58D
14C8  3190     MOVLP 0x10
14C9  082F     MOVF sizebuff, W
14CA  00BD     MOVWF adressReg_wr
14CB  082E     MOVF buff_read, W
14CC  00BC     MOVWF i
14CD  082D     MOVF cnt_i, W
14CE  00BB     MOVWF flag_read
14CF  082C     MOVF divisor, W
14D0  00BA     MOVWF S_Number
14D1  01BE     CLRF shift_pos
14D2  0ABE     INCF shift_pos, F
14D3  2533     CALL 0x533
14D4  3190     MOVLP 0x10
14D5  27D4     CALL 0x7D4
14D6  3190     MOVLP 0x10
14D7  2756     CALL 0x756
14D8  3190     MOVLP 0x10
309:           
310:               menu_data_ind1[5].S6 = t__;
14D9  0859     MOVF 0x59, W
14DA  0025     MOVLB 0x5
14DB  00C3     MOVWF 0x2C3
311:               menu_data_ind1[5].S5 = r__;
14DC  0022     MOVLB 0x2
14DD  085D     MOVF r__, W
14DE  0025     MOVLB 0x5
14DF  00C2     MOVWF 0x2C2
312:               menu_data_ind1[5].S4 = Space_;
14E0  0022     MOVLB 0x2
14E1  0860     MOVF Space_, W
14E2  0025     MOVLB 0x5
14E3  00C1     MOVWF 0x2C1
313:               menu_data_ind1[5].S3 = Space_;
14E4  0022     MOVLB 0x2
14E5  0860     MOVF Space_, W
14E6  0025     MOVLB 0x5
14E7  00C0     MOVWF 0x2C0
314:               menu_data_ind1[5].S2 = Space_;
14E8  0022     MOVLB 0x2
14E9  0860     MOVF Space_, W
14EA  0025     MOVLB 0x5
14EB  00BF     MOVWF 0x2BF
315:               menu_data_ind1[5].S1 = Space_;
14EC  0022     MOVLB 0x2
14ED  0860     MOVF Space_, W
14EE  0025     MOVLB 0x5
14EF  00BE     MOVWF 0x2BE
316:               menu_data_ind2[5] = func_Calcul_Numeral_Ind(tr_type, 0);
14F0  0022     MOVLB 0x2
14F1  0863     MOVF tr_type, W
14F2  0020     MOVLB 0x0
14F3  00BA     MOVWF S_Number
14F4  0022     MOVLB 0x2
14F5  0864     MOVF 0x164, W
14F6  27EB     CALL 0x7EB
14F7  3190     MOVLP 0x10
14F8  2533     CALL 0x533
14F9  3190     MOVLP 0x10
14FA  303A     MOVLW 0x3A
14FB  0086     MOVWF FSR1L
14FC  3000     MOVLW 0x0
14FD  0087     MOVWF FSR1H
14FE  301E     MOVLW 0x1E
14FF  2756     CALL 0x756
1500  3190     MOVLP 0x10
317:           
318:               menu_data_ind1[6].S6 = P__;
1501  085E     MOVF P__, W
1502  0025     MOVLB 0x5
1503  00C9     MOVWF 0x2C9
319:               menu_data_ind1[6].S5 = H__;
1504  0022     MOVLB 0x2
1505  0858     MOVF H__, W
1506  0025     MOVLB 0x5
1507  00C8     MOVWF 0x2C8
320:               menu_data_ind1[6].S4 = Space_;
1508  0022     MOVLB 0x2
1509  0860     MOVF Space_, W
150A  0025     MOVLB 0x5
150B  00C7     MOVWF 0x2C7
321:               menu_data_ind1[6].S3 = Space_;
150C  0022     MOVLB 0x2
150D  0860     MOVF Space_, W
150E  0025     MOVLB 0x5
150F  00C6     MOVWF 0x2C6
322:               menu_data_ind1[6].S2 = Space_;
1510  0022     MOVLB 0x2
1511  0860     MOVF Space_, W
1512  0025     MOVLB 0x5
1513  00C5     MOVWF 0x2C5
323:               menu_data_ind1[6].S1 = Space_;
1514  0022     MOVLB 0x2
1515  0860     MOVF Space_, W
1516  0025     MOVLB 0x5
1517  00C4     MOVWF 0x2C4
324:               menu_data_ind2[6] = func_Calcul_Numeral_Ind(phase_correct, 3);
1518  0022     MOVLB 0x2
1519  0869     MOVF phase_correct, W
151A  0020     MOVLB 0x0
151B  00BA     MOVWF S_Number
151C  0022     MOVLB 0x2
151D  086A     MOVF 0x16A, W
151E  0020     MOVLB 0x0
151F  00BB     MOVWF flag_read
1520  3003     MOVLW 0x3
1521  01BC     CLRF i
1522  01BD     CLRF adressReg_wr
1523  00BE     MOVWF shift_pos
1524  2533     CALL 0x533
1525  3190     MOVLP 0x10
1526  303A     MOVLW 0x3A
1527  0086     MOVWF FSR1
1528  3000     MOVLW 0x0
1529  0087     MOVWF FSR1H
152A  3024     MOVLW 0x24
152B  3E20     ADDLW 0x20
152C  2762     CALL 0x762
152D  3190     MOVLP 0x10
152E  0016     MOVIW FSR1++
152F  001A     MOVWI FSR0++
1530  0BDA     DECFSZ 0x5A, F
1531  2D2E     GOTO 0x52E
325:           }
1532  0008     RETURN
326:           
327:           void test_mode() {
328:           #define WAIT_FRONT_P_ACTIVE 1
329:           #define WAIT 2
330:           #define CAL_T1_BAD 3
331:           #define DELAY_CAL_MKS 1000000
332:           
333:               static struct {
334:                   UINT8 front_P : 1;
335:                   UINT8 cal_t1_completed : 1;
336:                   UINT8 comand_completed : 1;
337:               } step_test;
338:           
339:               BUTTON_STATE_REG = !BUTTON_PLUS || !BUTTON_MINUS || !BUTTON_ENTER || !BUTTON_ESC;
1025  0020     MOVLB 0x0
1026  01AB     CLRF eep_add
1027  0AAB     INCF eep_add, F
1028  188C     BTFSC PORTA, 0x1
1029  1F0E     BTFSS PORTC, 0x6
102A  282F     GOTO 0x2F
102B  180C     BTFSC PORTA, 0x0
102C  1D8C     BTFSS PORTA, 0x3
102D  282F     GOTO 0x2F
102E  01AB     CLRF eep_add
102F  082B     MOVF eep_add, W
1030  00A6     MOVWF index
1031  307D     MOVLW 0x7D
1032  01A7     CLRF byte
1033  0086     MOVWF FSR1
1034  3023     MOVLW 0x23
1035  0087     MOVWF FSR1H
1036  0826     MOVF index, W
1037  3FC0     MOVWI 0[FSR1]
1038  0827     MOVF byte, W
1039  3FC1     MOVWI 1[FSR1]
340:           
341:               UINT16 delta_time = hundler_Timers(&Timer_Interrupt);
103A  30EC     MOVLW 0xEC
103B  318E     MOVLP 0xE
103C  2658     CALL 0x658
103D  3190     MOVLP 0x10
103E  0821     MOVF addr, W
103F  00AD     MOVWF cnt_i
1040  0820     MOVF __pcstackBANK0, W
1041  00AC     MOVWF divisor
342:           
343:               static UINT16 del_cal = 0;
344:               if (!step_test.front_P)
1042  186B     BTFSC step_test, 0x0
1043  2863     GOTO 0x63
345:               {
346:                   CAL_STATE = WAIT_FRONT_P_ACTIVE;
1044  3082     MOVLW 0x82
1045  3182     MOVLP 0x2
1046  22D3     CALL 0x2D3
1047  3190     MOVLP 0x10
347:                   UINT32 temp;
348:                   GET_WORD(0, temp) = U_Value_LSB;
1048  300C     MOVLW 0xC
1049  0086     MOVWF FSR1
104A  3148     ADDFSR 1, 8
104B  3F40     MOVIW 0[FSR1]
104C  00AE     MOVWF buff_read
104D  3F41     MOVIW 1[FSR1]
104E  00AF     MOVWF sizebuff
349:                   GET_WORD(1, temp) = U_Value_MSB;
104F  27B5     CALL 0x7B5
1050  3190     MOVLP 0x10
1051  3F40     MOVIW 0[FSR1]
1052  00B0     MOVWF ad_current
1053  3F41     MOVIW 1[FSR1]
1054  00B1     MOVWF 0x31
350:                   if (temp > 10000)
1055  0831     MOVF 0x31, W
1056  1D03     BTFSS STATUS, 0x2
1057  2861     GOTO 0x61
1058  0830     MOVF ad_current, W
1059  1D03     BTFSS STATUS, 0x2
105A  2861     GOTO 0x61
105B  3011     MOVLW 0x11
105C  022E     SUBWF buff_read, W
105D  3027     MOVLW 0x27
105E  3B2F     SUBWFB sizebuff, W
105F  1C03     BTFSS STATUS, 0x0
1060  2958     GOTO 0x158
351:                       step_test.front_P = 1;
1061  146B     BSF step_test, 0x0
1062  2958     GOTO 0x158
352:               } else if (!step_test.cal_t1_completed)
1063  18EB     BTFSC step_test, 0x1
1064  294B     GOTO 0x14B
353:               {
354:                   if (step_test.comand_completed)
1065  1D6B     BTFSS step_test, 0x2
1066  2876     GOTO 0x76
355:                   {
356:                       if (!error_cal)
1067  086C     MOVF error_cal, W
1068  1D03     BTFSS STATUS, 0x2
1069  286D     GOTO 0x6D
357:                       {
358:                           step_test.cal_t1_completed = 1;
106A  14EB     BSF step_test, 0x1
359:                           step_test.comand_completed = 0;
106B  116B     BCF step_test, 0x2
360:                       } else
106C  2958     GOTO 0x158
361:                           CAL_STATE = CAL_T1_BAD;
106D  3082     MOVLW 0x82
106E  0086     MOVWF FSR1
106F  3023     MOVLW 0x23
1070  0087     MOVWF FSR1H
1071  3003     MOVLW 0x3
1072  3FC0     MOVWI 0[FSR1]
1073  3000     MOVLW 0x0
1074  3FC1     MOVWI 1[FSR1]
1075  2958     GOTO 0x158
362:                   } else
363:                   {
364:                       CAL_STATE = WAIT;
1076  3082     MOVLW 0x82
1077  0086     MOVWF FSR1
1078  3023     MOVLW 0x23
1079  0087     MOVWF FSR1H
107A  3002     MOVLW 0x2
107B  3FC0     MOVWI 0[FSR1]
107C  3000     MOVLW 0x0
107D  3FC1     MOVWI 1[FSR1]
365:                       del_cal += delta_time;
107E  082C     MOVF divisor, W
107F  0023     MOVLB 0x3
1080  07E3     ADDWF del_cal, F
1081  0020     MOVLB 0x0
1082  082D     MOVF cnt_i, W
1083  0023     MOVLB 0x3
1084  3DE4     ADDWFC 0x1E4, F
366:                       if (del_cal > DELAY_CAL_MKS / PERIOD_INTERRUPT_MKS)
1085  3018     MOVLW 0x18
1086  0264     SUBWF 0x1E4, W
1087  306B     MOVLW 0x6B
1088  1903     BTFSC STATUS, 0x2
1089  0263     SUBWF del_cal, W
108A  1C03     BTFSS STATUS, 0x0
108B  2958     GOTO 0x158
367:                       {
368:                           del_cal = 0;
108C  01E3     CLRF del_cal
108D  01E4     CLRF 0x1E4
369:                           if (reg_chip[0] < 0)
108E  1FA3     BTFSS 0x1A3, 0x7
108F  289B     GOTO 0x9B
370:                               reg_chip[0] = -reg_chip[0];
1090  09A0     COMF reg_chip, F
1091  09A1     COMF 0x1A1, F
1092  09A2     COMF 0x1A2, F
1093  09A3     COMF 0x1A3, F
1094  0AA0     INCF reg_chip, F
1095  1903     BTFSC STATUS, 0x2
1096  0AA1     INCF 0x1A1, F
1097  1903     BTFSC STATUS, 0x2
1098  0AA2     INCF 0x1A2, F
1099  1903     BTFSC STATUS, 0x2
109A  0AA3     INCF 0x1A3, F
371:                           cal_const_y.P = reg_chip[0] >> RESOL;
109B  0823     MOVF 0x1A3, W
109C  00B7     MOVWF 0x1B7
109D  0822     MOVF 0x1A2, W
109E  00B6     MOVWF 0x1B6
109F  0821     MOVF 0x1A1, W
10A0  00B5     MOVWF 0x1B5
10A1  0820     MOVF reg_chip, W
10A2  00B4     MOVWF cal_const_y
10A3  300A     MOVLW 0xA
10A4  0020     MOVLB 0x0
10A5  00A6     MOVWF index
10A6  0023     MOVLB 0x3
10A7  37B7     ASRF 0x1B7, F
10A8  0CB6     RRF 0x1B6, F
10A9  0CB5     RRF 0x1B5, F
10AA  0CB4     RRF cal_const_y, F
10AB  0020     MOVLB 0x0
10AC  0BA6     DECFSZ index, F
10AD  28A6     GOTO 0xA6
372:                           cal_const_y.F = reg_chip[2];
10AE  3008     MOVLW 0x8
10AF  3EA0     ADDLW 0xA0
10B0  0086     MOVWF FSR1
10B1  3001     MOVLW 0x1
10B2  0087     MOVWF FSR1H
10B3  3F40     MOVIW 0[FSR1]
10B4  0023     MOVLB 0x3
10B5  00C0     MOVWF 0x1C0
10B6  3F41     MOVIW 1[FSR1]
10B7  00C1     MOVWF 0x1C1
10B8  3F42     MOVIW 2[FSR1]
10B9  00C2     MOVWF 0x1C2
10BA  3F43     MOVIW 3[FSR1]
10BB  00C3     MOVWF 0x1C3
373:                           cal_const_y.I = reg_chip[3] >> RESOL;
10BC  082C     MOVF 0x1AC, W
10BD  0020     MOVLB 0x0
10BE  00A6     MOVWF index
10BF  0023     MOVLB 0x3
10C0  082D     MOVF 0x1AD, W
10C1  0020     MOVLB 0x0
10C2  00A7     MOVWF byte
10C3  0023     MOVLB 0x3
10C4  082E     MOVF 0x1AE, W
10C5  0020     MOVLB 0x0
10C6  00A8     MOVWF add
10C7  0023     MOVLB 0x3
10C8  082F     MOVF 0x1AF, W
10C9  0020     MOVLB 0x0
10CA  00A9     MOVWF crcTx
10CB  300A     MOVLW 0xA
10CC  00AA     MOVWF data
10CD  2188     CALL 0x188
10CE  3190     MOVLP 0x10
10CF  0BAA     DECFSZ data, F
10D0  28CD     GOTO 0xCD
10D1  0829     MOVF crcTx, W
10D2  0023     MOVLB 0x3
10D3  00BF     MOVWF 0x1BF
10D4  0020     MOVLB 0x0
10D5  0828     MOVF add, W
10D6  0023     MOVLB 0x3
10D7  00BE     MOVWF 0x1BE
10D8  0020     MOVLB 0x0
10D9  0827     MOVF byte, W
10DA  0023     MOVLB 0x3
10DB  00BD     MOVWF 0x1BD
10DC  0020     MOVLB 0x0
10DD  0826     MOVF index, W
10DE  0023     MOVLB 0x3
10DF  00BC     MOVWF 0x1BC
374:                           cal_const_y.U = reg_chip[4] >> RESOL;
10E0  0830     MOVF 0x1B0, W
10E1  0020     MOVLB 0x0
10E2  00A6     MOVWF index
10E3  0023     MOVLB 0x3
10E4  0831     MOVF 0x1B1, W
10E5  0020     MOVLB 0x0
10E6  00A7     MOVWF byte
10E7  0023     MOVLB 0x3
10E8  0832     MOVF 0x1B2, W
10E9  0020     MOVLB 0x0
10EA  00A8     MOVWF add
10EB  0023     MOVLB 0x3
10EC  0833     MOVF 0x1B3, W
10ED  0020     MOVLB 0x0
10EE  00A9     MOVWF crcTx
10EF  300A     MOVLW 0xA
10F0  00AA     MOVWF data
10F1  2188     CALL 0x188
10F2  3190     MOVLP 0x10
10F3  0BAA     DECFSZ data, F
10F4  28F1     GOTO 0xF1
10F5  0829     MOVF crcTx, W
10F6  0023     MOVLB 0x3
10F7  00BB     MOVWF 0x1BB
10F8  0020     MOVLB 0x0
10F9  0828     MOVF add, W
10FA  0023     MOVLB 0x3
10FB  00BA     MOVWF 0x1BA
10FC  0020     MOVLB 0x0
10FD  0827     MOVF byte, W
10FE  0023     MOVLB 0x3
10FF  00B9     MOVWF 0x1B9
1100  0020     MOVLB 0x0
1101  0826     MOVF index, W
1102  0023     MOVLB 0x3
1103  00B8     MOVWF 0x1B8
375:                           EEPR_WRITE(CAL_CONST_P_ADD, cal_const_y.P);
1104  0020     MOVLB 0x0
1105  01B2     CLRF wr_rd
1106  0832     MOVF wr_rd, W
1107  3EB4     ADDLW 0xB4
1108  318F     MOVLP 0xF
1109  2706     CALL 0x706
110A  3190     MOVLP 0x10
110B  0832     MOVF wr_rd, W
110C  3C38     SUBLW 0x38
110D  318B     MOVLP 0xB
110E  2357     CALL 0x357
110F  3190     MOVLP 0x10
1110  0020     MOVLB 0x0
1111  3004     MOVLW 0x4
1112  0AB2     INCF wr_rd, F
1113  0232     SUBWF wr_rd, W
1114  1C03     BTFSS STATUS, 0x0
1115  2906     GOTO 0x106
376:                           EEPR_WRITE(CAL_CONST_I_ADD, cal_const_y.I);
1116  01B3     CLRF command
1117  0833     MOVF command, W
1118  3EBC     ADDLW 0xBC
1119  318F     MOVLP 0xF
111A  2706     CALL 0x706
111B  3190     MOVLP 0x10
111C  0833     MOVF command, W
111D  3C34     SUBLW 0x34
111E  318B     MOVLP 0xB
111F  2357     CALL 0x357
1120  3190     MOVLP 0x10
1121  0020     MOVLB 0x0
1122  3004     MOVLW 0x4
1123  0AB3     INCF command, F
1124  0233     SUBWF command, W
1125  1C03     BTFSS STATUS, 0x0
1126  2917     GOTO 0x117
377:                           EEPR_WRITE(CAL_CONST_U_ADD, cal_const_y.U);
1127  01B4     CLRF error_adr
1128  0834     MOVF error_adr, W
1129  3EB8     ADDLW 0xB8
112A  318F     MOVLP 0xF
112B  2706     CALL 0x706
112C  3190     MOVLP 0x10
112D  0834     MOVF error_adr, W
112E  3C30     SUBLW 0x30
112F  318B     MOVLP 0xB
1130  2357     CALL 0x357
1131  3190     MOVLP 0x10
1132  0020     MOVLB 0x0
1133  3004     MOVLW 0x4
1134  0AB4     INCF error_adr, F
1135  0234     SUBWF error_adr, W
1136  1C03     BTFSS STATUS, 0x0
1137  2928     GOTO 0x128
378:                           EEPR_WRITE(CAL_CONST_F_ADD, cal_const_y.F);
1138  01B5     CLRF adressReg_wr
1139  0835     MOVF adressReg_wr, W
113A  3EC0     ADDLW 0xC0
113B  318F     MOVLP 0xF
113C  2706     CALL 0x706
113D  3190     MOVLP 0x10
113E  0835     MOVF adressReg_wr, W
113F  3C3C     SUBLW 0x3C
1140  318B     MOVLP 0xB
1141  2357     CALL 0x357
1142  3190     MOVLP 0x10
1143  0020     MOVLB 0x0
1144  3004     MOVLW 0x4
1145  0AB5     INCF adressReg_wr, F
1146  0235     SUBWF adressReg_wr, W
1147  1C03     BTFSS STATUS, 0x0
1148  2939     GOTO 0x139
379:           
380:                           step_test.comand_completed = 1;
1149  156B     BSF step_test, 0x2
114A  2958     GOTO 0x158
381:                       }
382:                   }
383:               } else
384:               {
385:                   CAL_STATE = 0xFF;
114B  3082     MOVLW 0x82
114C  0086     MOVWF FSR1
114D  3023     MOVLW 0x23
114E  0087     MOVWF FSR1H
114F  30FF     MOVLW 0xFF
1150  3FC0     MOVWI 0[FSR1]
1151  3000     MOVLW 0x0
1152  3FC1     MOVWI 1[FSR1]
386:                   eeprom_write(TEST_MOD_NOT_OK_ADD, 0);
1153  302C     MOVLW 0x2C
1154  01A0     CLRF __pcstackBANK0
1155  318B     MOVLP 0xB
1156  2357     CALL 0x357
1157  3190     MOVLP 0x10
387:               }
388:               error_cal = 0;
1158  0020     MOVLB 0x0
1159  01EC     CLRF error_cal
389:           
390:               static UINT16 Time_1S = 0;
391:               Time_1S += delta_time;
115A  082C     MOVF divisor, W
115B  0023     MOVLB 0x3
115C  07E1     ADDWF Time_1S, F
115D  0020     MOVLB 0x0
115E  082D     MOVF cnt_i, W
115F  0023     MOVLB 0x3
1160  3DE2     ADDWFC 0x1E2, F
392:               if (Time_1S >= 1000000 / PERIOD_INTERRUPT_MKS)
1161  3018     MOVLW 0x18
1162  0262     SUBWF 0x1E2, W
1163  306A     MOVLW 0x6A
1164  1903     BTFSC STATUS, 0x2
1165  0261     SUBWF Time_1S, W
1166  1C03     BTFSS STATUS, 0x0
1167  0008     RETURN
393:               {
394:                   static UINT8 current_check_num = 0;
395:                   for (UINT8 index = 0; index < sizeof (indicator_t); index++)
1168  0020     MOVLB 0x0
1169  01B6     CLRF error_adr
117A  3006     MOVLW 0x6
117B  0AB6     INCF error_adr, F
117C  0236     SUBWF error_adr, W
117D  1C03     BTFSS STATUS, 0x0
117E  296A     GOTO 0x16A
396:                   {
397:                       Symbol_Latch.indicator[0].mas[index] = Numeral[current_check_num];
116A  0836     MOVF error_adr, W
116B  3E5C     ADDLW 0x5C
116C  0086     MOVWF FSR1
116D  3002     MOVLW 0x2
116E  0087     MOVWF FSR1H
116F  086A     MOVF current_check_num, W
1170  27C2     CALL 0x7C2
1171  3190     MOVLP 0x10
398:                       Symbol_Latch.indicator[1].mas[index] = Numeral[current_check_num];
1172  0836     MOVF error_adr, W
1173  3E62     ADDLW 0x62
1174  0086     MOVWF FSR1
1175  086A     MOVF current_check_num, W
1176  3E4B     ADDLW 0x4B
1177  0084     MOVWF FSR0
1178  0800     MOVF INDF0, W
1179  0081     MOVWF INDF1
399:                   }
400:                   if (++current_check_num >= 10)
117F  300A     MOVLW 0xA
1180  0AEA     INCF current_check_num, F
1181  026A     SUBWF current_check_num, W
1182  1803     BTFSC STATUS, 0x0
401:                       current_check_num = 0;
1183  01EA     CLRF current_check_num
402:                   Time_1S = 0;
1184  0023     MOVLB 0x3
1185  01E1     CLRF Time_1S
1186  01E2     CLRF 0x1E2
403:               }
404:           }
1187  0008     RETURN
405:           
406:           void func_reset_all() {
407:           
408:               cal_const_y.U = cal_const_x.U;
0A7C  3054     MOVLW 0x54
0A7D  0084     MOVWF FSR0L
0A7E  3098     MOVLW 0x98
0A7F  0085     MOVWF FSR0H
0A80  3F00     MOVIW 0[FSR0]
0A81  00B8     MOVWF 0x1B8
0A82  3F01     MOVIW 1[FSR0]
0A83  00B9     MOVWF 0x1B9
0A84  3F02     MOVIW 2[FSR0]
0A85  00BA     MOVWF 0x1BA
0A86  3F03     MOVIW 3[FSR0]
0A87  00BB     MOVWF 0x1BB
409:               cal_const_y.I = cal_const_x.I;
0A88  3058     MOVLW 0x58
0A89  0084     MOVWF FSR0L
0A8A  3098     MOVLW 0x98
0A8B  0085     MOVWF FSR0H
0A8C  3F00     MOVIW 0[FSR0]
0A8D  00BC     MOVWF 0x1BC
0A8E  3F01     MOVIW 1[FSR0]
0A8F  00BD     MOVWF 0x1BD
0A90  3F02     MOVIW 2[FSR0]
0A91  00BE     MOVWF 0x1BE
0A92  3F03     MOVIW 3[FSR0]
0A93  00BF     MOVWF 0x1BF
410:               cal_const_y.P = cal_const_x.P;
0A94  3050     MOVLW 0x50
0A95  0084     MOVWF FSR0L
0A96  3098     MOVLW 0x98
0A97  0085     MOVWF FSR0H
0A98  3F00     MOVIW 0[FSR0]
0A99  00B4     MOVWF cal_const_y
0A9A  3F01     MOVIW 1[FSR0]
0A9B  00B5     MOVWF 0x1B5
0A9C  3F02     MOVIW 2[FSR0]
0A9D  00B6     MOVWF 0x1B6
0A9E  3F03     MOVIW 3[FSR0]
0A9F  00B7     MOVWF 0x1B7
411:               cal_const_y.F = cal_const_x.F;
0AA0  305C     MOVLW 0x5C
0AA1  0084     MOVWF FSR0L
0AA2  3098     MOVLW 0x98
0AA3  0085     MOVWF FSR0H
0AA4  3F00     MOVIW 0[FSR0]
0AA5  00C0     MOVWF 0x1C0
0AA6  3F01     MOVIW 1[FSR0]
0AA7  00C1     MOVWF 0x1C1
0AA8  3F02     MOVIW 2[FSR0]
0AA9  00C2     MOVWF 0x1C2
0AAA  3F03     MOVIW 3[FSR0]
0AAB  00C3     MOVWF 0x1C3
412:               addres_device = ADDRES_DEVICE_DEF_VAL;
0AAC  0022     MOVLB 0x2
0AAE  01ED     CLRF addres_device
0AAF  0AED     INCF addres_device, F
0AB0  01EE     CLRF 0x16E
413:               speed_device = SPEED_DEVICE_DEF_VAL;
0AAD  3002     MOVLW 0x2
0AB1  00EB     MOVWF speed_device
0AB3  01EC     CLRF 0x16C
414:               index_ind1 = 0;
0AB4  01E7     CLRF index_ind1
0AB5  01E8     CLRF 0x168
415:               index_ind2 = 1;
0AB6  01E5     CLRF index_ind2
0AB7  0AE5     INCF index_ind2, F
0AB8  01E6     CLRF 0x166
416:               tr_type = TR_MIN_VAL;
0AB2  3005     MOVLW 0x5
0AB9  00E3     MOVWF tr_type
0ABB  01E4     CLRF 0x164
417:               phase_correct = PHASE_CORRECT_DEF_VAL;
0ABA  302C     MOVLW 0x2C
0ABC  00E9     MOVWF phase_correct
0ABD  3001     MOVLW 0x1
0ABE  00EA     MOVWF 0x16A
418:               EEPR_WRITE(CAL_CONST_P_ADD, cal_const_y.P);
0ABF  0020     MOVLB 0x0
0AC0  01A2     CLRF multiplicand
0AC1  0822     MOVF multiplicand, W
0AC2  3EB4     ADDLW 0xB4
0AC3  2706     CALL 0x706
0AC4  3188     MOVLP 0x8
0AC5  0822     MOVF multiplicand, W
0AC6  3C38     SUBLW 0x38
0AC7  2357     CALL 0x357
0AC8  3188     MOVLP 0x8
0AC9  0020     MOVLB 0x0
0ACA  3004     MOVLW 0x4
0ACB  0AA2     INCF multiplicand, F
0ACC  0222     SUBWF multiplicand, W
0ACD  1C03     BTFSS STATUS, 0x0
0ACE  2AC1     GOTO 0x2C1
419:               EEPR_WRITE(CAL_CONST_I_ADD, cal_const_y.I);
0ACF  01A3     CLRF size_Tx
0AD0  0823     MOVF size_Tx, W
0AD1  3EBC     ADDLW 0xBC
0AD2  2706     CALL 0x706
0AD3  3188     MOVLP 0x8
0AD4  0823     MOVF size_Tx, W
0AD5  3C34     SUBLW 0x34
0AD6  2357     CALL 0x357
0AD7  3188     MOVLP 0x8
0AD8  0020     MOVLB 0x0
0AD9  3004     MOVLW 0x4
0ADA  0AA3     INCF size_Tx, F
0ADB  0223     SUBWF size_Tx, W
0ADC  1C03     BTFSS STATUS, 0x0
0ADD  2AD0     GOTO 0x2D0
420:               EEPR_WRITE(CAL_CONST_U_ADD, cal_const_y.U);
0ADE  01A4     CLRF size_Buff
0ADF  0824     MOVF size_Buff, W
0AE0  3EB8     ADDLW 0xB8
0AE1  2706     CALL 0x706
0AE2  3188     MOVLP 0x8
0AE3  0824     MOVF size_Buff, W
0AE4  3C30     SUBLW 0x30
0AE5  2357     CALL 0x357
0AE6  3188     MOVLP 0x8
0AE7  0020     MOVLB 0x0
0AE8  3004     MOVLW 0x4
0AE9  0AA4     INCF size_Buff, F
0AEA  0224     SUBWF size_Buff, W
0AEB  1C03     BTFSS STATUS, 0x0
0AEC  2ADF     GOTO 0x2DF
421:               EEPR_WRITE(CAL_CONST_F_ADD, cal_const_y.F);
0AED  01A5     CLRF flag_read
0AEE  0825     MOVF flag_read, W
0AEF  3EC0     ADDLW 0xC0
0AF0  2706     CALL 0x706
0AF1  3188     MOVLP 0x8
0AF2  0825     MOVF flag_read, W
0AF3  3C3C     SUBLW 0x3C
0AF4  2357     CALL 0x357
0AF5  3188     MOVLP 0x8
0AF6  0020     MOVLB 0x0
0AF7  3004     MOVLW 0x4
0AF8  0AA5     INCF flag_read, F
0AF9  0225     SUBWF flag_read, W
0AFA  1C03     BTFSS STATUS, 0x0
0AFB  2AEE     GOTO 0x2EE
422:               EEPR_WRITE(ADDRES_DEVICE_ADD, addres_device);
0AFC  01A6     CLRF index
0AFD  0826     MOVF index, W
0AFE  3E6D     ADDLW 0x6D
0AFF  270C     CALL 0x70C
0B00  3188     MOVLP 0x8
0B01  0826     MOVF index, W
0B02  3C24     SUBLW 0x24
0B03  2357     CALL 0x357
0B04  3188     MOVLP 0x8
0B05  0020     MOVLB 0x0
0B06  3002     MOVLW 0x2
0B07  0AA6     INCF index, F
0B08  0226     SUBWF index, W
0B09  1C03     BTFSS STATUS, 0x0
0B0A  2AFD     GOTO 0x2FD
423:               EEPR_WRITE(SPEED_DEVICE_ADD, speed_device);
0B0B  01A7     CLRF byte
0B0C  0827     MOVF byte, W
0B0D  3E6B     ADDLW 0x6B
0B0E  270C     CALL 0x70C
0B0F  3188     MOVLP 0x8
0B10  0827     MOVF byte, W
0B11  3C22     SUBLW 0x22
0B12  2357     CALL 0x357
0B13  3188     MOVLP 0x8
0B14  0020     MOVLB 0x0
0B15  3002     MOVLW 0x2
0B16  0AA7     INCF byte, F
0B17  0227     SUBWF byte, W
0B18  1C03     BTFSS STATUS, 0x0
0B19  2B0C     GOTO 0x30C
424:               EEPR_WRITE(INDEX_IND1_ADD, index_ind1);
0B1A  01A8     CLRF add
0B1B  0828     MOVF add, W
0B1C  3E67     ADDLW 0x67
0B1D  270C     CALL 0x70C
0B1E  3188     MOVLP 0x8
0B1F  0828     MOVF add, W
0B20  3C26     SUBLW 0x26
0B21  2357     CALL 0x357
0B22  3188     MOVLP 0x8
0B23  0020     MOVLB 0x0
0B24  3002     MOVLW 0x2
0B25  0AA8     INCF add, F
0B26  0228     SUBWF add, W
0B27  1C03     BTFSS STATUS, 0x0
0B28  2B1B     GOTO 0x31B
425:               EEPR_WRITE(INDEX_IND2_ADD, index_ind2);
0B29  01A9     CLRF crcTx
0B2A  0829     MOVF crcTx, W
0B2B  3E65     ADDLW 0x65
0B2C  270C     CALL 0x70C
0B2D  3188     MOVLP 0x8
0B2E  0829     MOVF crcTx, W
0B2F  3C28     SUBLW 0x28
0B30  2357     CALL 0x357
0B31  3188     MOVLP 0x8
0B32  0020     MOVLB 0x0
0B33  3002     MOVLW 0x2
0B34  0AA9     INCF crcTx, F
0B35  0229     SUBWF crcTx, W
0B36  1C03     BTFSS STATUS, 0x0
0B37  2B2A     GOTO 0x32A
426:               EEPR_WRITE(TR_TYPE_ADD, tr_type);
0B38  01AA     CLRF data
0B39  082A     MOVF data, W
0B3A  3E63     ADDLW 0x63
0B3B  270C     CALL 0x70C
0B3C  3188     MOVLP 0x8
0B3D  082A     MOVF data, W
0B3E  3C2A     SUBLW 0x2A
0B3F  2357     CALL 0x357
0B40  3188     MOVLP 0x8
0B41  0020     MOVLB 0x0
0B42  3002     MOVLW 0x2
0B43  0AAA     INCF data, F
0B44  022A     SUBWF data, W
0B45  1C03     BTFSS STATUS, 0x0
0B46  2B39     GOTO 0x339
427:               EEPR_WRITE(PHASE_CORRECT_ADD, phase_correct);
0B47  01AB     CLRF eep_add
0B48  082B     MOVF eep_add, W
0B49  3E69     ADDLW 0x69
0B4A  270C     CALL 0x70C
0B4B  3188     MOVLP 0x8
0B4C  082B     MOVF eep_add, W
0B4D  3C3E     SUBLW 0x3E
0B4E  2357     CALL 0x357
0B4F  3188     MOVLP 0x8
0B50  0020     MOVLB 0x0
0B51  3002     MOVLW 0x2
0B52  0AAB     INCF eep_add, F
0B53  022B     SUBWF eep_add, W
0B54  1803     BTFSC STATUS, 0x0
0B55  0008     RETURN
0B56  2B48     GOTO 0x348
428:           }
429:           
430:           void func_initialization() {
431:               EEPR_READ(CAL_CONST_U_ADD, cal_const_y.U);
09B9  0020     MOVLB 0x0
09BA  01A1     CLRF addr
09BB  0821     MOVF addr, W
09BC  3EB8     ADDLW 0xB8
09BD  0086     MOVWF FSR1
09BE  3001     MOVLW 0x1
09BF  0087     MOVWF FSR1H
09C0  0821     MOVF addr, W
09C1  3C30     SUBLW 0x30
09C2  2265     CALL 0x265
09C3  3188     MOVLP 0x8
09C4  0081     MOVWF INDF1
09C5  0020     MOVLB 0x0
09C6  3004     MOVLW 0x4
09C7  0AA1     INCF addr, F
09C8  0221     SUBWF addr, W
09C9  1C03     BTFSS STATUS, 0x0
09CA  29BB     GOTO 0x1BB
432:               EEPR_READ(CAL_CONST_I_ADD, cal_const_y.I);
09CB  01A2     CLRF multiplicand
09CC  0822     MOVF multiplicand, W
09CD  3EBC     ADDLW 0xBC
09CE  0086     MOVWF FSR1
09CF  3001     MOVLW 0x1
09D0  0087     MOVWF FSR1H
09D1  0822     MOVF multiplicand, W
09D2  3C34     SUBLW 0x34
09D3  2265     CALL 0x265
09D4  3188     MOVLP 0x8
09D5  0081     MOVWF INDF1
09D6  0020     MOVLB 0x0
09D7  3004     MOVLW 0x4
09D8  0AA2     INCF multiplicand, F
09D9  0222     SUBWF multiplicand, W
09DA  1C03     BTFSS STATUS, 0x0
09DB  29CC     GOTO 0x1CC
433:               EEPR_READ(CAL_CONST_P_ADD, cal_const_y.P);
09DC  01A3     CLRF size_Tx
09DD  0823     MOVF size_Tx, W
09DE  3EB4     ADDLW 0xB4
09DF  0086     MOVWF FSR1
09E0  3001     MOVLW 0x1
09E1  0087     MOVWF FSR1H
09E2  0823     MOVF size_Tx, W
09E3  3C38     SUBLW 0x38
09E4  2265     CALL 0x265
09E5  3188     MOVLP 0x8
09E6  0081     MOVWF INDF1
09E7  0020     MOVLB 0x0
09E8  3004     MOVLW 0x4
09E9  0AA3     INCF size_Tx, F
09EA  0223     SUBWF size_Tx, W
09EB  1C03     BTFSS STATUS, 0x0
09EC  29DD     GOTO 0x1DD
434:               EEPR_READ(CAL_CONST_F_ADD, cal_const_y.F);
09ED  01A4     CLRF size_Buff
09EE  0824     MOVF size_Buff, W
09EF  3EC0     ADDLW 0xC0
09F0  0086     MOVWF FSR1
09F1  3001     MOVLW 0x1
09F2  0087     MOVWF FSR1H
09F3  0824     MOVF size_Buff, W
09F4  3C3C     SUBLW 0x3C
09F5  2265     CALL 0x265
09F6  3188     MOVLP 0x8
09F7  0081     MOVWF INDF1
09F8  0020     MOVLB 0x0
09F9  3004     MOVLW 0x4
09FA  0AA4     INCF size_Buff, F
09FB  0224     SUBWF size_Buff, W
09FC  1C03     BTFSS STATUS, 0x0
09FD  29EE     GOTO 0x1EE
435:               EEPR_READ(ADDRES_DEVICE_ADD, addres_device);
09FE  01A5     CLRF flag_read
09FF  0825     MOVF flag_read, W
0A00  3E6D     ADDLW 0x6D
0A01  0086     MOVWF FSR1
0A02  3001     MOVLW 0x1
0A03  0087     MOVWF FSR1H
0A04  0825     MOVF flag_read, W
0A05  3C24     SUBLW 0x24
0A06  2265     CALL 0x265
0A07  3188     MOVLP 0x8
0A08  0081     MOVWF INDF1
0A09  0020     MOVLB 0x0
0A0A  3002     MOVLW 0x2
0A0B  0AA5     INCF flag_read, F
0A0C  0225     SUBWF flag_read, W
0A0D  1C03     BTFSS STATUS, 0x0
0A0E  29FF     GOTO 0x1FF
436:               EEPR_READ(SPEED_DEVICE_ADD, speed_device);
0A0F  01A6     CLRF index
0A10  0826     MOVF index, W
0A11  3E6B     ADDLW 0x6B
0A12  0086     MOVWF FSR1
0A13  3001     MOVLW 0x1
0A14  0087     MOVWF FSR1H
0A15  0826     MOVF index, W
0A16  3C22     SUBLW 0x22
0A17  2265     CALL 0x265
0A18  3188     MOVLP 0x8
0A19  0081     MOVWF INDF1
0A1A  0020     MOVLB 0x0
0A1B  3002     MOVLW 0x2
0A1C  0AA6     INCF index, F
0A1D  0226     SUBWF index, W
0A1E  1C03     BTFSS STATUS, 0x0
0A1F  2A10     GOTO 0x210
437:               EEPR_READ(INDEX_IND1_ADD, index_ind1);
0A20  01A7     CLRF byte
0A21  0827     MOVF byte, W
0A22  3E67     ADDLW 0x67
0A23  0086     MOVWF FSR1
0A24  3001     MOVLW 0x1
0A25  0087     MOVWF FSR1H
0A26  0827     MOVF byte, W
0A27  3C26     SUBLW 0x26
0A28  2265     CALL 0x265
0A29  3188     MOVLP 0x8
0A2A  0081     MOVWF INDF1
0A2B  0020     MOVLB 0x0
0A2C  3002     MOVLW 0x2
0A2D  0AA7     INCF byte, F
0A2E  0227     SUBWF byte, W
0A2F  1C03     BTFSS STATUS, 0x0
0A30  2A21     GOTO 0x221
438:               EEPR_READ(INDEX_IND2_ADD, index_ind2);
0A31  01A8     CLRF add
0A32  0828     MOVF add, W
0A33  3E65     ADDLW 0x65
0A34  0086     MOVWF FSR1
0A35  3001     MOVLW 0x1
0A36  0087     MOVWF FSR1H
0A37  0828     MOVF add, W
0A38  3C28     SUBLW 0x28
0A39  2265     CALL 0x265
0A3A  3188     MOVLP 0x8
0A3B  0081     MOVWF INDF1
0A3C  0020     MOVLB 0x0
0A3D  3002     MOVLW 0x2
0A3E  0AA8     INCF add, F
0A3F  0228     SUBWF add, W
0A40  1C03     BTFSS STATUS, 0x0
0A41  2A32     GOTO 0x232
439:               EEPR_READ(TR_TYPE_ADD, tr_type);
0A42  01A9     CLRF crcTx
0A43  0829     MOVF crcTx, W
0A44  3E63     ADDLW 0x63
0A45  0086     MOVWF FSR1
0A46  3001     MOVLW 0x1
0A47  0087     MOVWF FSR1H
0A48  0829     MOVF crcTx, W
0A49  3C2A     SUBLW 0x2A
0A4A  2265     CALL 0x265
0A4B  3188     MOVLP 0x8
0A4C  0081     MOVWF INDF1
0A4D  0020     MOVLB 0x0
0A4E  3002     MOVLW 0x2
0A4F  0AA9     INCF crcTx, F
0A50  0229     SUBWF crcTx, W
0A51  1C03     BTFSS STATUS, 0x0
0A52  2A43     GOTO 0x243
440:               EEPR_READ(PHASE_CORRECT_ADD, phase_correct);
0A53  01AA     CLRF data
0A54  082A     MOVF data, W
0A55  3E69     ADDLW 0x69
0A56  0086     MOVWF FSR1
0A57  3001     MOVLW 0x1
0A58  0087     MOVWF FSR1H
0A59  082A     MOVF data, W
0A5A  3C3E     SUBLW 0x3E
0A5B  2265     CALL 0x265
0A5C  3188     MOVLP 0x8
0A5D  0081     MOVWF INDF1
0A5E  0020     MOVLB 0x0
0A5F  3002     MOVLW 0x2
0A60  0AAA     INCF data, F
0A61  022A     SUBWF data, W
0A62  1803     BTFSC STATUS, 0x0
0A63  0008     RETURN
0A64  2A54     GOTO 0x254
441:           }
442:           
443:           void init_menu() {
444:               menu_data[0].type_menu = SHOW;
0310  308E     MOVLW 0x8E
0311  0086     MOVWF FSR1
0312  3023     MOVLW 0x23
0313  0087     MOVWF FSR1H
0314  30F0     MOVLW 0xF0
0315  0581     ANDWF INDF1, F
445:               menu_data[0].next = 1;
0316  3099     MOVLW 0x99
0317  0086     MOVWF FSR1
0318  3001     MOVLW 0x1
0319  0081     MOVWF INDF1
446:               menu_data[0].pre = 6;
031A  309A     MOVLW 0x9A
031B  0086     MOVWF FSR1
031C  3006     MOVLW 0x6
031D  0081     MOVWF INDF1
447:           
448:               menu_data[1].type_menu = EN_UP;
031E  308E     MOVLW 0x8E
031F  0086     MOVWF FSR1
0320  314E     ADDFSR 1, 14
0321  0801     MOVF INDF1, W
0322  39F0     ANDLW 0xF0
0323  3801     IORLW 0x1
0324  241E     CALL 0x41E
0325  3180     MOVLP 0x0
449:               menu_data[1].blink_width = 2;
0326  314E     ADDFSR 1, 14
0327  0801     MOVF INDF1, W
0328  390F     ANDLW 0xF
0329  3820     IORLW 0x20
032A  241E     CALL 0x41E
032B  3180     MOVLP 0x0
450:               menu_data[1].Lo_val = 0;
032C  3000     MOVLW 0x0
032D  3153     ADDFSR 1, 19
032E  3FC0     MOVWI 0[FSR1]
032F  2418     CALL 0x418
0330  3180     MOVLP 0x0
451:               menu_data[1].Hi_val = MAX_INDEX_IND;
0331  3004     MOVLW 0x4
0332  3151     ADDFSR 1, 17
0333  3FC0     MOVWI 0[FSR1]
0334  3000     MOVLW 0x0
0335  2418     CALL 0x418
0336  3180     MOVLP 0x0
452:               menu_data[1].Step = 1;
0337  3001     MOVLW 0x1
0338  3155     ADDFSR 1, 21
0339  3FC0     MOVWI 0[FSR1]
033A  3000     MOVLW 0x0
033B  2418     CALL 0x418
033C  3180     MOVLP 0x0
453:               menu_data[1].Add_eep = INDEX_IND1_ADD;
033D  3026     MOVLW 0x26
033E  3157     ADDFSR 1, 23
033F  3FC0     MOVWI 0[FSR1]
0340  3000     MOVLW 0x0
0341  3FC1     MOVWI 1[FSR1]
454:               menu_data[1].next = 2;
0342  30A7     MOVLW 0xA7
0343  0086     MOVWF FSR1
0344  3023     MOVLW 0x23
0345  0087     MOVWF FSR1H
0346  3002     MOVLW 0x2
0347  0081     MOVWF INDF1
455:               menu_data[1].pre = 0;
0348  308E     MOVLW 0x8E
0349  0086     MOVWF FSR1
034A  315A     ADDFSR 1, 26
034B  0181     CLRF INDF1
456:               menu_data[1].add_enter_value = (INT16*)&index_ind1;
034C  0086     MOVWF FSR1
034D  3023     MOVLW 0x23
034E  0087     MOVWF FSR1H
034F  3067     MOVLW 0x67
0350  314F     ADDFSR 1, 15
0351  3FC0     MOVWI 0[FSR1]
0352  3001     MOVLW 0x1
0353  2418     CALL 0x418
0354  3180     MOVLP 0x0
457:           
458:               menu_data[2].type_menu = EN_DOWN;
0355  315C     ADDFSR 1, 28
0356  0801     MOVF INDF1, W
0357  39F0     ANDLW 0xF0
0358  3802     IORLW 0x2
0359  241E     CALL 0x41E
035A  3180     MOVLP 0x0
459:               menu_data[2].blink_width = 2;
035B  315C     ADDFSR 1, 28
035C  0801     MOVF INDF1, W
035D  390F     ANDLW 0xF
035E  3820     IORLW 0x20
035F  0081     MOVWF INDF1
460:               menu_data[2].Lo_val = 0;
0360  30AF     MOVLW 0xAF
0361  242A     CALL 0x42A
0362  3180     MOVLP 0x0
461:               menu_data[2].Hi_val = MAX_INDEX_IND;
0363  308E     MOVLW 0x8E
0364  0086     MOVWF FSR1
0365  3004     MOVLW 0x4
0366  315F     ADDFSR 1, 31
0367  3FC0     MOVWI 0[FSR1]
0368  3000     MOVLW 0x0
0369  3FC1     MOVWI 1[FSR1]
462:               menu_data[2].Step = 1;
036A  30B1     MOVLW 0xB1
036B  22D3     CALL 0x2D3
036C  3180     MOVLP 0x0
463:               menu_data[2].Add_eep = INDEX_IND2_ADD;
036D  30B3     MOVLW 0xB3
036E  0086     MOVWF FSR1
036F  3028     MOVLW 0x28
0370  3FC0     MOVWI 0[FSR1]
0371  3000     MOVLW 0x0
0372  3FC1     MOVWI 1[FSR1]
464:               menu_data[2].next = 3;
0373  30B5     MOVLW 0xB5
0374  0086     MOVWF FSR1
0375  3003     MOVLW 0x3
0376  0081     MOVWF INDF1
465:               menu_data[2].pre = 1;
0377  30B6     MOVLW 0xB6
0378  0086     MOVWF FSR1
0379  3001     MOVLW 0x1
037A  0081     MOVWF INDF1
466:               menu_data[2].add_enter_value = (INT16*)&index_ind2;
037B  308E     MOVLW 0x8E
037C  0086     MOVWF FSR1
037D  3065     MOVLW 0x65
037E  315D     ADDFSR 1, 29
037F  3FC0     MOVWI 0[FSR1]
0380  3001     MOVLW 0x1
0381  3FC1     MOVWI 1[FSR1]
467:           
468:               menu_data[3].type_menu = EN_DOWN;
0382  30B8     MOVLW 0xB8
0383  0086     MOVWF FSR1
0384  3023     MOVLW 0x23
0385  0087     MOVWF FSR1H
0386  2409     CALL 0x409
0387  3180     MOVLP 0x0
469:               menu_data[3].blink_width = sizeof (indicator_t);
470:               menu_data[3].Lo_val = ADDRES_DEVICE_MIN_VAL;
0388  30BD     MOVLW 0xBD
0389  2424     CALL 0x424
038A  3180     MOVLP 0x0
471:               menu_data[3].Hi_val = ADDRES_DEVICE_MAX_VAL;
038B  30BB     MOVLW 0xBB
038C  0086     MOVWF FSR1
038D  30F7     MOVLW 0xF7
038E  3FC0     MOVWI 0[FSR1]
038F  3000     MOVLW 0x0
0390  3FC1     MOVWI 1[FSR1]
472:               menu_data[3].Step = 1;
0391  30BF     MOVLW 0xBF
0392  2424     CALL 0x424
0393  3180     MOVLP 0x0
473:               menu_data[3].Add_eep = ADDRES_DEVICE_ADD;
0394  30C1     MOVLW 0xC1
0395  0086     MOVWF FSR1
0396  3024     MOVLW 0x24
0397  3FC0     MOVWI 0[FSR1]
0398  3000     MOVLW 0x0
0399  3FC1     MOVWI 1[FSR1]
474:               menu_data[3].next = 4;
039A  30C3     MOVLW 0xC3
039B  0086     MOVWF FSR1
039C  3004     MOVLW 0x4
039D  0081     MOVWF INDF1
475:               menu_data[3].pre = 2;
039E  30C4     MOVLW 0xC4
039F  0086     MOVWF FSR1
03A0  3002     MOVLW 0x2
03A1  0081     MOVWF INDF1
476:               menu_data[3].add_enter_value = (INT16*)&addres_device;
03A2  30B9     MOVLW 0xB9
03A3  0086     MOVWF FSR1
03A4  306D     MOVLW 0x6D
03A5  3FC0     MOVWI 0[FSR1]
03A6  3001     MOVLW 0x1
03A7  3FC1     MOVWI 1[FSR1]
477:           
478:               menu_data[4].type_menu = EN_DOWN;
03A8  30C6     MOVLW 0xC6
03A9  0086     MOVWF FSR1
03AA  2409     CALL 0x409
03AB  3180     MOVLP 0x0
479:               menu_data[4].blink_width = sizeof (indicator_t);
480:               menu_data[4].Lo_val = SPEED_DEVICE_MIN_VAL;
03AC  30CB     MOVLW 0xCB
03AD  0086     MOVWF FSR1
03AE  3000     MOVLW 0x0
03AF  3FC0     MOVWI 0[FSR1]
03B0  3FC1     MOVWI 1[FSR1]
481:               menu_data[4].Hi_val = SPEED_DEVICE_MAX_VAL;
03B1  30C9     MOVLW 0xC9
03B2  0086     MOVWF FSR1
03B3  3007     MOVLW 0x7
03B4  3FC0     MOVWI 0[FSR1]
03B5  3000     MOVLW 0x0
03B6  3FC1     MOVWI 1[FSR1]
482:               menu_data[4].Step = 1;
03B7  30CD     MOVLW 0xCD
03B8  2424     CALL 0x424
03B9  3180     MOVLP 0x0
483:               menu_data[4].Add_eep = SPEED_DEVICE_ADD;
03BA  30CF     MOVLW 0xCF
03BB  0086     MOVWF FSR1
03BC  3022     MOVLW 0x22
03BD  3FC0     MOVWI 0[FSR1]
03BE  3000     MOVLW 0x0
03BF  3FC1     MOVWI 1[FSR1]
484:               menu_data[4].next = 5;
03C0  30D1     MOVLW 0xD1
03C1  0086     MOVWF FSR1
03C2  3005     MOVLW 0x5
03C3  0081     MOVWF INDF1
485:               menu_data[4].pre = 3;
03C4  30D2     MOVLW 0xD2
03C5  0086     MOVWF FSR1
03C6  3003     MOVLW 0x3
03C7  0081     MOVWF INDF1
486:               menu_data[4].add_enter_value = (INT16*)&speed_device;
03C8  30C7     MOVLW 0xC7
03C9  0086     MOVWF FSR1
03CA  306B     MOVLW 0x6B
03CB  3FC0     MOVWI 0[FSR1]
03CC  3001     MOVLW 0x1
03CD  3FC1     MOVWI 1[FSR1]
487:           
488:               menu_data[5].type_menu = EN_DOWN;
03CE  30D4     MOVLW 0xD4
03CF  0086     MOVWF FSR1
03D0  2409     CALL 0x409
03D1  3180     MOVLP 0x0
489:               menu_data[5].blink_width = sizeof (indicator_t);
490:               menu_data[5].Lo_val = TR_MIN_VAL;
03D2  30D9     MOVLW 0xD9
03D3  2412     CALL 0x412
03D4  3180     MOVLP 0x0
491:               menu_data[5].Hi_val = TR_MAX_VAL;
03D5  30D7     MOVLW 0xD7
03D6  2437     CALL 0x437
03D7  3180     MOVLP 0x0
492:               menu_data[5].Step = 5;
03D8  30DB     MOVLW 0xDB
03D9  2412     CALL 0x412
03DA  3180     MOVLP 0x0
493:               menu_data[5].Add_eep = TR_TYPE_ADD;
03DB  30DD     MOVLW 0xDD
03DC  2431     CALL 0x431
03DD  3180     MOVLP 0x0
494:               menu_data[5].next = 6;
03DE  30DF     MOVLW 0xDF
03DF  0086     MOVWF FSR1
03E0  3006     MOVLW 0x6
03E1  0081     MOVWF INDF1
495:               menu_data[5].pre = 4;
03E2  30E0     MOVLW 0xE0
03E3  0086     MOVWF FSR1
03E4  3004     MOVLW 0x4
03E5  0081     MOVWF INDF1
496:               menu_data[5].add_enter_value = (INT16*)&tr_type;
03E6  30D5     MOVLW 0xD5
03E7  0086     MOVWF FSR1
03E8  3063     MOVLW 0x63
03E9  3FC0     MOVWI 0[FSR1]
03EA  3001     MOVLW 0x1
03EB  3FC1     MOVWI 1[FSR1]
497:           
498:               menu_data[6].type_menu = EN_DOWN;
03EC  30E2     MOVLW 0xE2
03ED  0086     MOVWF FSR1
03EE  2409     CALL 0x409
03EF  3180     MOVLP 0x0
499:               menu_data[6].blink_width = sizeof (indicator_t);
500:               menu_data[6].Lo_val = TR_MIN_VAL;
03F0  30E7     MOVLW 0xE7
03F1  2412     CALL 0x412
03F2  3180     MOVLP 0x0
501:               menu_data[6].Hi_val = TR_MAX_VAL;
03F3  30E5     MOVLW 0xE5
03F4  2437     CALL 0x437
03F5  3180     MOVLP 0x0
502:               menu_data[6].Step = 5;
03F6  30E9     MOVLW 0xE9
03F7  2412     CALL 0x412
03F8  3180     MOVLP 0x0
503:               menu_data[6].Add_eep = TR_TYPE_ADD;
03F9  30EB     MOVLW 0xEB
03FA  2431     CALL 0x431
504:               menu_data[6].next = 0;
03FB  30ED     MOVLW 0xED
03FC  0086     MOVWF FSR1
03FE  0181     CLRF INDF1
505:               menu_data[6].pre = 5;
03FD  30EE     MOVLW 0xEE
03FF  0086     MOVWF FSR1
0400  3005     MOVLW 0x5
0401  0081     MOVWF INDF1
506:               menu_data[6].add_enter_value = (INT16*)&phase_correct;
0402  30E3     MOVLW 0xE3
0403  0086     MOVWF FSR1
0404  3069     MOVLW 0x69
0405  3FC0     MOVWI 0[FSR1]
0406  3001     MOVLW 0x1
0407  3FC1     MOVWI 1[FSR1]
507:           }
0408  0008     RETURN
508:           
509:           /*void ResetAdress()
510:           {
511:               UINT8 cntPushButton = 0;
512:               while (!BUTTON_PLUS)
513:               {
514:                   CLRWDT();
515:                   if (cntPushButton >= 20)
516:                   {
517:                       eeprom_write(ADDRES_DEVICE_ADD, ADDRES_DEVICE_DEF_VAL);
518:                       eeprom_write(SPEED_DEVICE_ADD, SPEED_DEVICE_DEF_VAL);
519:                       UINT8 cntCycleLED = 6;
520:                       while (cntCycleLED--)
521:                       {
522:           
523:                           //LED_BLUE = !LED_BLUE;
524:                           //LED_RED = !LED_RED;
525:                           __delay_ms(300);
526:                       }
527:                       break;
528:                   }
529:                   __delay_ms(100);
530:                   cntPushButton++;
531:               }
532:           }*/
533:           
534:           interrupt void getData(void) {
0004  147E     BSF 0x7E, 0x0
535:               DEBUG_PIN = 1;
0006  0022     MOVLB 0x2
0007  140E     BSF LATC, 0x0
536:               static bit Switch_Transsmit_Recieve = 0;
537:               if (CCP4IF)
0008  0020     MOVLB 0x0
0009  1E93     BTFSS PIR3, 0x5
000A  2860     GOTO 0x60
538:               {
539:           
540:                   union {
541:           
542:                       struct {
543:                           UINT8 data_symbol;
544:                           UINT16 data_shift;
545:                       };
546:                       UINT8 spi_byte[3];
547:                   } data_out_ind;
548:                   static UINT8 index_1 = 0;
549:                   static UINT8 index_2 = sizeof (Symbol_Latch.mas) - 1;
08B2  300B     MOVLW 0xB
550:                   const UINT16 comb[] = {0xFFFE, 0xFFFD, 0xFFFB, 0xFFF7, 0xFFEF, 0xFFDF, 0xFFBF, 0xFF7F, 0xFEFF, 0xFDFF, 0xFBFF, 0xF7FF, 0xEFFF, 0xDFFF, 0xBFFF, 0x7FFF};
551:           #if defined NIKITA_SAMPLE
552:                   const UINT8 redirect[sizeof (Symbol_Latch)] = {6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 7};
553:           #elif defined GOLUBEV_SAMPLE
554:                   const UINT8 redirect[sizeof (Symbol_Latch)] = {14, 13, 12, 9, 10, 11, 3, 2, 1, 4, 5, 6};
555:           #endif
556:                   if (index_1 == 0)
000B  0869     MOVF index_1, W
000C  1D03     BTFSS STATUS, 0x2
000D  283A     GOTO 0x3A
557:                   {
558:                       RLAT = 1;
000E  0022     MOVLB 0x2
000F  150E     BSF LATC, 0x2
559:                       index_1 = 2;
0010  3002     MOVLW 0x2
0011  0020     MOVLB 0x0
0012  00E9     MOVWF index_1
560:                       if (index_2 == sizeof (Symbol_Latch) - 1)
0013  300B     MOVLW 0xB
0014  067B     XORWF __pdataCOMMON, W
0015  1D03     BTFSS STATUS, 0x2
0016  2819     GOTO 0x19
561:                           index_2 = 0;
0017  01FB     CLRF __pdataCOMMON
0018  281A     GOTO 0x1A
562:                       else
563:                           index_2++;
0019  0AFB     INCF __pdataCOMMON, F
564:                       data_out_ind.data_shift = comb[redirect[index_2]];
001A  087B     MOVF __pdataCOMMON, W
001B  3E60     ADDLW 0x60
001C  0084     MOVWF FSR0
001D  3098     MOVLW 0x98
001E  1803     BTFSC STATUS, 0x0
001F  3E01     ADDLW 0x1
0020  0085     MOVWF FSR0H
0021  0800     MOVF INDF0, W
0022  00F0     MOVWF __pcstackCOMMON
0023  3000     MOVLW 0x0
0024  01F1     CLRF 0x71
0025  35F0     LSLF __pcstackCOMMON, F
0026  0DF1     RLF 0x71, F
0027  0770     ADDWF __pcstackCOMMON, W
0028  0084     MOVWF FSR0
0029  3098     MOVLW 0x98
002A  3D71     ADDWFC 0x71, W
002B  0085     MOVWF FSR0H
002C  3F00     MOVIW 0[FSR0]
002D  00F3     MOVWF 0x73
002E  3F01     MOVIW 1[FSR0]
002F  00F4     MOVWF 0x74
565:                       data_out_ind.data_symbol = Symbol_Latch.mas[index_2].byte;
0030  087B     MOVF __pdataCOMMON, W
0031  3E5C     ADDLW 0x5C
0032  0086     MOVWF FSR1
0033  3002     MOVLW 0x2
0034  0087     MOVWF FSR1H
0035  0801     MOVF INDF1, W
0036  00F2     MOVWF data_out_ind
566:                       RLAT = 0;
0037  0022     MOVLB 0x2
0038  110E     BCF LATC, 0x2
567:                   } else
0039  283B     GOTO 0x3B
568:                       index_1--;
003A  03E9     DECF phase_correct, F
569:                   SSP1CON1bits.WCOL = 0;
003B  0024     MOVLB 0x4
003C  1395     BCF SSP1CON1, 0x7
570:                   SSP1BUF = data_out_ind.spi_byte[index_1];
003D  0020     MOVLB 0x0
003E  0869     MOVF index_1, W
003F  3E72     ADDLW 0x72
0040  0086     MOVWF FSR1
0041  0187     CLRF FSR1H
0042  0801     MOVF INDF1, W
0043  0024     MOVLB 0x4
0044  0091     MOVWF SSP1BUF
571:           
572:                   if (Switch_Transsmit_Recieve && TRMT) //переключение приемопередатчика с передачи на прием
0045  1C7A     BTFSS 0x27A, 0x0
0046  2853     GOTO 0x53
0047  0023     MOVLB 0x3
0048  1C9E     BTFSS TXSTA, 0x1
0049  2853     GOTO 0x53
573:                   {
574:                       TranssmitOrRecieve = Recive;
004A  0022     MOVLB 0x2
004B  118E     BCF LATC, 0x3
575:                       //LED_BLUE = 0;
576:                       CREN = 1; //UART включение приемника
004C  0023     MOVLB 0x3
004D  161D     BSF RCSTA, 0x4
577:                       TMR0 = TimeOutFrame_3_5;
004E  0879     MOVF 0x1F9, W
004F  0020     MOVLB 0x0
0050  0095     MOVWF TMR0
578:                       TMR0IF = 0;
0051  110B     BCF INTCON, 0x2
579:                       Switch_Transsmit_Recieve = 0;
0052  107A     BCF Switch_Transsmit_Recieve, 0x0
580:                   }
581:                   Timer_Interrupt_3++;
0053  0023     MOVLB 0x3
0054  0AE8     INCF Timer_Interrupt_3, F
0055  1903     BTFSC STATUS, 0x2
0056  0AE9     INCF 0x1E9, F
582:                   Timer_Interrupt_2++;
0057  0AEA     INCF Timer_Interrupt_2, F
0058  1903     BTFSC STATUS, 0x2
0059  0AEB     INCF 0x1EB, F
583:                   Timer_Interrupt++;
005A  0AEC     INCF Timer_Interrupt, F
005B  1903     BTFSC STATUS, 0x2
005C  0AED     INCF 0x1ED, F
584:                   CCP4IF = 0;
005D  0020     MOVLB 0x0
005E  1293     BCF PIR3, 0x5
585:               } else if (TXIE && TXIF)
005F  28C2     GOTO 0xC2
0060  0021     MOVLB 0x1
0061  1E11     BTFSS PIE1, 0x4
0062  2886     GOTO 0x86
0063  0020     MOVLB 0x0
0064  1E11     BTFSS PIR1, 0x4
0065  2886     GOTO 0x86
586:               {
587:                   if (Number_Tx_Byte < size_Tx_frame)
0066  0877     MOVF size_Tx_frame, W
0067  0278     SUBWF Number_Tx_Byte, W
0068  1803     BTFSC STATUS, 0x0
0069  28C2     GOTO 0xC2
588:                   {
589:                       TX9D = TX9Dbit[Number_Tx_Byte];
006A  0878     MOVF Number_Tx_Byte, W
006B  3ECA     ADDLW 0xCA
006C  0086     MOVWF FSR1
006D  3002     MOVLW 0x2
006E  0087     MOVWF FSR1H
006F  1C01     BTFSS INDF1, 0x0
0070  2874     GOTO 0x74
0071  0023     MOVLB 0x3
0072  141E     BSF TXSTA, 0x0
0073  2876     GOTO 0x76
0074  0023     MOVLB 0x3
0075  101E     BCF TXSTA, 0x0
590:                       TXREG = Rx_Tx_data[Number_Tx_Byte];
0076  0878     MOVF 0x1F8, W
0077  3E3E     ADDLW 0x3E
0078  0086     MOVWF FSR1L
0079  3002     MOVLW 0x2
007A  0087     MOVWF FSR1H
007B  0801     MOVF INDF1, W
007C  009A     MOVWF TXREG
591:                       Number_Tx_Byte++;
007D  0AF8     INCF 0x1F8, F
592:                       if (Number_Tx_Byte == size_Tx_frame)
007E  0878     MOVF 0x1F8, W
007F  0677     XORWF 0x1F7, W
0080  1D03     BTFSS STATUS, 0x2
0081  28C2     GOTO 0xC2
593:                       {
594:                           TXIE = 0;
0082  0021     MOVLB 0x1
0083  1211     BCF PIE1, 0x4
595:                           Switch_Transsmit_Recieve = 1;
0084  147A     BSF 0xFA, 0x0
0085  28C2     GOTO 0xC2
596:                       }
597:                   }
598:               } else if (RCIE && RCIF)
0086  0021     MOVLB 0x1
0087  1E91     BTFSS PIE1, 0x5
0088  28C2     GOTO 0xC2
0089  0020     MOVLB 0x0
008A  1E91     BTFSS PIR1, 0x5
008B  28C2     GOTO 0xC2
599:               {
600:                   UINT8 receiv_byte = RCREG;
008C  0023     MOVLB 0x3
008D  0819     MOVF RCREG, W
008E  00F5     MOVWF 0x1F5
601:                   if (Number_Rx_Byte)
008F  0876     MOVF 0x1F6, W
0090  1903     BTFSC STATUS, 0x2
0091  28A5     GOTO 0xA5
602:                   {
603:                       if (TMR0 > TimeOutFrame_1_5)
0092  0020     MOVLB 0x0
0093  0815     MOVF TMR0, W
0094  026E     SUBWF TimeOutFrame_1_5, W
0095  1803     BTFSC STATUS, 0x0
0096  2899     GOTO 0x99
604:                           Error_Recive_1_5 = 1;
0097  01ED     CLRF Error_Recive_1_5
0098  0AED     INCF Error_Recive_1_5, F
605:                       if (Number_Rx_Byte < sizeof (Rx_Tx_data))
0099  301E     MOVLW 0x1E
009A  0276     SUBWF Number_Rx_Byte, W
009B  1803     BTFSC STATUS, 0x0
009C  28B6     GOTO 0xB6
606:                       {
607:                           Rx_Tx_data[Number_Rx_Byte] = receiv_byte;
009D  0876     MOVF Number_Rx_Byte, W
009E  3E3E     ADDLW 0x3E
009F  0086     MOVWF FSR1
00A0  3002     MOVLW 0x2
00A1  0087     MOVWF FSR1H
00A2  0875     MOVF receiv_byte, W
00A3  0081     MOVWF INDF1
00A4  28B5     GOTO 0xB5
608:                           Number_Rx_Byte++;
609:                       }
610:                   } else
611:                   {
612:                       if ((TMR0 > TimeOutFrame_3_5 || TMR0IF) && receiv_byte == (UINT8) addres_device)
00A5  0020     MOVLB 0x0
00A6  0815     MOVF TMR0, W
00A7  0279     SUBWF TimeOutFrame_3_5, W
00A8  1C03     BTFSS STATUS, 0x0
00A9  28AC     GOTO 0xAC
00AA  1D0B     BTFSS INTCON, 0x2
00AB  28B6     GOTO 0xB6
00AC  0875     MOVF receiv_byte, W
00AD  0022     MOVLB 0x2
00AE  066D     XORWF addres_device, W
00AF  1D03     BTFSS STATUS, 0x2
00B0  28B6     GOTO 0xB6
613:                       {
614:                           //LED_RED = 1;
615:                           Rx_Tx_data[0] = receiv_byte;
00B1  0875     MOVF 0x175, W
00B2  0024     MOVLB 0x4
00B3  00BE     MOVWF Rx_Tx_data
616:                           Number_Rx_Byte = 1;
00B4  01F6     CLRF 0x276
00B5  0AF6     INCF 0x276, F
617:                       }
618:                   }
619:                   TMR0 = 0;
00B6  0020     MOVLB 0x0
00B7  0195     CLRF TMR0
620:                   TMR0IF = 0;
00B8  110B     BCF INTCON, 0x2
621:                   if (OERR)
00B9  0023     MOVLB 0x3
00BA  1C9D     BTFSS RCSTA, 0x1
00BB  28C2     GOTO 0xC2
622:                   {
623:                       Number_Rx_Byte = 0;
00BC  01F6     CLRF 0x1F6
624:                       Error_Recive_1_5 = 0;
00BD  0020     MOVLB 0x0
00BE  01ED     CLRF Error_Recive_1_5
625:                       CREN = 0;
00BF  0023     MOVLB 0x3
00C0  121D     BCF RCSTA, 0x4
626:                       CREN = 1;
00C1  161D     BSF RCSTA, 0x4
627:                   }
628:               }
629:               DEBUG_PIN = 0;
00C2  0022     MOVLB 0x2
00C3  100E     BCF LATC, 0x0
630:           }
00C4  107E     BCF 0x17E, 0x0
00C5  0009     RETFIE
---  C:/work_Git/VAR_C_NEW/VAR_C_NEW.X/indicator.c  -----------------------------------------------------
1:             /*
2:              * File:   functions_menu.c
3:              * Author: ogorodov.a
4:              *
5:              * Created on 19 января 2021 г., 13:34
6:              */
7:             #define INDICATOR_C_DATA
8:             #include "indicator.h"
9:             
10:            UINT8 index_menu = 0;
11:            indicator_t menu_data_ind1[7];
12:            indicator_t menu_data_ind2[7];
13:            menu_data_t menu_data[7];
14:            Symbol_Latch_t Symbol_Latch;
15:            
16:            comand_butt_t comand_butt = {0};
17:            symbol Numeral[10];
18:            symbol Space_;
19:            symbol C__;
20:            symbol P__;
21:            symbol o__;
22:            symbol F__;
23:            symbol U__;
24:            symbol E__;
25:            symbol t__;
26:            symbol H__;
27:            symbol i__;
28:            symbol n__;
29:            symbol h__;
30:            symbol L__;
31:            symbol b__;
32:            symbol r__;
33:            symbol A__;
34:            symbol c__;
35:            symbol Left_Down__;
36:            symbol Left_UP__;
37:            symbol Right_UP__;
38:            symbol dash__;
39:            symbol d__;
40:            symbol Comma;
41:            UINT16 Timer_Interrupt = 0;
42:            UINT16 Timer_Interrupt_2 = 0;
43:            
44:            UINT16 hundler_Timers(UINT16 *Timer) {
0E58  0020     MOVLB 0x0
0E59  00A5     MOVWF flag_read
45:                di();
0E5A  138B     BCF INTCON, 0x7
46:                UINT16 temp = *Timer;
0E5B  0086     MOVWF FSR1
0E5C  3001     MOVLW 0x1
0E5D  0087     MOVWF FSR1H
0E5E  3F40     MOVIW 0[FSR1]
0E5F  00A3     MOVWF size_Tx
0E60  3F41     MOVIW 1[FSR1]
0E61  00A4     MOVWF size_Buff
47:                *Timer = 0;
0E62  0825     MOVF flag_read, W
0E63  0086     MOVWF FSR1
0E64  3000     MOVLW 0x0
0E65  3FC0     MOVWI 0[FSR1]
0E66  3FC1     MOVWI 1[FSR1]
48:                ei();
0E67  178B     BSF INTCON, 0x7
49:                return temp;
0E68  0824     MOVF size_Buff, W
0E69  00A1     MOVWF addr
0E6A  0823     MOVF size_Tx, W
0E6B  00A0     MOVWF __pcstackBANK0
50:            }
0E6C  0008     RETURN
51:            
52:            void func_init_symbols() {
53:                Numeral[0].led_A = 1;
0F56  144B     BSF sign, 0x0
54:                Numeral[0].led_B = 1;
0F57  14CB     BSF sign, 0x1
55:                Numeral[0].led_C = 1;
0F58  154B     BSF sign, 0x2
56:                Numeral[0].led_D = 1;
0F59  15CB     BSF sign, 0x3
57:                Numeral[0].led_E = 1;
0F5A  164B     BSF sign, 0x4
58:                Numeral[0].led_F = 1;
0F5B  16CB     BSF sign, 0x5
59:                Numeral[0].led_G = 0;
0F5C  134B     BCF sign, 0x6
60:                Numeral[0].led_H = 0;
0F5D  13CB     BCF sign, 0x7
61:            
62:                Numeral[1].led_A = 0;
0F5E  104C     BCF temp_CREN, 0x0
63:                Numeral[1].led_B = 1;
0F5F  14CC     BSF temp_CREN, 0x1
64:                Numeral[1].led_C = 1;
0F60  154C     BSF temp_CREN, 0x2
65:                Numeral[1].led_D = 0;
0F61  11CC     BCF temp_CREN, 0x3
66:                Numeral[1].led_E = 0;
0F62  124C     BCF temp_CREN, 0x4
67:                Numeral[1].led_F = 0;
0F63  12CC     BCF temp_CREN, 0x5
68:                Numeral[1].led_G = 0;
0F64  134C     BCF temp_CREN, 0x6
69:                Numeral[1].led_H = 0;
0F65  13CC     BCF temp_CREN, 0x7
70:            
71:                Numeral[2].led_A = 1;
0F66  144D     BSF flag_read, 0x0
72:                Numeral[2].led_B = 1;
0F67  14CD     BSF flag_read, 0x1
73:                Numeral[2].led_C = 0;
0F68  114D     BCF flag_read, 0x2
74:                Numeral[2].led_D = 1;
0F69  15CD     BSF flag_read, 0x3
75:                Numeral[2].led_E = 1;
0F6A  164D     BSF flag_read, 0x4
76:                Numeral[2].led_F = 0;
0F6B  12CD     BCF flag_read, 0x5
77:                Numeral[2].led_G = 1;
0F6C  174D     BSF flag_read, 0x6
78:                Numeral[2].led_H = 0;
0F6D  13CD     BCF flag_read, 0x7
79:            
80:                Numeral[3].led_A = 1;
0F6E  144E     BSF Number, 0x0
81:                Numeral[3].led_B = 1;
0F6F  14CE     BSF Number, 0x1
82:                Numeral[3].led_C = 1;
0F70  154E     BSF Number, 0x2
83:                Numeral[3].led_D = 1;
0F71  15CE     BSF Number, 0x3
84:                Numeral[3].led_E = 0;
0F72  124E     BCF Number, 0x4
85:                Numeral[3].led_F = 0;
0F73  12CE     BCF Number, 0x5
86:                Numeral[3].led_G = 1;
0F74  174E     BSF Number, 0x6
87:                Numeral[3].led_H = 0;
0F75  13CE     BCF Number, 0x7
88:            
89:                Numeral[4].led_A = 0;
0F76  104F     BCF Speed_devise_bit_sek, 0x0
90:                Numeral[4].led_B = 1;
0F77  14CF     BSF Speed_devise_bit_sek, 0x1
91:                Numeral[4].led_C = 1;
0F78  154F     BSF Speed_devise_bit_sek, 0x2
92:                Numeral[4].led_D = 0;
0F79  11CF     BCF Speed_devise_bit_sek, 0x3
93:                Numeral[4].led_E = 0;
0F7A  124F     BCF Speed_devise_bit_sek, 0x4
94:                Numeral[4].led_F = 1;
0F7B  16CF     BSF Speed_devise_bit_sek, 0x5
95:                Numeral[4].led_G = 1;
0F7C  174F     BSF Speed_devise_bit_sek, 0x6
96:                Numeral[4].led_H = 0;
0F7D  13CF     BCF Speed_devise_bit_sek, 0x7
97:            
98:                Numeral[5].led_A = 1;
0F7E  1450     BSF index, 0x0
99:                Numeral[5].led_B = 0;
0F7F  10D0     BCF index, 0x1
100:               Numeral[5].led_C = 1;
0F80  1550     BSF index, 0x2
101:               Numeral[5].led_D = 1;
0F81  15D0     BSF index, 0x3
102:               Numeral[5].led_E = 0;
0F82  1250     BCF index, 0x4
103:               Numeral[5].led_F = 1;
0F83  16D0     BSF index, 0x5
104:               Numeral[5].led_G = 1;
0F84  1750     BSF index, 0x6
105:               Numeral[5].led_H = 0;
0F85  13D0     BCF index, 0x7
106:           
107:               Numeral[6].led_A = 1;
0F86  1451     BSF crcRx, 0x0
108:               Numeral[6].led_B = 0;
0F87  10D1     BCF crcRx, 0x1
109:               Numeral[6].led_C = 1;
0F88  1551     BSF crcRx, 0x2
110:               Numeral[6].led_D = 1;
0F89  15D1     BSF crcRx, 0x3
111:               Numeral[6].led_E = 1;
0F8A  1651     BSF crcRx, 0x4
112:               Numeral[6].led_F = 1;
0F8B  16D1     BSF crcRx, 0x5
113:               Numeral[6].led_G = 1;
0F8C  1751     BSF crcRx, 0x6
114:               Numeral[6].led_H = 0;
0F8D  13D1     BCF crcRx, 0x7
115:           
116:               Numeral[7].led_A = 1;
0F8E  1452     BSF index, 0x0
117:               Numeral[7].led_B = 1;
0F8F  14D2     BSF index, 0x1
118:               Numeral[7].led_C = 1;
0F90  1552     BSF index, 0x2
119:               Numeral[7].led_D = 0;
0F91  11D2     BCF index, 0x3
120:               Numeral[7].led_E = 0;
0F92  1252     BCF index, 0x4
121:               Numeral[7].led_F = 0;
0F93  12D2     BCF index, 0x5
122:               Numeral[7].led_G = 0;
0F94  1352     BCF index, 0x6
123:               Numeral[7].led_H = 0;
0F95  13D2     BCF index, 0x7
124:           
125:               Numeral[8].led_A = 1;
0F96  1453     BSF temp_Error_Recive_1_5, 0x0
126:               Numeral[8].led_B = 1;
0F97  14D3     BSF temp_Error_Recive_1_5, 0x1
127:               Numeral[8].led_C = 1;
0F98  1553     BSF temp_Error_Recive_1_5, 0x2
128:               Numeral[8].led_D = 1;
0F99  15D3     BSF temp_Error_Recive_1_5, 0x3
129:               Numeral[8].led_E = 1;
0F9A  1653     BSF temp_Error_Recive_1_5, 0x4
130:               Numeral[8].led_F = 1;
0F9B  16D3     BSF temp_Error_Recive_1_5, 0x5
131:               Numeral[8].led_G = 1;
0F9C  1753     BSF temp_Error_Recive_1_5, 0x6
132:               Numeral[8].led_H = 0;
0F9D  13D3     BCF temp_Error_Recive_1_5, 0x7
133:           
134:               Numeral[9].led_A = 1;
0F9E  1454     BSF temp_Number_Rx_Byte, 0x0
135:               Numeral[9].led_B = 1;
0F9F  14D4     BSF temp_Number_Rx_Byte, 0x1
136:               Numeral[9].led_C = 1;
0FA0  1554     BSF temp_Number_Rx_Byte, 0x2
137:               Numeral[9].led_D = 1;
0FA1  15D4     BSF temp_Number_Rx_Byte, 0x3
138:               Numeral[9].led_E = 0;
0FA2  1254     BCF temp_Number_Rx_Byte, 0x4
139:               Numeral[9].led_F = 1;
0FA3  16D4     BSF temp_Number_Rx_Byte, 0x5
140:               Numeral[9].led_G = 1;
0FA4  1754     BSF temp_Number_Rx_Byte, 0x6
141:               Numeral[9].led_H = 0;
0FA5  13D4     BCF temp_Number_Rx_Byte, 0x7
142:           
143:               Space_.byte = 0;
0FA6  01E0     CLRF 0x60
144:           
145:               C__.led_A = 1;
146:               C__.led_B = 0;
147:               C__.led_H = 0;
148:               C__.led_C = 0;
149:               C__.led_D = 1;
150:               C__.led_E = 1;
151:               C__.led_F = 1;
152:               C__.led_G = 0;
153:           
154:               P__.led_A = 1;
0FA7  145E     BSF 0x5E, 0x0
155:               P__.led_B = 1;
0FA8  14DE     BSF 0x5E, 0x1
156:               P__.led_C = 0;
0FA9  115E     BCF 0x5E, 0x2
157:               P__.led_D = 0;
0FAA  11DE     BCF 0x5E, 0x3
158:               P__.led_E = 1;
0FAB  165E     BSF 0x5E, 0x4
159:               P__.led_F = 1;
0FAC  16DE     BSF 0x5E, 0x5
160:               P__.led_G = 1;
0FAD  175E     BSF 0x5E, 0x6
161:               P__.led_H = 0;
0FAE  13DE     BCF 0x5E, 0x7
162:           
163:           
164:               o__.led_A = 0;
165:               o__.led_B = 0;
166:               o__.led_C = 1;
167:               o__.led_D = 1;
168:               o__.led_E = 1;
169:               o__.led_F = 0;
170:               o__.led_G = 1;
171:               o__.led_H = 0;
172:           
173:           
174:               F__.led_A = 1;
0FAF  145C     BSF 0x5C, 0x0
175:               F__.led_B = 0;
0FB0  10DC     BCF 0x5C, 0x1
176:               F__.led_C = 0;
0FB1  115C     BCF 0x5C, 0x2
177:               F__.led_D = 0;
0FB2  11DC     BCF 0x5C, 0x3
178:               F__.led_E = 1;
0FB3  165C     BSF 0x5C, 0x4
179:               F__.led_F = 1;
0FB4  16DC     BSF 0x5C, 0x5
180:               F__.led_G = 1;
0FB5  175C     BSF 0x5C, 0x6
181:               F__.led_H = 0;
0FB6  13DC     BCF 0x5C, 0x7
182:           
183:               U__.led_A = 0;
0FB7  1061     BCF 0x61, 0x0
184:               U__.led_B = 1;
0FB8  14E1     BSF 0x61, 0x1
185:               U__.led_C = 1;
0FB9  1561     BSF 0x61, 0x2
186:               U__.led_D = 1;
0FBA  15E1     BSF 0x61, 0x3
187:               U__.led_E = 1;
0FBB  1661     BSF 0x61, 0x4
188:               U__.led_F = 1;
0FBC  16E1     BSF 0x61, 0x5
189:               U__.led_G = 0;
0FBD  1361     BCF 0x61, 0x6
190:               U__.led_H = 0;
0FBE  13E1     BCF 0x61, 0x7
191:           
192:               E__.led_A = 1;
193:               E__.led_B = 0;
194:               E__.led_C = 0;
195:               E__.led_D = 1;
196:               E__.led_E = 1;
197:               E__.led_F = 1;
198:               E__.led_G = 1;
199:               E__.led_H = 0;
200:           
201:               t__.led_A = 0;
0FBF  1059     BCF 0x59, 0x0
202:               t__.led_B = 0;
0FC0  10D9     BCF 0x59, 0x1
203:               t__.led_C = 0;
0FC1  1159     BCF 0x59, 0x2
204:               t__.led_D = 1;
0FC2  15D9     BSF 0x59, 0x3
205:               t__.led_E = 1;
0FC3  1659     BSF 0x59, 0x4
206:               t__.led_F = 1;
0FC4  16D9     BSF 0x59, 0x5
207:               t__.led_G = 1;
0FC5  1759     BSF 0x59, 0x6
208:               t__.led_H = 0;
0FC6  13D9     BCF 0x59, 0x7
209:           
210:               H__.led_A = 0;
0FC7  1058     BCF 0x58, 0x0
211:               H__.led_B = 1;
0FC8  14D8     BSF 0x58, 0x1
212:               H__.led_C = 1;
0FC9  1558     BSF 0x58, 0x2
213:               H__.led_D = 0;
0FCA  11D8     BCF 0x58, 0x3
214:               H__.led_E = 1;
0FCB  1658     BSF 0x58, 0x4
215:               H__.led_F = 1;
0FCC  16D8     BSF 0x58, 0x5
216:               H__.led_G = 1;
0FCD  1758     BSF 0x58, 0x6
217:               H__.led_H = 0;
0FCE  13D8     BCF 0x58, 0x7
218:           
219:               i__.led_A = 0;
220:               i__.led_B = 0;
221:               i__.led_C = 0;
222:               i__.led_D = 0;
223:               i__.led_E = 1;
224:               i__.led_F = 0;
225:               i__.led_G = 0;
226:               i__.led_H = 0;
227:           
228:               n__.led_A = 0;
229:               n__.led_B = 0;
230:               n__.led_C = 1;
231:               n__.led_D = 0;
232:               n__.led_E = 1;
233:               n__.led_F = 0;
234:               n__.led_G = 1;
235:               n__.led_H = 0;
236:           
237:               h__.led_A = 0;
238:               h__.led_B = 0;
239:               h__.led_C = 1;
240:               h__.led_D = 0;
241:               h__.led_E = 1;
242:               h__.led_F = 1;
243:               h__.led_G = 1;
244:               h__.led_H = 0;
245:           
246:               L__.led_A = 0;
247:               L__.led_B = 0;
248:               L__.led_C = 0;
249:               L__.led_D = 1;
250:               L__.led_E = 1;
251:               L__.led_F = 1;
252:               L__.led_G = 0;
253:               L__.led_H = 0;
254:           
255:               b__.led_A = 0;
0FCF  105A     BCF 0x5A, 0x0
256:               b__.led_B = 0;
0FD0  10DA     BCF 0x5A, 0x1
257:               b__.led_C = 1;
0FD1  155A     BSF 0x5A, 0x2
258:               b__.led_D = 1;
0FD2  15DA     BSF 0x5A, 0x3
259:               b__.led_E = 1;
0FD3  165A     BSF 0x5A, 0x4
260:               b__.led_F = 1;
0FD4  16DA     BSF 0x5A, 0x5
261:               b__.led_G = 1;
0FD5  175A     BSF 0x5A, 0x6
262:               b__.led_H = 0;
0FD6  13DA     BCF 0x5A, 0x7
263:           
264:               r__.led_A = 0;
0FD7  105D     BCF 0x5D, 0x0
265:               r__.led_B = 0;
0FD8  10DD     BCF 0x5D, 0x1
266:               r__.led_C = 0;
0FD9  115D     BCF 0x5D, 0x2
267:               r__.led_D = 0;
0FDA  11DD     BCF 0x5D, 0x3
268:               r__.led_E = 1;
0FDB  165D     BSF 0x5D, 0x4
269:               r__.led_F = 0;
0FDC  12DD     BCF 0x5D, 0x5
270:               r__.led_G = 1;
0FDD  175D     BSF 0x5D, 0x6
271:               r__.led_H = 0;
0FDE  13DD     BCF 0x5D, 0x7
272:           
273:               A__.led_A = 1;
0FDF  145F     BSF 0x5F, 0x0
274:               A__.led_B = 1;
0FE0  14DF     BSF 0x5F, 0x1
275:               A__.led_C = 1;
0FE1  155F     BSF 0x5F, 0x2
276:               A__.led_D = 0;
0FE2  11DF     BCF 0x5F, 0x3
277:               A__.led_E = 1;
0FE3  165F     BSF 0x5F, 0x4
278:               A__.led_F = 1;
0FE4  16DF     BSF 0x5F, 0x5
279:               A__.led_G = 1;
0FE5  175F     BSF 0x5F, 0x6
280:               A__.led_H = 0;
0FE6  13DF     BCF 0x5F, 0x7
281:           
282:               c__.led_A = 0;
283:               c__.led_B = 0;
284:               c__.led_C = 0;
285:               c__.led_D = 1;
286:               c__.led_E = 1;
287:               c__.led_F = 0;
288:               c__.led_G = 1;
289:               c__.led_H = 0;
290:           
291:               Left_Down__.led_A = 0;
292:               Left_Down__.led_B = 0;
293:               Left_Down__.led_C = 1;
294:               Left_Down__.led_D = 0;
295:               Left_Down__.led_E = 0;
296:               Left_Down__.led_F = 0;
297:               Left_Down__.led_G = 1;
298:               Left_Down__.led_H = 0;
299:           
300:               Left_UP__.led_A = 0;
301:               Left_UP__.led_B = 1;
302:               Left_UP__.led_C = 0;
303:               Left_UP__.led_D = 0;
304:               Left_UP__.led_E = 0;
305:               Left_UP__.led_F = 0;
306:               Left_UP__.led_G = 1;
307:               Left_UP__.led_H = 0;
308:           
309:               Right_UP__.led_A = 0;
310:               Right_UP__.led_B = 0;
311:               Right_UP__.led_C = 0;
312:               Right_UP__.led_D = 0;
313:               Right_UP__.led_E = 0;
314:               Right_UP__.led_F = 1;
315:               Right_UP__.led_G = 1;
316:               Right_UP__.led_H = 0;
317:           
318:               dash__.led_A = 0;
0FE7  1056     BCF 0x56, 0x0
319:               dash__.led_B = 0;
0FE8  10D6     BCF 0x56, 0x1
320:               dash__.led_C = 0;
0FE9  1156     BCF 0x56, 0x2
321:               dash__.led_D = 0;
0FEA  11D6     BCF 0x56, 0x3
322:               dash__.led_E = 0;
0FEB  1256     BCF 0x56, 0x4
323:               dash__.led_F = 0;
0FEC  12D6     BCF 0x56, 0x5
324:               dash__.led_G = 1;
0FED  1756     BSF 0x56, 0x6
325:               dash__.led_H = 0;
0FEE  13D6     BCF 0x56, 0x7
326:           
327:               d__.led_A = 0;
0FEF  105B     BCF 0x5B, 0x0
328:               d__.led_B = 1;
0FF0  14DB     BSF 0x5B, 0x1
329:               d__.led_C = 1;
0FF1  155B     BSF 0x5B, 0x2
330:               d__.led_D = 1;
0FF2  15DB     BSF 0x5B, 0x3
331:               d__.led_E = 1;
0FF3  165B     BSF 0x5B, 0x4
332:               d__.led_F = 0;
0FF4  12DB     BCF 0x5B, 0x5
333:               d__.led_G = 1;
0FF5  175B     BSF 0x5B, 0x6
334:               d__.led_H = 0;
0FF6  13DB     BCF 0x5B, 0x7
335:           
336:               Comma.led_A = 0;
0FF7  1055     BCF 0x55, 0x0
337:               Comma.led_B = 0;
0FF8  10D5     BCF 0x55, 0x1
338:               Comma.led_C = 0;
0FF9  1155     BCF 0x55, 0x2
339:               Comma.led_D = 0;
0FFA  11D5     BCF 0x55, 0x3
340:               Comma.led_E = 0;
0FFB  1255     BCF 0x55, 0x4
341:               Comma.led_F = 0;
0FFC  12D5     BCF 0x55, 0x5
342:               Comma.led_G = 0;
0FFD  1355     BCF 0x55, 0x6
343:               Comma.led_H = 1;
0FFE  17D5     BSF 0x55, 0x7
344:           }
0FFF  0008     RETURN
345:           
346:           indicator_t func_Calcul_Numeral_Ind(INT32 S_Number, UINT8 pos_point) {
347:               UINT8 sign;
348:               UINT32 Number;
349:               indicator_t indicator;
350:               for (INT8 index = 0; index < sizeof (indicator); index++)
1533  01CC     CLRF temp_CREN
153B  0020     MOVLB 0x0
153C  3006     MOVLW 0x6
153D  0ACC     INCF temp_CREN, F
153E  024C     SUBWF temp_CREN, W
153F  1C03     BTFSS STATUS, 0x0
1540  2D34     GOTO 0x534
351:                   indicator.mas[index] = Space_;
1534  084C     MOVF temp_CREN, W
1535  3E54     ADDLW 0x54
1536  0086     MOVWF FSR1
1537  0187     CLRF FSR1H
1538  0022     MOVLB 0x2
1539  0860     MOVF Space_, W
153A  0081     MOVWF INDF1
352:           #define SHIFT_IND 2 //сдвиг, определяющий рабочую длину индикатора. В нерабочей будет название 
353:               const UINT8 size_ind = sizeof (indicator) - SHIFT_IND;
1588  3040     MOVLW 0x40
1589  00C8     MOVWF 0x148
158A  3098     MOVLW 0x98
158B  2D8F     GOTO 0x58F
158C  3044     MOVLW 0x44
158D  00C8     MOVWF 0x148
158E  3098     MOVLW 0x98
158F  00C9     MOVWF 0x149
15C9  3003     MOVLW 0x3
15CA  00D2     MOVWF 0x152
15F9  3003     MOVLW 0x3
15FA  00D3     MOVWF 0x153
354:               if (S_Number == 0)
1541  083D     MOVF temp, W
1542  043C     IORWF multy, W
1543  043B     IORWF 0x13B, W
1544  043A     IORWF 0x13A, W
1545  1D03     BTFSS STATUS, 0x2
1546  2D5B     GOTO 0x55B
355:               {
356:                   indicator.S1 = Numeral[0];
1547  0022     MOVLB 0x2
1548  084B     MOVF Numeral, W
1549  0020     MOVLB 0x0
154A  00D4     MOVWF temp_Number_Rx_Byte
357:                   return indicator;
154B  3054     MOVLW 0x54
154C  0086     MOVWF FSR1
154D  3000     MOVLW 0x0
154E  0087     MOVWF FSR1H
154F  303A     MOVLW 0x3A
1550  0084     MOVWF FSR0
1551  3000     MOVLW 0x0
1552  0085     MOVWF FSR0H
1553  3006     MOVLW 0x6
1554  0020     MOVLB 0x0
1555  00C0     MOVWF index
1556  0016     MOVIW FSR1++
1557  001A     MOVWI FSR0++
1558  0BC0     DECFSZ index, F
1559  2D56     GOTO 0x556
155A  0008     RETURN
358:               } else if (S_Number > 0)
155B  1BBD     BTFSC adressReg_wr, 0x7
155C  2D75     GOTO 0x575
155D  083D     MOVF adressReg_wr, W
155E  1D03     BTFSS STATUS, 0x2
155F  2D6A     GOTO 0x56A
1560  083C     MOVF i, W
1561  1D03     BTFSS STATUS, 0x2
1562  2D6A     GOTO 0x56A
1563  083B     MOVF flag_read, W
1564  1D03     BTFSS STATUS, 0x2
1565  2D6A     GOTO 0x56A
1566  3001     MOVLW 0x1
1567  023A     SUBWF S_Number, W
1568  1C03     BTFSS STATUS, 0x0
1569  2D75     GOTO 0x575
359:               {
360:                   Number = S_Number;
156A  083D     MOVF adressReg_wr, W
156B  00D1     MOVWF crcRx
156C  083C     MOVF i, W
156D  00D0     MOVWF index
156E  083B     MOVF flag_read, W
156F  00CF     MOVWF Speed_devise_bit_sek
1570  083A     MOVF S_Number, W
1571  00CE     MOVWF Number
361:                   sign = 1;
1572  01CB     CLRF sign
1573  0ACB     INCF sign, F
362:               } else
1574  2D85     GOTO 0x585
363:               {
364:                   Number = -S_Number;
1575  093A     COMF S_Number, W
1576  00CE     MOVWF Number
1577  093B     COMF flag_read, W
1578  00CF     MOVWF Speed_devise_bit_sek
1579  093C     COMF i, W
157A  00D0     MOVWF index
157B  093D     COMF adressReg_wr, W
157C  00D1     MOVWF crcRx
157D  0ACE     INCF Number, F
157E  1903     BTFSC STATUS, 0x2
157F  0ACF     INCF Speed_devise_bit_sek, F
1580  1903     BTFSC STATUS, 0x2
1581  0AD0     INCF index, F
1582  1903     BTFSC STATUS, 0x2
1583  0AD1     INCF crcRx, F
365:                   sign = 0;
1584  01CB     CLRF sign
366:               }
367:               const UINT32 limit_ind[] = {9, 99, 999, 9999, 99999, 999999};
368:               UINT32 temp_limit_ind = (sign) ? limit_ind[size_ind - 1] : limit_ind[size_ind - 2];
1585  084B     MOVF sign, W
1586  1D03     BTFSS STATUS, 0x2
1587  2D8C     GOTO 0x58C
1590  0848     MOVF Timer_1, W
1591  0084     MOVWF FSR0
1592  0849     MOVF 0x49, W
1593  0085     MOVWF FSR0H
1594  3F00     MOVIW 0[FSR0]
1595  00C4     MOVWF temp_limit_ind
1596  3F01     MOVIW 1[FSR0]
1597  00C5     MOVWF 0x45
1598  3F02     MOVIW 2[FSR0]
1599  00C6     MOVWF 0x46
159A  3F03     MOVIW 3[FSR0]
159B  00C7     MOVWF 0x47
369:               if (!sign && (pos_point == (size_ind - 1)))
159C  084B     MOVF sign, W
159D  1D03     BTFSS STATUS, 0x2
159E  2DB9     GOTO 0x5B9
159F  3003     MOVLW 0x3
15A0  063E     XORWF shift_pos, W
15A1  1903     BTFSC STATUS, 0x2
15A2  2DA7     GOTO 0x5A7
15A3  2DB9     GOTO 0x5B9
370:               {
371:                   Number /= 10;
15A7  300A     MOVLW 0xA
15A8  00A0     MOVWF __pcstackBANK0
15A9  01A1     CLRF addr
15AA  01A2     CLRF multiplicand
15AB  01A3     CLRF size_Tx
15AC  27A4     CALL 0x7A4
15AD  3190     MOVLP 0x10
15AE  2669     CALL 0x669
15AF  3190     MOVLP 0x10
15B0  0823     MOVF size_Tx, W
15B1  00D1     MOVWF crcRx
15B2  0822     MOVF multiplicand, W
15B3  00D0     MOVWF index
15B4  0821     MOVF addr, W
15B5  00CF     MOVWF Speed_devise_bit_sek
15B6  0820     MOVF __pcstackBANK0, W
15B7  00CE     MOVWF Number
372:                   pos_point--;
15B8  03BE     DECF shift_pos, F
373:               }
374:               while (Number > temp_limit_ind && pos_point)
15A4  083E     MOVF shift_pos, W
15A5  1903     BTFSC STATUS, 0x2
15A6  2DC9     GOTO 0x5C9
15B9  0851     MOVF crcRx, W
15BA  0247     SUBWF 0x47, W
15BB  1D03     BTFSS STATUS, 0x2
15BC  2DC7     GOTO 0x5C7
15BD  0850     MOVF index, W
15BE  0246     SUBWF 0x46, W
15BF  1D03     BTFSS STATUS, 0x2
15C0  2DC7     GOTO 0x5C7
15C1  084F     MOVF Speed_devise_bit_sek, W
15C2  0245     SUBWF 0x45, W
15C3  1D03     BTFSS STATUS, 0x2
15C4  2DC7     GOTO 0x5C7
15C5  084E     MOVF Number, W
15C6  0244     SUBWF temp_limit_ind, W
15C7  1C03     BTFSS STATUS, 0x0
15C8  2DA4     GOTO 0x5A4
375:               {
376:                   Number /= 10;
377:                   pos_point--;
378:               }
379:               const UINT32 div[] = {1, 10, 100, 1000, 10000, 100000};
380:               for (INT8 index = size_ind - 1; index >= 0; index--)
15F6  03D2     DECF index, F
15F7  1FD2     BTFSS index, 0x7
15F8  2DCB     GOTO 0x5CB
381:               {
382:                   UINT8 temp = Number / div[index];
15CB  277F     CALL 0x77F
15CC  3190     MOVLP 0x10
15CD  0085     MOVWF FSR0H
15CE  3F00     MOVIW 0[FSR0]
15CF  00A0     MOVWF __pcstackBANK0
15D0  3F01     MOVIW 1[FSR0]
15D1  00A1     MOVWF addr
15D2  3F02     MOVIW 2[FSR0]
15D3  00A2     MOVWF multiplicand
15D4  3F03     MOVIW 3[FSR0]
15D5  00A3     MOVWF size_Tx
15D6  27A4     CALL 0x7A4
15D7  3190     MOVLP 0x10
15D8  2669     CALL 0x669
15D9  3190     MOVLP 0x10
15DA  0820     MOVF __pcstackBANK0, W
15DB  00CA     MOVWF temp_SPBRG
383:                   indicator.mas[index] = Numeral[temp];
15DC  0852     MOVF index, W
15DD  3E54     ADDLW 0x54
15DE  0086     MOVWF FSR1
15DF  0187     CLRF FSR1H
15E0  084A     MOVF temp_SPBRG, W
15E1  27C2     CALL 0x7C2
15E2  3190     MOVLP 0x10
384:                   Number -= temp * div[index];
15E3  084A     MOVF temp_SPBRG, W
15E4  00A0     MOVWF __pcstackBANK0
15E5  01A1     CLRF addr
15E6  01A2     CLRF multiplicand
15E7  01A3     CLRF size_Tx
15E8  277F     CALL 0x77F
15E9  3190     MOVLP 0x10
15EA  2730     CALL 0x730
15EB  3190     MOVLP 0x10
15EC  2644     CALL 0x644
15ED  3190     MOVLP 0x10
15EE  0820     MOVF __pcstackBANK0, W
15EF  02CE     SUBWF Number, F
15F0  0821     MOVF addr, W
15F1  3BCF     SUBWFB Speed_devise_bit_sek, F
15F2  0822     MOVF multiplicand, W
15F3  3BD0     SUBWFB index, F
15F4  0823     MOVF size_Tx, W
15F5  3BD1     SUBWFB crcRx, F
385:               }
386:               for (INT8 index = size_ind - 1; index >= 0; index--)
1609  0020     MOVLB 0x0
160A  03D3     DECF temp_Error_Recive_1_5, F
160B  1BD3     BTFSC temp_Error_Recive_1_5, 0x7
160C  2E1D     GOTO 0x61D
387:               {
388:                   if (pos_point != index)
15FB  2E0D     GOTO 0x60D
160D  0853     MOVF temp_Error_Recive_1_5, W
160E  00C0     MOVWF index
160F  01C1     CLRF index
1610  1BC0     BTFSC index, 0x7
1611  03C1     DECF index, F
1612  083E     MOVF shift_pos, W
1613  00C2     MOVWF lock
1614  01C3     CLRF 0x43
1615  0841     MOVF index, W
1616  0643     XORWF 0x43, W
1617  1D03     BTFSS STATUS, 0x2
1618  2E1B     GOTO 0x61B
1619  0840     MOVF index, W
161A  0642     XORWF lock, W
161B  1D03     BTFSS STATUS, 0x2
161C  2DFC     GOTO 0x5FC
389:                   {
390:                       if (indicator.mas[index].byte == Numeral[0].byte)
15FC  0853     MOVF temp_Error_Recive_1_5, W
15FD  27D9     CALL 0x7D9
15FE  3190     MOVLP 0x10
15FF  064B     XORWF sign, W
1600  1D03     BTFSS STATUS, 0x2
1601  2E1D     GOTO 0x61D
391:                           indicator.mas[index] = Space_;
1602  0020     MOVLB 0x0
1603  0853     MOVF temp_Error_Recive_1_5, W
1604  3E54     ADDLW 0x54
1605  0086     MOVWF FSR1
1606  0022     MOVLB 0x2
1607  0860     MOVF Space_, W
1608  0081     MOVWF INDF1
392:                       else
393:                           break;
394:                   } else
395:                       break;
396:               }
397:               if (!sign)
161D  0020     MOVLB 0x0
161E  084B     MOVF sign, W
161F  1D03     BTFSS STATUS, 0x2
1620  2E38     GOTO 0x638
398:                   for (INT8 index = 1; index < size_ind; index++)
1621  01CD     CLRF flag_read
1622  0ACD     INCF flag_read, F
1631  0020     MOVLB 0x0
1632  0ACD     INCF flag_read, F
1633  084D     MOVF flag_read, W
1634  3A80     XORLW 0x80
1635  3E7C     ADDLW 0x7C
1636  1C03     BTFSS STATUS, 0x0
1637  2E23     GOTO 0x623
399:                       if (indicator.mas[index].byte == Space_.byte)
1623  084D     MOVF flag_read, W
1624  27D9     CALL 0x7D9
1625  3190     MOVLP 0x10
1626  0660     XORWF 0x60, W
1627  1D03     BTFSS STATUS, 0x2
1628  2E31     GOTO 0x631
400:                       {
401:                           indicator.mas[index] = dash__;
1629  0020     MOVLB 0x0
162A  084D     MOVF flag_read, W
162B  3E54     ADDLW 0x54
162C  0086     MOVWF FSR1
162D  0022     MOVLB 0x2
162E  0856     MOVF dash__, W
162F  0081     MOVWF INDF1
402:                           break;
1630  2E38     GOTO 0x638
403:                       }
404:               if (pos_point)
1638  0020     MOVLB 0x0
1639  083E     MOVF shift_pos, W
163A  1903     BTFSC STATUS, 0x2
163B  2D4B     GOTO 0x54B
405:                   indicator.mas[pos_point].byte |= Comma.byte;
163C  083E     MOVF shift_pos, W
163D  3E54     ADDLW 0x54
163E  0086     MOVWF FSR1
163F  0187     CLRF FSR1H
1640  0022     MOVLB 0x2
1641  0855     MOVF Comma, W
1642  0481     IORWF INDF1, F
1643  2D4B     GOTO 0x54B
406:               return indicator;
407:           }
408:           
409:           void indicator_func() {
410:           
411:               static comand_butt_t button_state;
412:           
413:               static struct {
414:                   UINT16 PLUS;
415:                   UINT16 MINUS;
416:                   UINT16 ENTER;
417:                   UINT16 ESC;
418:               } button_count;
419:               const UINT16 time_filt_button = 30000 / PERIOD_INTERRUPT_MKS;
420:               UINT16 Timer_1 = hundler_Timers(&Timer_Interrupt);
043D  30EC     MOVLW 0xEC
043E  318E     MOVLP 0xE
043F  2658     CALL 0x658
0440  3184     MOVLP 0x4
0441  0821     MOVF 0x121, W
0442  00C9     MOVWF 0x149
0443  0820     MOVF __pcstackBANK2, W
0444  00C8     MOVWF 0x148
421:               UINT8 temp_state = !(BUTTON_PLUS ^ ACTIVE_LEVEL_BUTTON);
0445  1003     BCF STATUS, 0x0
0446  1C8C     BTFSS LATA, 0x1
0447  1403     BSF STATUS, 0x0
0448  3000     MOVLW 0x0
0449  1803     BTFSC STATUS, 0x0
044A  3001     MOVLW 0x1
044B  00CA     MOVWF 0x14A
422:               if (temp_state != button_state.PLUS)
044C  0866     MOVF 0x166, W
044D  3901     ANDLW 0x1
044E  064A     XORWF 0x14A, W
044F  1903     BTFSC STATUS, 0x2
0450  2C6D     GOTO 0x46D
423:               {
424:                   button_count.PLUS += Timer_1;
0451  0848     MOVF 0x148, W
0452  0023     MOVLB 0x3
0453  07C4     ADDWF button_count, F
0454  0020     MOVLB 0x0
0455  0849     MOVF 0x49, W
0456  0023     MOVLB 0x3
0457  3DC5     ADDWFC 0x1C5, F
425:                   if (button_count.PLUS >= time_filt_button)
0458  3000     MOVLW 0x0
0459  0245     SUBWF 0x1C5, W
045A  30BB     MOVLW 0xBB
045B  1903     BTFSC STATUS, 0x2
045C  0244     SUBWF button_count, W
045D  1C03     BTFSS STATUS, 0x0
045E  2C71     GOTO 0x471
426:                   {
427:                       comand_butt.PLUS = !temp_state;
045F  0020     MOVLB 0x0
0460  084A     MOVF temp_SPBRG, W
0461  1D03     BTFSS STATUS, 0x2
0462  2C66     GOTO 0x466
0463  0020     MOVLB 0x0
0464  1467     BSF comand_butt, 0x0
0465  2C68     GOTO 0x468
0466  0020     MOVLB 0x0
0467  1067     BCF comand_butt, 0x0
428:                       button_state.PLUS = temp_state;
0468  084A     MOVF temp_SPBRG, W
0469  3901     ANDLW 0x1
046A  1066     BCF __pbssBANK0, 0x0
046B  1D03     BTFSS STATUS, 0x2
046C  1466     BSF __pbssBANK0, 0x0
429:                       button_count.PLUS = 0;
046D  0023     MOVLB 0x3
046E  01C4     CLRF button_count
046F  01C5     CLRF 0x1C5
430:                   }
431:               } else
432:                   button_count.PLUS = 0;
433:           
434:               UINT8 temp_state = !(BUTTON_MINUS ^ ACTIVE_LEVEL_BUTTON);
0470  1003     BCF STATUS, 0x0
0471  0020     MOVLB 0x0
0472  1F0E     BTFSS PORTC, 0x6
0473  1403     BSF STATUS, 0x0
0474  25F9     CALL 0x5F9
0475  3184     MOVLP 0x4
435:               if (temp_state != button_state.MINUS)
0476  3901     ANDLW 0x1
0477  064A     XORWF temp_SPBRG, W
0478  1903     BTFSC STATUS, 0x2
0479  2C96     GOTO 0x496
436:               {
437:                   button_count.MINUS += Timer_1;
047A  0848     MOVF Timer_1, W
047B  0023     MOVLB 0x3
047C  07C6     ADDWF 0x1C6, F
047D  0020     MOVLB 0x0
047E  0849     MOVF 0x49, W
047F  0023     MOVLB 0x3
0480  3DC7     ADDWFC 0x1C7, F
438:                   if (button_count.MINUS >= time_filt_button)
0481  3000     MOVLW 0x0
0482  0247     SUBWF 0x1C7, W
0483  30BB     MOVLW 0xBB
0484  1903     BTFSC STATUS, 0x2
0485  0246     SUBWF 0x1C6, W
0486  1C03     BTFSS STATUS, 0x0
0487  2C9A     GOTO 0x49A
439:                   {
440:                       comand_butt.MINUS = !temp_state;
0488  0020     MOVLB 0x0
0489  084A     MOVF temp_SPBRG, W
048A  1D03     BTFSS STATUS, 0x2
048B  2C8F     GOTO 0x48F
048C  0020     MOVLB 0x0
048D  14E7     BSF comand_butt, 0x1
048E  2C91     GOTO 0x491
048F  0020     MOVLB 0x0
0490  10E7     BCF comand_butt, 0x1
441:                       button_state.MINUS = temp_state;
0491  084A     MOVF temp_SPBRG, W
0492  3901     ANDLW 0x1
0493  10E6     BCF __pbssBANK0, 0x1
0494  1D03     BTFSS STATUS, 0x2
0495  14E6     BSF __pbssBANK0, 0x1
442:                       button_count.MINUS = 0;
0496  0023     MOVLB 0x3
0497  01C6     CLRF 0x1C6
0498  01C7     CLRF 0x1C7
443:                   }
444:               } else
445:                   button_count.MINUS = 0;
446:           
447:               UINT8 temp_state = !(BUTTON_ENTER ^ ACTIVE_LEVEL_BUTTON);
0499  1003     BCF STATUS, 0x0
049A  0020     MOVLB 0x0
049B  1C0C     BTFSS PORTA, 0x0
049C  1403     BSF STATUS, 0x0
049D  25F9     CALL 0x5F9
049E  3184     MOVLP 0x4
448:               if (temp_state != button_state.ENTER)
049F  0C89     RRF WREG, F
04A0  3901     ANDLW 0x1
04A1  064A     XORWF temp_SPBRG, W
04A2  1903     BTFSC STATUS, 0x2
04A3  2CC0     GOTO 0x4C0
449:               {
450:                   button_count.ENTER += Timer_1;
04A4  0848     MOVF Timer_1, W
04A5  0023     MOVLB 0x3
04A6  07C8     ADDWF 0x1C8, F
04A7  0020     MOVLB 0x0
04A8  0849     MOVF 0x49, W
04A9  0023     MOVLB 0x3
04AA  3DC9     ADDWFC 0x1C9, F
451:                   if (button_count.ENTER >= time_filt_button)
04AB  3000     MOVLW 0x0
04AC  0249     SUBWF 0x1C9, W
04AD  30BB     MOVLW 0xBB
04AE  1903     BTFSC STATUS, 0x2
04AF  0248     SUBWF 0x1C8, W
04B0  1C03     BTFSS STATUS, 0x0
04B1  2CC4     GOTO 0x4C4
452:                   {
453:                       comand_butt.ENTER = !temp_state;
04B2  0020     MOVLB 0x0
04B3  084A     MOVF temp_SPBRG, W
04B4  1D03     BTFSS STATUS, 0x2
04B5  2CB9     GOTO 0x4B9
04B6  0020     MOVLB 0x0
04B7  1567     BSF comand_butt, 0x2
04B8  2CBB     GOTO 0x4BB
04B9  0020     MOVLB 0x0
04BA  1167     BCF comand_butt, 0x2
454:                       button_state.ENTER = temp_state;
04BB  084A     MOVF temp_SPBRG, W
04BC  3901     ANDLW 0x1
04BD  1166     BCF __pbssBANK0, 0x2
04BE  1D03     BTFSS STATUS, 0x2
04BF  1566     BSF __pbssBANK0, 0x2
455:                       button_count.ENTER = 0;
04C0  0023     MOVLB 0x3
04C1  01C8     CLRF 0x1C8
04C2  01C9     CLRF 0x1C9
456:                   }
457:               } else
458:                   button_count.ENTER = 0;
459:           
460:               UINT8 temp_state = !(BUTTON_ESC ^ ACTIVE_LEVEL_BUTTON);
04C3  1003     BCF STATUS, 0x0
04C4  0020     MOVLB 0x0
04C5  1D8C     BTFSS PORTA, 0x3
04C6  1403     BSF STATUS, 0x0
04C7  25F9     CALL 0x5F9
04C8  3184     MOVLP 0x4
461:               if (temp_state != button_state.ESC)
04C9  00C3     MOVWF 0x43
04CA  0CC3     RRF 0x43, F
04CB  0C43     RRF 0x43, W
04CC  3901     ANDLW 0x1
04CD  064A     XORWF temp_SPBRG, W
04CE  1903     BTFSC STATUS, 0x2
04CF  2CEC     GOTO 0x4EC
462:               {
463:                   button_count.ESC += Timer_1;
04D0  0848     MOVF Timer_1, W
04D1  0023     MOVLB 0x3
04D2  07CA     ADDWF 0x1CA, F
04D3  0020     MOVLB 0x0
04D4  0849     MOVF 0x49, W
04D5  0023     MOVLB 0x3
04D6  3DCB     ADDWFC 0x1CB, F
464:                   if (button_count.ESC >= time_filt_button)
04D7  3000     MOVLW 0x0
04D8  024B     SUBWF 0x1CB, W
04D9  30BB     MOVLW 0xBB
04DA  1903     BTFSC STATUS, 0x2
04DB  024A     SUBWF 0x1CA, W
04DC  1C03     BTFSS STATUS, 0x0
04DD  2CEF     GOTO 0x4EF
465:                   {
466:                       comand_butt.ESC = !temp_state;
04DE  0020     MOVLB 0x0
04DF  084A     MOVF temp_SPBRG, W
04E0  1D03     BTFSS STATUS, 0x2
04E1  2CE5     GOTO 0x4E5
04E2  0020     MOVLB 0x0
04E3  15E7     BSF comand_butt, 0x3
04E4  2CE7     GOTO 0x4E7
04E5  0020     MOVLB 0x0
04E6  11E7     BCF comand_butt, 0x3
467:                       button_state.ESC = temp_state;
04E7  084A     MOVF temp_SPBRG, W
04E8  3901     ANDLW 0x1
04E9  11E6     BCF __pbssBANK0, 0x3
04EA  1D03     BTFSS STATUS, 0x2
04EB  15E6     BSF __pbssBANK0, 0x3
468:                       button_count.ESC = 0;
04EC  0023     MOVLB 0x3
04ED  01CA     CLRF 0x1CA
04EE  01CB     CLRF 0x1CB
469:                   }
470:               } else
471:                   button_count.ESC = 0;
472:           
473:               static UINT32 count_auto_esc = 0;
474:               count_auto_esc += Timer_1;
04EF  0020     MOVLB 0x0
04F0  0848     MOVF Timer_1, W
04F1  0023     MOVLB 0x3
04F2  07CC     ADDWF count_auto_esc, F
04F3  0020     MOVLB 0x0
04F4  0849     MOVF 0x49, W
04F5  0023     MOVLB 0x3
04F6  3DCD     ADDWFC 0x1CD, F
04F7  3000     MOVLW 0x0
04F8  3DCE     ADDWFC 0x1CE, F
04F9  3DCF     ADDWFC 0x1CF, F
475:               if (button_state.All)
04FA  0020     MOVLB 0x0
04FB  0866     MOVF __pbssBANK0, W
04FC  1903     BTFSC STATUS, 0x2
04FD  2D03     GOTO 0x503
476:                   count_auto_esc = 0;
04FE  0023     MOVLB 0x3
04FF  01CC     CLRF count_auto_esc
0500  01CD     CLRF 0x1CD
0501  01CE     CLRF 0x1CE
0502  01CF     CLRF 0x1CF
477:               if (count_auto_esc > 20000000 / PERIOD_INTERRUPT_MKS)
0503  0023     MOVLB 0x3
0504  084F     MOVF 0x1CF, W
0505  1D03     BTFSS STATUS, 0x2
0506  2D0F     GOTO 0x50F
0507  3049     MOVLW 0x49
0508  024C     SUBWF count_auto_esc, W
0509  30E8     MOVLW 0xE8
050A  3B4D     SUBWFB 0x1CD, W
050B  3001     MOVLW 0x1
050C  3B4E     SUBWFB 0x1CE, W
050D  1C03     BTFSS STATUS, 0x0
050E  2D15     GOTO 0x515
478:               {
479:                   count_auto_esc = 0;
050F  01CC     CLRF count_auto_esc
0510  01CD     CLRF 0x1CD
0511  01CE     CLRF 0x1CE
0512  01CF     CLRF 0x1CF
480:                   comand_butt.ESC = 1;
0513  0020     MOVLB 0x0
0514  15E7     BSF comand_butt, 0x3
481:               }
482:           
483:           #if 1   //пульсы
484:           #define PERIOD_SPEED_PULSE (100000/PERIOD_INTERRUPT_MKS) //мкс
485:           #define TIME_RUN_PULSE (1000000 / PERIOD_INTERRUPT_MKS)
486:               static UINT16 count_pulse = 0;
487:               static INT16 count_speed_pulse = 0;
488:               static UINT16 time_pulse = 0;
489:               static UINT8 Number_Pulses_in_sec = 0;
490:               if (button_state.All)
0515  0020     MOVLB 0x0
0516  0866     MOVF __pbssBANK0, W
0517  1903     BTFSC STATUS, 0x2
0518  2D7D     GOTO 0x57D
491:               {
492:                   count_pulse += Timer_1;
0519  0848     MOVF Timer_1, W
051A  0023     MOVLB 0x3
051B  07DF     ADDWF count_pulse, F
051C  0020     MOVLB 0x0
051D  0849     MOVF 0x49, W
051E  0023     MOVLB 0x3
051F  3DE0     ADDWFC 0x1E0, F
493:                   count_speed_pulse += (INT16) Timer_1;
0520  0020     MOVLB 0x0
0521  0848     MOVF Timer_1, W
0522  0023     MOVLB 0x3
0523  07DD     ADDWF count_speed_pulse, F
0524  0020     MOVLB 0x0
0525  0849     MOVF 0x49, W
0526  0023     MOVLB 0x3
0527  3DDE     ADDWFC 0x1DE, F
494:                   if (count_speed_pulse >= PERIOD_SPEED_PULSE)
0528  085E     MOVF 0x1DE, W
0529  3A80     XORLW 0x80
052A  0020     MOVLB 0x0
052B  00C3     MOVWF 0x43
052C  3082     MOVLW 0x82
052D  0243     SUBWF 0x43, W
052E  1D03     BTFSS STATUS, 0x2
052F  2D33     GOTO 0x533
0530  3071     MOVLW 0x71
0531  0023     MOVLB 0x3
0532  025D     SUBWF count_speed_pulse, W
0533  1C03     BTFSS STATUS, 0x0
0534  2D68     GOTO 0x568
495:                   {
496:                       time_pulse = (1000000 / Number_Pulses_in_sec) / PERIOD_INTERRUPT_MKS;
0535  0022     MOVLB 0x2
0536  086F     MOVF Number_Pulses_in_sec, W
0537  0020     MOVLB 0x0
0538  00AC     MOVWF divisor
0539  300F     MOVLW 0xF
053A  01AD     CLRF cnt_i
053B  01AE     CLRF buff_read
053C  01AF     CLRF sizebuff
053D  01B3     CLRF command
053E  00B2     MOVWF wr_rd
053F  3042     MOVLW 0x42
0540  00B1     MOVWF 0x31
0541  3040     MOVLW 0x40
0542  00B0     MOVWF ad_current
0543  258D     CALL 0x58D
0544  3184     MOVLP 0x4
0545  082F     MOVF sizebuff, W
0546  00C7     MOVWF 0x47
0547  082E     MOVF buff_read, W
0548  00C6     MOVWF 0x46
0549  082D     MOVF cnt_i, W
054A  00C5     MOVWF 0x45
054B  082C     MOVF divisor, W
054C  00C4     MOVWF temp_limit_ind
054D  30A0     MOVLW 0xA0
054E  00AC     MOVWF divisor
054F  01AD     CLRF cnt_i
0550  01AE     CLRF buff_read
0551  01AF     CLRF sizebuff
0552  0847     MOVF 0x47, W
0553  00B3     MOVWF command
0554  0846     MOVF 0x46, W
0555  00B2     MOVWF wr_rd
0556  0845     MOVF 0x45, W
0557  00B1     MOVWF 0x31
0558  0844     MOVF temp_limit_ind, W
0559  00B0     MOVWF ad_current
055A  258D     CALL 0x58D
055B  3184     MOVLP 0x4
055C  082D     MOVF cnt_i, W
055D  0023     MOVLB 0x3
055E  00DC     MOVWF 0x1DC
055F  0020     MOVLB 0x0
0560  082C     MOVF divisor, W
0561  0023     MOVLB 0x3
0562  00DB     MOVWF time_pulse
497:                       Number_Pulses_in_sec++;
0563  0022     MOVLB 0x2
0564  0AEF     INCF Number_Pulses_in_sec, F
498:                       count_speed_pulse = 0;
0565  0023     MOVLB 0x3
0566  01DD     CLRF count_speed_pulse
0567  01DE     CLRF 0x1DE
499:                   }
500:                   if (count_pulse >= time_pulse)
0568  0023     MOVLB 0x3
0569  085C     MOVF 0x1DC, W
056A  0260     SUBWF 0x1E0, W
056B  1D03     BTFSS STATUS, 0x2
056C  2D6F     GOTO 0x56F
056D  085B     MOVF time_pulse, W
056E  025F     SUBWF count_pulse, W
056F  1C03     BTFSS STATUS, 0x0
0570  2D8B     GOTO 0x58B
501:                   {
502:                       if (button_state.PLUS)
0571  0020     MOVLB 0x0
0572  1C66     BTFSS __pbssBANK0, 0x0
0573  2D76     GOTO 0x576
503:                       {
504:                           comand_butt.PLUS = 1;
0574  1467     BSF comand_butt, 0x0
505:                       } else if (button_state.MINUS)
0575  2D79     GOTO 0x579
0576  1CE6     BTFSS __pbssBANK0, 0x1
0577  2D79     GOTO 0x579
506:                       {
507:                           comand_butt.MINUS = 1;
0578  14E7     BSF comand_butt, 0x1
508:                       }
509:                       count_pulse = 0;
0579  0023     MOVLB 0x3
057A  01DF     CLRF count_pulse
057B  01E0     CLRF 0x1E0
057C  2D8B     GOTO 0x58B
510:                   }
511:           
512:               } else
513:               {
514:                   time_pulse = 0xFFFF;
057D  30FF     MOVLW 0xFF
057E  0023     MOVLB 0x3
057F  00DB     MOVWF time_pulse
0580  00DC     MOVWF 0x1DC
515:                   Number_Pulses_in_sec = 5;
0581  3005     MOVLW 0x5
0582  0022     MOVLB 0x2
0583  00EF     MOVWF Number_Pulses_in_sec
516:                   count_pulse = 0;
0584  0023     MOVLB 0x3
0586  01DF     CLRF count_pulse
0587  01E0     CLRF 0x1E0
517:                   count_speed_pulse = PERIOD_SPEED_PULSE - TIME_RUN_PULSE;
0585  3007     MOVLW 0x7
0588  00DD     MOVWF count_speed_pulse
0589  30EA     MOVLW 0xEA
058A  00DE     MOVWF 0x1DE
518:               }
519:           #endif
520:               func_ind_main_men();
058B  318C     MOVLP 0xC
058C  2C51     GOTO 0x451
521:           }
522:           
523:           void hundler_menu_func(UINT8 pre_pos, UINT8 next_pos, indicator_t indicator, UINT8 *lock) {
0DA9  00AF     MOVWF 0x1AF
524:               Symbol_Latch.indicator[0] = indicator;
0DAA  3027     MOVLW 0x27
0DAB  0086     MOVWF FSR1L
0DAC  3000     MOVLW 0x0
0DAD  273D     CALL 0x73D
0DAE  3188     MOVLP 0x8
0DAF  00AE     MOVWF 0x1AE
0DB0  0016     MOVIW FSR1++
0DB1  001A     MOVWI FSR0++
0DB2  0BAE     DECFSZ 0x1AE, F
0DB3  2DB0     GOTO 0x5B0
525:               if (!*lock)
0DB4  082D     MOVF 0x1AD, W
0DB5  0086     MOVWF FSR1L
0DB6  0187     CLRF FSR1H
0DB7  0801     MOVF INDF1, W
0DB8  1D03     BTFSS STATUS, 0x2
0DB9  0008     RETURN
526:               {
527:                   if (comand_butt.PLUS)
0DBA  1C67     BTFSS flags, 0x0
0DBB  2DC2     GOTO 0x5C2
528:                   {
529:                       index_menu = next_pos;
0DBC  0826     MOVF 0x1A6, W
0DBD  2DBF     GOTO 0x5BF
530:                       comand_butt.All = 0;
0DC0  01E7     CLRF flags
531:                   } else if (comand_butt.MINUS)
0DC1  0008     RETURN
0DC2  18E7     BTFSC flags, 0x1
0DC3  2DBE     GOTO 0x5BE
532:                   {
533:                       index_menu = pre_pos;
0DBE  082F     MOVF 0x1AF, W
0DBF  00E8     MOVWF Timer_Interrupt_3
534:                       comand_butt.All = 0;
535:                   } else if (comand_butt.ESC)
0DC4  1DE7     BTFSS flags, 0x3
0DC5  0008     RETURN
536:                   {
537:                       index_menu = 0;
0DC6  01E8     CLRF Timer_Interrupt_3
538:                       comand_butt.All = 0;
0DC7  01E7     CLRF flags
0DC8  0008     RETURN
539:                   }
540:               }
541:           }
542:           
543:           void func_ind_main_men() {
544:           
545:               static UINT8 Show_Hide = 0;
546:               UINT8 lock = 0;
0C51  0020     MOVLB 0x0
0C52  01C2     CLRF lock
0C53  26AD     CALL 0x6AD
0C54  3188     MOVLP 0x8
547:               switch (menu_data[index_menu].type_menu)
0C55  2587     CALL 0x587
0C56  3188     MOVLP 0x8
0C57  308E     MOVLW 0x8E
0C58  26B4     CALL 0x6B4
0C59  3188     MOVLP 0x8
0C5A  0801     MOVF INDF1, W
0C5B  390F     ANDLW 0xF
0C5C  1903     BTFSC STATUS, 0x2
0C5D  2C68     GOTO 0x468
0C5E  3A01     XORLW 0x1
0C5F  1903     BTFSC STATUS, 0x2
0C60  2CEC     GOTO 0x4EC
0C61  3A03     XORLW 0x3
0C62  1903     BTFSC STATUS, 0x2
0C63  2C86     GOTO 0x486
0C64  3A01     XORLW 0x1
0C65  1903     BTFSC STATUS, 0x2
0C66  2D5C     GOTO 0x55C
0C67  2D86     GOTO 0x586
548:               {
549:                   case SHOW:
550:                       hundler_menu_func(menu_data[index_menu].pre, menu_data[index_menu].next, menu_data_ind1[index_menu], &lock);
0C68  26AD     CALL 0x6AD
0C69  3188     MOVLP 0x8
0C6A  2587     CALL 0x587
0C6B  3188     MOVLP 0x8
0C6C  3099     MOVLW 0x99
0C6D  26B4     CALL 0x6B4
0C6E  3188     MOVLP 0x8
0C6F  2728     CALL 0x728
0C70  3188     MOVLP 0x8
0C71  259C     CALL 0x59C
0C72  3188     MOVLP 0x8
0C73  3EA0     ADDLW 0xA0
0C74  0086     MOVWF FSR1
0C75  3002     MOVLW 0x2
0C76  2693     CALL 0x693
0C77  3188     MOVLP 0x8
0C78  2587     CALL 0x587
0C79  3188     MOVLP 0x8
0C7A  309A     MOVLW 0x9A
0C7B  26BE     CALL 0x6BE
0C7C  3188     MOVLP 0x8
0C7D  0801     MOVF INDF1, W
0C7E  25A9     CALL 0x5A9
0C7F  3188     MOVLP 0x8
551:                       Symbol_Latch.indicator[1] = menu_data_ind2[index_menu];
0C80  3006     MOVLW 0x6
0C81  00A0     MOVWF __pcstackBANK0
0C82  0868     MOVF index_menu, W
0C83  259C     CALL 0x59C
0C84  3188     MOVLP 0x8
0C85  2EC8     GOTO 0x6C8
552:                       break;
553:                   case EN_DOWN:
554:                       hundler_menu_func(menu_data[index_menu].pre, menu_data[index_menu].next, menu_data_ind1[index_menu], &lock);
0C86  26AD     CALL 0x6AD
0C87  3188     MOVLP 0x8
0C88  2587     CALL 0x587
0C89  3188     MOVLP 0x8
0C8A  3099     MOVLW 0x99
0C8B  26B4     CALL 0x6B4
0C8C  3188     MOVLP 0x8
0C8D  2728     CALL 0x728
0C8E  3188     MOVLP 0x8
0C8F  259C     CALL 0x59C
0C90  3188     MOVLP 0x8
0C91  3EA0     ADDLW 0xA0
0C92  0086     MOVWF FSR1
0C93  3002     MOVLW 0x2
0C94  2693     CALL 0x693
0C95  3188     MOVLP 0x8
0C96  2587     CALL 0x587
0C97  3188     MOVLP 0x8
0C98  309A     MOVLW 0x9A
0C99  26BE     CALL 0x6BE
0C9A  3188     MOVLP 0x8
0C9B  0801     MOVF INDF1, W
0C9C  25A9     CALL 0x5A9
0C9D  3188     MOVLP 0x8
0C9E  26AD     CALL 0x6AD
0C9F  3188     MOVLP 0x8
555:                       func_ind_enter_value_menu(menu_data[index_menu].add_enter_value, menu_data[index_menu].Hi_val, menu_data[index_menu].Lo_val, &lock, menu_data[index_menu].Add_eep, &Show_Hide, menu_data[index_menu].Step);
0CA0  2587     CALL 0x587
0CA1  3188     MOVLP 0x8
0CA2  3091     MOVLW 0x91
0CA3  26B4     CALL 0x6B4
0CA4  3188     MOVLP 0x8
0CA5  2719     CALL 0x719
0CA6  3188     MOVLP 0x8
0CA7  26AD     CALL 0x6AD
0CA8  3188     MOVLP 0x8
0CA9  2587     CALL 0x587
0CAA  3188     MOVLP 0x8
0CAB  3093     MOVLW 0x93
0CAC  26BE     CALL 0x6BE
0CAD  3188     MOVLP 0x8
0CAE  2712     CALL 0x712
0CAF  3188     MOVLP 0x8
0CB0  26AD     CALL 0x6AD
0CB1  3188     MOVLP 0x8
0CB2  2587     CALL 0x587
0CB3  3188     MOVLP 0x8
0CB4  26D8     CALL 0x6D8
0CB5  3188     MOVLP 0x8
0CB6  26AD     CALL 0x6AD
0CB7  3188     MOVLP 0x8
0CB8  2587     CALL 0x587
0CB9  3188     MOVLP 0x8
0CBA  26E7     CALL 0x6E7
0CBB  3188     MOVLP 0x8
0CBC  26AD     CALL 0x6AD
0CBD  3188     MOVLP 0x8
0CBE  2587     CALL 0x587
0CBF  3188     MOVLP 0x8
0CC0  26F6     CALL 0x6F6
0CC1  3188     MOVLP 0x8
0CC2  25C9     CALL 0x5C9
0CC3  3188     MOVLP 0x8
556:                        if (Show_Hide)
0CC4  0020     MOVLB 0x0
0CC5  086F     MOVF Show_Hide, W
0CC6  1903     BTFSC STATUS, 0x2
0CC7  2CE6     GOTO 0x4E6
557:                            for (UINT8 index = sizeof (indicator_t) - 1; index >= sizeof (indicator_t) - menu_data[index_menu].blink_width; index++)
0CC8  3005     MOVLW 0x5
0CC9  00C0     MOVWF index
0CCA  26AD     CALL 0x6AD
0CCB  3188     MOVLP 0x8
0CCC  2587     CALL 0x587
0CCD  3188     MOVLP 0x8
0CCE  308E     MOVLW 0x8E
0CCF  26B4     CALL 0x6B4
0CD0  3188     MOVLP 0x8
0CD1  2743     CALL 0x743
0CD2  3188     MOVLP 0x8
0CD3  1C03     BTFSS STATUS, 0x0
0CD4  03B8     DECF 0x38, F
0CD5  0840     MOVF index, W
0CD6  00B9     MOVWF crcTx
0CD7  01BA     CLRF S_Number
0CD8  0838     MOVF 0x38, W
0CD9  023A     SUBWF S_Number, W
0CDA  1D03     BTFSS STATUS, 0x2
0CDB  2CDE     GOTO 0x4DE
0CDC  0837     MOVF Number_reg_wr, W
0CDD  0239     SUBWF crcTx, W
0CDE  1C03     BTFSS STATUS, 0x0
0CDF  0008     RETURN
0CE4  0AC0     INCF index, F
0CE5  2CCA     GOTO 0x4CA
558:                                Symbol_Latch.indicator[1].mas[index] = Space_;
0CE0  0840     MOVF index, W
0CE1  3E62     ADDLW 0x62
0CE2  272E     CALL 0x72E
0CE3  3188     MOVLP 0x8
559:                        else
560:                            Symbol_Latch.indicator[1] = menu_data_ind2[index_menu];
0CE6  3006     MOVLW 0x6
0CE7  00A0     MOVWF __pcstackBANK0
0CE8  0868     MOVF index_menu, W
0CE9  259C     CALL 0x59C
0CEA  3188     MOVLP 0x8
0CEB  2EC8     GOTO 0x6C8
561:                       break;
562:                   case EN_UP:
563:                       hundler_menu_func(menu_data[index_menu].pre, menu_data[index_menu].next, menu_data_ind2[index_menu], &lock);
0CEC  26AD     CALL 0x6AD
0CED  3188     MOVLP 0x8
0CEE  2587     CALL 0x587
0CEF  3188     MOVLP 0x8
0CF0  3099     MOVLW 0x99
0CF1  26B4     CALL 0x6B4
0CF2  3188     MOVLP 0x8
0CF3  2728     CALL 0x728
0CF4  3188     MOVLP 0x8
0CF5  259C     CALL 0x59C
0CF6  3188     MOVLP 0x8
0CF7  3E20     ADDLW 0x20
0CF8  0086     MOVWF FSR1
0CF9  3003     MOVLW 0x3
0CFA  2693     CALL 0x693
0CFB  3188     MOVLP 0x8
0CFC  2587     CALL 0x587
0CFD  3188     MOVLP 0x8
0CFE  309A     MOVLW 0x9A
0CFF  26BE     CALL 0x6BE
0D00  3188     MOVLP 0x8
0D01  0801     MOVF INDF1, W
0D02  25A9     CALL 0x5A9
0D03  3188     MOVLP 0x8
0D04  26AD     CALL 0x6AD
0D05  3188     MOVLP 0x8
564:                       func_ind_enter_value_menu(menu_data[index_menu].add_enter_value, menu_data[index_menu].Hi_val, menu_data[index_menu].Lo_val, &lock, menu_data[index_menu].Add_eep, &Show_Hide, menu_data[index_menu].Step);
0D06  2587     CALL 0x587
0D07  3188     MOVLP 0x8
0D08  3091     MOVLW 0x91
0D09  26B4     CALL 0x6B4
0D0A  3188     MOVLP 0x8
0D0B  2719     CALL 0x719
0D0C  3188     MOVLP 0x8
0D0D  26AD     CALL 0x6AD
0D0E  3188     MOVLP 0x8
0D0F  2587     CALL 0x587
0D10  3188     MOVLP 0x8
0D11  3093     MOVLW 0x93
0D12  26BE     CALL 0x6BE
0D13  3188     MOVLP 0x8
0D14  2712     CALL 0x712
0D15  3188     MOVLP 0x8
0D16  26AD     CALL 0x6AD
0D17  3188     MOVLP 0x8
0D18  2587     CALL 0x587
0D19  3188     MOVLP 0x8
0D1A  26D8     CALL 0x6D8
0D1B  3188     MOVLP 0x8
0D1C  26AD     CALL 0x6AD
0D1D  3188     MOVLP 0x8
0D1E  2587     CALL 0x587
0D1F  3188     MOVLP 0x8
0D20  26E7     CALL 0x6E7
0D21  3188     MOVLP 0x8
0D22  26AD     CALL 0x6AD
0D23  3188     MOVLP 0x8
0D24  2587     CALL 0x587
0D25  3188     MOVLP 0x8
0D26  26F6     CALL 0x6F6
0D27  3188     MOVLP 0x8
0D28  25C9     CALL 0x5C9
0D29  3188     MOVLP 0x8
565:                       if (Show_Hide)
0D2A  0020     MOVLB 0x0
0D2B  086F     MOVF Show_Hide, W
0D2C  1903     BTFSC STATUS, 0x2
0D2D  2D4C     GOTO 0x54C
566:                            for (UINT8 index = sizeof (indicator_t) - 1; index >= sizeof (indicator_t) - menu_data[index_menu].blink_width; index++)
0D2E  3005     MOVLW 0x5
0D2F  00C1     MOVWF index
0D30  26AD     CALL 0x6AD
0D31  3188     MOVLP 0x8
0D32  2587     CALL 0x587
0D33  3188     MOVLP 0x8
0D34  308E     MOVLW 0x8E
0D35  26B4     CALL 0x6B4
0D36  3188     MOVLP 0x8
0D37  2743     CALL 0x743
0D38  3188     MOVLP 0x8
0D39  1C03     BTFSS STATUS, 0x0
0D3A  03B8     DECF 0x38, F
0D3B  0841     MOVF index, W
0D3C  00B9     MOVWF crcTx
0D3D  01BA     CLRF S_Number
0D3E  0838     MOVF 0x38, W
0D3F  023A     SUBWF S_Number, W
0D40  1D03     BTFSS STATUS, 0x2
0D41  2D44     GOTO 0x544
0D42  0837     MOVF Number_reg_wr, W
0D43  0239     SUBWF crcTx, W
0D44  1C03     BTFSS STATUS, 0x0
0D45  0008     RETURN
0D4A  0AC1     INCF index, F
0D4B  2D30     GOTO 0x530
567:                                Symbol_Latch.indicator[0].mas[index] = Space_;
0D46  0841     MOVF index, W
0D47  3E5C     ADDLW 0x5C
0D48  272E     CALL 0x72E
0D49  3188     MOVLP 0x8
568:                        else
569:                            Symbol_Latch.indicator[0] = menu_data_ind1[index_menu];
0D4C  3006     MOVLW 0x6
0D4D  00A0     MOVWF __pcstackBANK0
0D4E  0868     MOVF index_menu, W
0D4F  259C     CALL 0x59C
0D50  3188     MOVLP 0x8
0D51  3EA0     ADDLW 0xA0
0D52  0086     MOVWF FSR1
0D53  3002     MOVLW 0x2
0D54  273D     CALL 0x73D
0D55  3188     MOVLP 0x8
0D56  00B4     MOVWF error_adr
0D57  0016     MOVIW FSR1++
0D58  001A     MOVWI FSR0++
0D59  0BB4     DECFSZ error_adr, F
0D5A  2D57     GOTO 0x557
0D5B  0008     RETURN
570:                       break;
571:                   case GO:
572:                       hundler_menu_func(menu_data[index_menu].pre, menu_data[index_menu].next, menu_data_ind1[index_menu], &lock);
0D5C  26AD     CALL 0x6AD
0D5D  3188     MOVLP 0x8
0D5E  2587     CALL 0x587
0D5F  3188     MOVLP 0x8
0D60  3099     MOVLW 0x99
0D61  26B4     CALL 0x6B4
0D62  3188     MOVLP 0x8
0D63  2728     CALL 0x728
0D64  3188     MOVLP 0x8
0D65  259C     CALL 0x59C
0D66  3188     MOVLP 0x8
0D67  3EA0     ADDLW 0xA0
0D68  0086     MOVWF FSR1
0D69  3002     MOVLW 0x2
0D6A  2693     CALL 0x693
0D6B  3188     MOVLP 0x8
0D6C  2587     CALL 0x587
0D6D  3188     MOVLP 0x8
0D6E  309A     MOVLW 0x9A
0D6F  26BE     CALL 0x6BE
0D70  3188     MOVLP 0x8
0D71  0801     MOVF INDF1, W
0D72  25A9     CALL 0x5A9
0D73  3188     MOVLP 0x8
573:                       if (comand_butt.ENTER)
0D74  1D67     BTFSS comand_butt, 0x2
0D75  2D80     GOTO 0x580
0D76  26AD     CALL 0x6AD
0D77  3188     MOVLP 0x8
574:                       {
575:                           index_menu = menu_data[index_menu].deep;
0D78  2587     CALL 0x587
0D79  3188     MOVLP 0x8
0D7A  309B     MOVLW 0x9B
0D7B  26B4     CALL 0x6B4
0D7C  3188     MOVLP 0x8
0D7D  0801     MOVF INDF1, W
0D7E  00E8     MOVWF index_menu
576:                           comand_butt.All = 0;
0D7F  01E7     CLRF comand_butt
577:                       }
578:                       Symbol_Latch.indicator[1] = menu_data_ind2[index_menu];
0D80  3006     MOVLW 0x6
0D81  00A0     MOVWF __pcstackBANK0
0D82  0868     MOVF index_menu, W
0D83  259C     CALL 0x59C
0D84  3188     MOVLP 0x8
0D85  2EC8     GOTO 0x6C8
579:                       break;
580:                   default:
581:                       break;
582:               }
583:           }
0D86  0008     RETURN
584:           
585:           void func_ind_enter_value_menu(INT16 *value, INT16 Hi, INT16 Lo, UINT8 *lock, UINT8 eep_add, UINT8 *Show_Hide, INT16 Step) {
0DC9  00B3     MOVWF command
586:               static UINT16 cnt_time = 0;
587:               cnt_time += hundler_Timers(&Timer_Interrupt_2);
0DCA  30EA     MOVLW 0xEA
0DCB  2658     CALL 0x658
0DCC  3188     MOVLP 0x8
0DCD  0820     MOVF __pcstackBANK0, W
0DCE  0023     MOVLB 0x3
0DCF  07D9     ADDWF cnt_time, F
0DD0  0020     MOVLB 0x0
0DD1  0821     MOVF addr, W
0DD2  0023     MOVLB 0x3
0DD3  3DDA     ADDWFC 0x1DA, F
588:               if (*lock)
0DD4  0020     MOVLB 0x0
0DD5  082A     MOVF data, W
0DD6  0086     MOVWF FSR1
0DD7  0187     CLRF FSR1H
0DD8  0801     MOVF INDF1, W
0DD9  1903     BTFSC STATUS, 0x2
0DDA  2E4F     GOTO 0x64F
589:               {
590:                   if (comand_butt.ENTER || comand_butt.ESC)
0DDB  1967     BTFSC comand_butt, 0x2
0DDC  2DDF     GOTO 0x5DF
0DDD  1DE7     BTFSS comand_butt, 0x3
0DDE  2DF4     GOTO 0x5F4
591:                   {
592:                       EEPR_WRITE(eep_add, *value);
0DDF  01B2     CLRF wr_rd
0DE0  0832     MOVF wr_rd, W
0DE1  0733     ADDWF command, W
0DE2  00AF     MOVWF sizebuff
0DE3  270C     CALL 0x70C
0DE4  3188     MOVLP 0x8
0DE5  0832     MOVF wr_rd, W
0DE6  022B     SUBWF eep_add, W
0DE7  2357     CALL 0x357
0DE8  3188     MOVLP 0x8
0DE9  0020     MOVLB 0x0
0DEA  3002     MOVLW 0x2
0DEB  0AB2     INCF wr_rd, F
0DEC  0232     SUBWF wr_rd, W
0DED  1C03     BTFSS STATUS, 0x0
0DEE  2DE0     GOTO 0x5E0
593:                       *lock = 0;
0DEF  082A     MOVF data, W
0DF0  0086     MOVWF FSR1
0DF1  0187     CLRF FSR1H
0DF2  0181     CLRF INDF1
0DF3  2E2C     GOTO 0x62C
594:                       cnt_time = 0;
595:                       *Show_Hide = 0;
596:                       comand_butt.All = 0;
597:                   } else if (comand_butt.MINUS)
0DF4  1CE7     BTFSS comand_butt, 0x1
0DF5  2E10     GOTO 0x610
598:                   {
599:                       *value -= Step;
0DF6  274A     CALL 0x74A
0DF7  3188     MOVLP 0x8
0DF8  0281     SUBWF INDF1, F
0DF9  3141     ADDFSR 1, 1
0DFA  082E     MOVF buff_read, W
0DFB  3B81     SUBWFB INDF1, F
0DFC  271E     CALL 0x71E
0DFD  3188     MOVLP 0x8
600:                       if (* value < Lo)
0DFE  3A80     XORLW 0x80
0DFF  00B1     MOVWF 0x31
0E00  0829     MOVF crcTx, W
0E01  3A80     XORLW 0x80
0E02  0231     SUBWF 0x31, W
0E03  1D03     BTFSS STATUS, 0x2
0E04  2E07     GOTO 0x607
0E05  0828     MOVF add, W
0E06  022F     SUBWF sizebuff, W
0E07  1803     BTFSC STATUS, 0x0
0E08  2E2C     GOTO 0x62C
601:                           *value = Hi;
0E09  2750     CALL 0x750
0E0A  3188     MOVLP 0x8
0E0B  0826     MOVF index, W
0E0C  3FC0     MOVWI 0[FSR1]
0E0D  0827     MOVF byte, W
0E0E  3FC1     MOVWI 1[FSR1]
602:                       cnt_time = 0;
0E2C  0023     MOVLB 0x3
0E2D  01D9     CLRF cnt_time
0E2E  01DA     CLRF 0x1DA
603:                       *Show_Hide = 0;
0E2F  0020     MOVLB 0x0
0E30  082C     MOVF divisor, W
0E31  0086     MOVWF FSR1
0E32  0187     CLRF FSR1H
0E33  0181     CLRF INDF1
604:                       comand_butt.All = 0;
0E34  01E7     CLRF comand_butt
605:                   } else if (comand_butt.PLUS)
0E0F  2E2C     GOTO 0x62C
0E10  1C67     BTFSS comand_butt, 0x0
0E11  2E35     GOTO 0x635
0E12  274A     CALL 0x74A
0E13  3188     MOVLP 0x8
606:                   {
607:                       *value += Step;
0E14  0781     ADDWF INDF1, F
0E15  3141     ADDFSR 1, 1
0E16  082E     MOVF buff_read, W
0E17  3D81     ADDWFC INDF1, F
0E18  271E     CALL 0x71E
0E19  3188     MOVLP 0x8
608:                       if (*value > Hi)
0E1A  0827     MOVF byte, W
0E1B  3A80     XORLW 0x80
0E1C  00B1     MOVWF 0x31
0E1D  0830     MOVF ad_current, W
0E1E  3A80     XORLW 0x80
0E1F  0231     SUBWF 0x31, W
0E20  1D03     BTFSS STATUS, 0x2
0E21  2E24     GOTO 0x624
0E22  082F     MOVF sizebuff, W
0E23  0226     SUBWF index, W
0E24  1803     BTFSC STATUS, 0x0
0E25  2E2C     GOTO 0x62C
0E26  2750     CALL 0x750
0E27  3188     MOVLP 0x8
609:                           *value = Lo;
0E28  0828     MOVF add, W
0E29  3FC0     MOVWI 0[FSR1]
0E2A  0829     MOVF crcTx, W
0E2B  3FC1     MOVWI 1[FSR1]
610:                       cnt_time = 0;
611:                       *Show_Hide = 0;
612:                       comand_butt.All = 0;
613:                   }
614:                   if (cnt_time >= PERIOD_BLINK_VALUE)
0E35  300C     MOVLW 0xC
0E36  0023     MOVLB 0x3
0E37  025A     SUBWF 0x1DA, W
0E38  3035     MOVLW 0x35
0E39  1903     BTFSC STATUS, 0x2
0E3A  0259     SUBWF cnt_time, W
0E3B  1C03     BTFSS STATUS, 0x0
0E3C  0008     RETURN
615:                   {
616:                       *Show_Hide = !*Show_Hide;
0E3D  0020     MOVLB 0x0
0E3E  082C     MOVF divisor, W
0E3F  0086     MOVWF FSR1
0E40  0187     CLRF FSR1H
0E41  082C     MOVF divisor, W
0E42  0084     MOVWF FSR0
0E43  0185     CLRF FSR0H
0E44  0800     MOVF INDF0, W
0E45  1D03     BTFSS STATUS, 0x2
0E46  2E49     GOTO 0x649
0E47  3001     MOVLW 0x1
0E48  2E4A     GOTO 0x64A
0E49  3000     MOVLW 0x0
0E4A  0081     MOVWF INDF1
617:                       cnt_time = 0;
0E4B  0023     MOVLB 0x3
0E4C  01D9     CLRF cnt_time
0E4D  01DA     CLRF 0x1DA
0E4E  0008     RETURN
618:                   }
619:               } else
620:               {
621:                   if (comand_butt.ENTER)
0E4F  1D67     BTFSS flags, 0x2
0E50  0008     RETURN
622:                   {
623:                       *lock = 1;
0E51  082A     MOVF 0x1AA, W
0E52  0086     MOVWF FSR1L
0E53  0187     CLRF FSR1H
0E54  0181     CLRF INDF1
0E55  0A81     INCF INDF1, F
624:                       comand_butt.All = 0;
0E56  01E7     CLRF flags
0E57  2E4B     GOTO 0x64B
625:                       cnt_time = 0;
626:                   }
627:               }
628:           }
---  C:/work_Git/VAR_C_NEW/VAR_C_NEW.X/Modbus.c  --------------------------------------------------------
1:             #define MODBUS_C_DATA
2:             #include "Modbus.h"
3:             #include "main.h"
4:             
5:             UINT16 addres_device = 0;
6:             UINT16 speed_device = 0;
7:             
8:             UINT8 Rx_Tx_data[RX_BUF_SIZE] = 0;
9:             UINT8 TX9Dbit[RX_BUF_SIZE] = 0;
10:            UINT8 Number_Rx_Byte = 0;
11:            UINT8 Number_Tx_Byte = 0;
12:            UINT8 size_Tx_frame = 0;
13:            //bit volatile Start_Recive = 0;
14:            UINT8 TimeOutFrame_1_5 = 0;
15:            UINT8 TimeOutFrame_3_5 = 0;
16:            UINT8 Error_Recive_1_5 = 0;
17:            
18:            HDR_Space Space[HDR_SPACE_SIZE] = {
19:                1, 100, 0, //      //0
20:            
21:                0, 200, 0, //      //1
22:                0, 201, 0, //      //2
23:                0, 202, 0, //      //3
24:                0, 203, 0, //      //4
25:                0, 204, 0, //      //5
26:                0, 205, 0, //      //6
27:                0, 206, 0, //      //7
28:                0, 207, 0, //      //8
29:                0, 208, 0, //      //9
30:                0, 209, 0, //      //10
31:                
32:                1, 1000, 0, //отладочный 0        //11
33:                1, 1001, 0, //отладочный 1        //12
34:                1, 1002, 0, //отладочный 2        //13
35:                1, 1003, 0, //отладочный 3        //14
36:                1, 1004, 0, //отладочный 4        //15
37:                1, 1005, 0, //отладочный 5        //16
38:                1, 1006, 0, //отладочный 6        //17
39:                1, 1007, 0, //отладочный 7        //18
40:                1, 1008, 0, //отладочный 8        //19
41:                1, 1009, 0, //отладочный 9        //20
42:            
43:                1, 1010, 0, //командный                 //21
44:                0, 1011, 0, //состояние кнопки          //22
45:                0, 1012, 0xFF, //состояние калибровки   //23
46:            
47:                0, 0xFFF0, 0x0306, // id                //24
48:                0, 0xFFF1, (soft_ver_S0 << 8) | (soft_ver_S1 * 10 + soft_ver_S2) // ver  //25
49:            };
50:            
51:            void set_baud_rate() {
52:                UINT32 Speed_devise_bit_sek = CALCUL_SPEED_DEV_BIT_S(speed_device);
1EFE  0022     MOVLB 0x2
1EFF  086B     MOVF speed_device, W
1F00  046C     IORWF 0x16C, W
1F01  1903     BTFSC STATUS, 0x2
1F02  2F80     GOTO 0x780
1F03  036B     DECF speed_device, W
1F04  046C     IORWF 0x16C, W
1F05  1903     BTFSC STATUS, 0x2
1F06  2F71     GOTO 0x771
1F07  3002     MOVLW 0x2
1F08  066B     XORWF speed_device, W
1F09  046C     IORWF 0x16C, W
1F0A  1903     BTFSC STATUS, 0x2
1F0B  2F63     GOTO 0x763
1F0C  3003     MOVLW 0x3
1F0D  066B     XORWF speed_device, W
1F0E  046C     IORWF 0x16C, W
1F0F  1903     BTFSC STATUS, 0x2
1F10  2F53     GOTO 0x753
1F11  3004     MOVLW 0x4
1F12  066B     XORWF speed_device, W
1F13  046C     IORWF 0x16C, W
1F14  1903     BTFSC STATUS, 0x2
1F15  2F45     GOTO 0x745
1F16  3005     MOVLW 0x5
1F17  066B     XORWF speed_device, W
1F18  046C     IORWF 0x16C, W
1F19  1903     BTFSC STATUS, 0x2
1F1A  2F36     GOTO 0x736
1F1B  3006     MOVLW 0x6
1F1C  066B     XORWF speed_device, W
1F1D  046C     IORWF 0x16C, W
1F1E  1903     BTFSC STATUS, 0x2
1F1F  2F26     GOTO 0x726
1F20  0020     MOVLB 0x0
1F21  3001     MOVLW 0x1
1F22  01CE     CLRF Number
1F23  00CD     MOVWF flag_read
1F24  30C2     MOVLW 0xC2
1F25  2F2B     GOTO 0x72B
1F26  0020     MOVLB 0x0
1F27  3001     MOVLW 0x1
1F28  01CE     CLRF Number
1F29  00CD     MOVWF flag_read
1F2A  302C     MOVLW 0x2C
1F2B  00CC     MOVWF temp_CREN
1F2C  01CB     CLRF sign
1F2D  084E     MOVF Number, W
1F2E  00CA     MOVWF temp_SPBRG
1F2F  084D     MOVF flag_read, W
1F30  00C9     MOVWF 0x49
1F31  084C     MOVF temp_CREN, W
1F32  00C8     MOVWF Timer_1
1F33  084B     MOVF sign, W
1F34  00C7     MOVWF 0x47
1F35  2F3C     GOTO 0x73C
1F36  0020     MOVLB 0x0
1F37  30E1     MOVLW 0xE1
1F38  01CA     CLRF temp_SPBRG
1F39  01C9     CLRF 0x49
1F3A  00C8     MOVWF Timer_1
1F3B  01C7     CLRF 0x47
1F3C  084A     MOVF temp_SPBRG, W
1F3D  00C6     MOVWF 0x46
1F3E  0849     MOVF 0x49, W
1F3F  00C5     MOVWF 0x45
1F40  0848     MOVF Timer_1, W
1F41  00C4     MOVWF temp_limit_ind
1F42  0847     MOVF 0x47, W
1F43  00C3     MOVWF 0x43
1F44  2F4B     GOTO 0x74B
1F45  0020     MOVLB 0x0
1F46  3096     MOVLW 0x96
1F47  01C6     CLRF 0x46
1F48  01C5     CLRF 0x45
1F49  00C4     MOVWF temp_limit_ind
1F4A  01C3     CLRF 0x43
1F4B  0846     MOVF 0x46, W
1F4C  00C2     MOVWF lock
1F4D  0845     MOVF 0x45, W
1F4E  00C1     MOVWF index
1F4F  0844     MOVF temp_limit_ind, W
1F50  00C0     MOVWF index
1F51  0843     MOVF 0x43, W
1F52  2F59     GOTO 0x759
1F53  0020     MOVLB 0x0
1F54  3070     MOVLW 0x70
1F55  01C2     CLRF lock
1F56  01C1     CLRF index
1F57  00C0     MOVWF index
1F58  3080     MOVLW 0x80
1F59  00BF     MOVWF 0x3F
1F5A  0842     MOVF lock, W
1F5B  00BE     MOVWF shift_pos
1F5C  0841     MOVF index, W
1F5D  00BD     MOVWF adressReg_wr
1F5E  0840     MOVF index, W
1F5F  00BC     MOVWF i
1F60  083F     MOVF 0x3F, W
1F61  00BB     MOVWF flag_read
1F62  2F69     GOTO 0x769
1F63  0020     MOVLB 0x0
1F64  304B     MOVLW 0x4B
1F65  01BE     CLRF shift_pos
1F66  01BD     CLRF adressReg_wr
1F67  00BC     MOVWF i
1F68  01BB     CLRF flag_read
1F69  083E     MOVF shift_pos, W
1F6A  00BA     MOVWF S_Number
1F6B  083D     MOVF adressReg_wr, W
1F6C  00B9     MOVWF crcTx
1F6D  083C     MOVF i, W
1F6E  00B8     MOVWF 0x38
1F6F  083B     MOVF flag_read, W
1F70  2F77     GOTO 0x777
1F71  0020     MOVLB 0x0
1F72  3038     MOVLW 0x38
1F73  01BA     CLRF S_Number
1F74  01B9     CLRF crcTx
1F75  00B8     MOVWF 0x38
1F76  3040     MOVLW 0x40
1F77  00B7     MOVWF Number_reg_wr
1F78  083A     MOVF S_Number, W
1F79  00D2     MOVWF index
1F7A  0839     MOVF crcTx, W
1F7B  00D1     MOVWF crcRx
1F7C  0838     MOVF 0x38, W
1F7D  00D0     MOVWF index
1F7E  0837     MOVF Number_reg_wr, W
1F7F  2F86     GOTO 0x786
1F80  0020     MOVLB 0x0
1F81  3025     MOVLW 0x25
1F82  01D2     CLRF index
1F83  01D1     CLRF crcRx
1F84  00D0     MOVWF index
1F85  3080     MOVLW 0x80
1F86  00CF     MOVWF Speed_devise_bit_sek
53:                SPBRG = CALCUL_SPBRG(Speed_devise_bit_sek);
1F87  3001     MOVLW 0x1
1F88  27E5     CALL 0x7E5
1F89  319E     MOVLP 0x1E
1F8A  3002     MOVLW 0x2
1F8B  27FB     CALL 0x7FB
1F8C  319E     MOVLP 0x1E
1F8D  0B89     DECFSZ WREG, F
1F8E  2F8B     GOTO 0x78B
1F8F  27F2     CALL 0x7F2
1F90  3003     MOVLW 0x3
1F91  00A7     MOVWF byte
1F92  30D0     MOVLW 0xD0
1F93  00A6     MOVWF index
1F94  3090     MOVLW 0x90
1F95  00A5     MOVWF flag_read
1F96  01A4     CLRF size_Buff
1F97  3196     MOVLP 0x16
1F98  2669     CALL 0x669
1F99  319E     MOVLP 0x1E
1F9A  27D7     CALL 0x7D7
1F9B  319E     MOVLP 0x1E
1F9C  3EFF     ADDLW 0xFF
1F9D  00B5     MOVWF adressReg_wr
1F9E  30FF     MOVLW 0xFF
1F9F  3D2E     ADDWFC buff_read, W
1FA0  00B6     MOVWF error_adr
1FA1  0835     MOVF adressReg_wr, W
1FA2  0023     MOVLB 0x3
1FA3  009B     MOVWF SPBRG
1FA4  0020     MOVLB 0x0
1FA5  0836     MOVF error_adr, W
1FA6  0023     MOVLB 0x3
1FA7  009C     MOVWF SPBRGH
54:                TimeOutFrame_3_5 = CALCUL_T_3_5(Speed_devise_bit_sek);
1FA8  3001     MOVLW 0x1
1FA9  0020     MOVLB 0x0
1FAA  27E5     CALL 0x7E5
1FAB  319E     MOVLP 0x1E
1FAC  3005     MOVLW 0x5
1FAD  27FB     CALL 0x7FB
1FAE  319E     MOVLP 0x1E
1FAF  0B89     DECFSZ WREG, F
1FB0  2FAD     GOTO 0x7AD
1FB1  27F2     CALL 0x7F2
1FB2  3005     MOVLW 0x5
1FB3  00A7     MOVWF byte
1FB4  30E6     MOVLW 0xE6
1FB5  00A6     MOVWF index
1FB6  309E     MOVLW 0x9E
1FB7  00A5     MOVWF flag_read
1FB8  30C0     MOVLW 0xC0
1FB9  00A4     MOVWF size_Buff
1FBA  3196     MOVLP 0x16
1FBB  2669     CALL 0x669
1FBC  319E     MOVLP 0x1E
1FBD  27D7     CALL 0x7D7
1FBE  319E     MOVLP 0x1E
1FBF  00F9     MOVWF TimeOutFrame_3_5
55:                TimeOutFrame_1_5 = CALCUL_T_1_5(Speed_devise_bit_sek);
1FC0  3001     MOVLW 0x1
1FC1  27E5     CALL 0x7E5
1FC2  319E     MOVLP 0x1E
1FC3  3005     MOVLW 0x5
1FC4  27FB     CALL 0x7FB
1FC5  319E     MOVLP 0x1E
1FC6  0B89     DECFSZ WREG, F
1FC7  2FC4     GOTO 0x7C4
1FC8  27F2     CALL 0x7F2
1FC9  3003     MOVLW 0x3
1FCA  00A7     MOVWF byte
1FCB  3047     MOVLW 0x47
1FCC  00A6     MOVWF index
1FCD  303B     MOVLW 0x3B
1FCE  00A5     MOVWF flag_read
1FCF  30C0     MOVLW 0xC0
1FD0  00A4     MOVWF size_Buff
1FD1  3196     MOVLP 0x16
1FD2  2669     CALL 0x669
1FD3  319E     MOVLP 0x1E
1FD4  27D7     CALL 0x7D7
1FD5  00EE     MOVWF TimeOutFrame_1_5
56:            }
1FD6  0008     RETURN
57:            
58:            UINT8 error_ad(UINT16 adres_reg_mask, UINT8 Modif, UINT8 Number_reg, UINT16 * ad) {
59:                HDR_Space *ad_current = Space;
60:                UINT8 cnt_i = 0;
06D8  01AD     CLRF cnt_i
61:                for (ad_current = Space; ad_current < (Space + sizeof (Space) / sizeof (HDR_Space)); ad_current++)
06D7  300C     MOVLW 0xC
06D9  00B0     MOVWF ad_current
06DA  3023     MOVLW 0x23
06DB  00B1     MOVWF 0x31
06DF  07B0     ADDWF ad_current, F
06E0  1803     BTFSC STATUS, 0x0
06E1  0AB1     INCF 0x31, F
06E2  3023     MOVLW 0x23
06E3  0231     SUBWF 0x31, W
06E4  308E     MOVLW 0x8E
06E5  1903     BTFSC STATUS, 0x2
06E6  0230     SUBWF ad_current, W
06E7  1803     BTFSC STATUS, 0x0
06E8  2EFA     GOTO 0x6FA
62:                {
63:                    if (adres_reg_mask == ad_current->adress)
06E9  0830     MOVF ad_current, W
06EA  0086     MOVWF FSR1
06EB  0831     MOVF 0x31, W
06EC  272E     CALL 0x72E
06ED  3185     MOVLP 0x5
06EE  1D03     BTFSS STATUS, 0x2
06EF  2EDD     GOTO 0x6DD
64:                    {
65:                        *ad = cnt_i;
06F0  082D     MOVF cnt_i, W
06F1  00AB     MOVWF eep_add
06F2  01AC     CLRF divisor
06F3  082A     MOVF data, W
06F4  0086     MOVWF FSR1
06F5  0187     CLRF FSR1H
06F6  082B     MOVF eep_add, W
06F7  3FC0     MOVWI 0[FSR1]
06F8  082C     MOVF divisor, W
06F9  3FC1     MOVWI 1[FSR1]
66:                        break;
06DC  2EE2     GOTO 0x6E2
67:                    }
68:                    cnt_i++;
06DD  3005     MOVLW 0x5
06DE  0AAD     INCF cnt_i, F
69:                }
70:                for (HDR_Space *ad_next = ad_current; ad_next < ad_current + Number_reg; ad_next++)
06FA  0831     MOVF 0x31, W
06FB  00AF     MOVWF sizebuff
06FC  0830     MOVF ad_current, W
06FD  00AE     MOVWF buff_read
06FE  0829     MOVF crcTx, W
06FF  274F     CALL 0x74F
0700  318D     MOVLP 0xD
0701  2587     CALL 0x587
0702  3185     MOVLP 0x5
0703  0820     MOVF __pcstackBANK0, W
0704  0730     ADDWF ad_current, W
0705  00AB     MOVWF eep_add
0706  0821     MOVF addr, W
0707  3D31     ADDWFC 0x31, W
0708  00AC     MOVWF divisor
0709  022F     SUBWF sizebuff, W
070A  1D03     BTFSS STATUS, 0x2
070B  2F0E     GOTO 0x70E
070C  082B     MOVF eep_add, W
070D  022E     SUBWF buff_read, W
070E  1803     BTFSC STATUS, 0x0
070F  3400     RETLW 0x0
0729  3005     MOVLW 0x5
71:                {
72:                    if (ad_next->modif < Modif || ad_next ->adress != adres_reg_mask || ad_next >= (Space + sizeof (Space) / sizeof (HDR_Space)))
0710  082E     MOVF buff_read, W
0711  0086     MOVWF FSR1
0712  082F     MOVF sizebuff, W
0713  0087     MOVWF FSR1H
0714  0828     MOVF add, W
0715  0201     SUBWF INDF1, W
0716  1C03     BTFSS STATUS, 0x0
0717  3401     RETLW 0x1
0718  082E     MOVF buff_read, W
0719  0086     MOVWF FSR1
071A  082F     MOVF sizebuff, W
071B  272E     CALL 0x72E
071C  3185     MOVLP 0x5
071D  1D03     BTFSS STATUS, 0x2
071E  3401     RETLW 0x1
071F  3023     MOVLW 0x23
0720  022F     SUBWF sizebuff, W
0721  308E     MOVLW 0x8E
0722  1903     BTFSC STATUS, 0x2
0723  022E     SUBWF buff_read, W
0724  1803     BTFSC STATUS, 0x0
73:            
74:                        return 1;
0725  3401     RETLW 0x1
75:                    adres_reg_mask++;
0726  0AA6     INCF index, F
0727  1903     BTFSC STATUS, 0x2
0728  0AA7     INCF byte, F
0729  3005     MOVLW 0x5
072A  07AE     ADDWF buff_read, F
072B  1803     BTFSC STATUS, 0x0
072C  0AAF     INCF sizebuff, F
072D  2EFE     GOTO 0x6FE
76:                }
77:                return 0;
78:            }
79:            
80:            void ModBusTxRxFunc() {
81:                if (TranssmitOrRecieve == Recive)
0B74  0022     MOVLB 0x2
0B75  198E     BTFSC LATC, 0x3
0B76  0008     RETURN
82:                {
83:                    UINT8 temp_Number_Rx_Byte = Number_Rx_Byte;
0B77  0876     MOVF 0x176, W
0B78  0020     MOVLB 0x0
0B79  00D4     MOVWF temp_Number_Rx_Byte
84:                    UINT8 temp_Error_Recive_1_5 = Error_Recive_1_5;
0B7A  086D     MOVF Error_Recive_1_5, W
0B7B  00D3     MOVWF temp_Error_Recive_1_5
85:                    if (temp_Number_Rx_Byte && ((TMR0 > TimeOutFrame_3_5) || TMR0IF))
0B7C  0854     MOVF temp_Number_Rx_Byte, W
0B7D  1903     BTFSC STATUS, 0x2
0B7E  0008     RETURN
0B7F  0815     MOVF TMR0, W
0B80  0279     SUBWF TimeOutFrame_3_5, W
0B81  1C03     BTFSS STATUS, 0x0
0B82  2B85     GOTO 0x385
0B83  1D0B     BTFSS INTCON, 0x2
0B84  0008     RETURN
86:                    {
87:                        //LED_RED = 0;
88:            #if 0 //вывод последних принятых запросов в ипром начиная с 80 адреса
89:                        static UINT16 index_eep = 80;
90:                        for (UINT8 index_byte = 0; index_byte < Number_Rx_Byte; index_byte++)
91:                        {
92:                            EEPROM_WRITE(index_eep + index_byte, Rx_Tx_data[index_byte]);
93:                        }
94:                        EEPROM_WRITE(index_eep + 13, TMR0);
95:                        EEPROM_WRITE(index_eep + 14, Error_Recive_1_5);
96:                        EEPROM_WRITE(index_eep + 15, Number_Rx_Byte);
97:                        index_eep += 16;
98:                        if (index_eep + 16 > 256)
99:                        {
100:                           index_eep = 80;
101:                       }
102:           #endif
103:                       if (temp_Number_Rx_Byte > 5 && !temp_Error_Recive_1_5)
0B85  3006     MOVLW 0x6
0B86  0254     SUBWF temp_Number_Rx_Byte, W
0B87  1C03     BTFSS STATUS, 0x0
0B88  2BAB     GOTO 0x3AB
0B89  0853     MOVF temp_Error_Recive_1_5, W
0B8A  1D03     BTFSS STATUS, 0x2
0B8B  2BAB     GOTO 0x3AB
104:                       {
105:                           UINT16 crcRx = crc_chk(Rx_Tx_data, temp_Number_Rx_Byte - 2);
0B8C  0854     MOVF temp_Number_Rx_Byte, W
0B8D  3EFE     ADDLW 0xFE
0B8E  00A0     MOVWF __pcstackBANK0
0B8F  303E     MOVLW 0x3E
0B90  23AF     CALL 0x3AF
0B91  3188     MOVLP 0x8
0B92  0821     MOVF addr, W
0B93  00D2     MOVWF index
0B94  0820     MOVF __pcstackBANK0, W
0B95  00D1     MOVWF crcRx
106:                           if (crcRx == (Rx_Tx_data[temp_Number_Rx_Byte - 1] << 8 | Rx_Tx_data[temp_Number_Rx_Byte - 2]))
0B96  0854     MOVF temp_Number_Rx_Byte, W
0B97  3E3C     ADDLW 0x3C
0B98  0086     MOVWF FSR1
0B99  3002     MOVLW 0x2
0B9A  0087     MOVWF FSR1H
0B9B  0854     MOVF temp_Number_Rx_Byte, W
0B9C  3E3D     ADDLW 0x3D
0B9D  0084     MOVWF FSR0
0B9E  3002     MOVLW 0x2
0B9F  0085     MOVWF FSR0H
0BA0  0852     MOVF index, W
0BA1  0600     XORWF INDF0, W
0BA2  1D03     BTFSS STATUS, 0x2
0BA3  2BA6     GOTO 0x3A6
0BA4  0851     MOVF crcRx, W
0BA5  0601     XORWF INDF1, W
0BA6  1D03     BTFSS STATUS, 0x2
0BA7  2BAB     GOTO 0x3AB
107:                           {
108:                               CREN = 0;
0BA8  0023     MOVLB 0x3
0BA9  121D     BCF RCSTA, 0x4
109:                               actCodeFunc();
0BAA  23DA     CALL 0x3DA
110:                           }
111:                       }
112:                       Number_Rx_Byte = 0;
0BAB  01F6     CLRF 0x1F6
113:                       Error_Recive_1_5 = 0;
0BAC  0020     MOVLB 0x0
0BAD  01ED     CLRF Error_Recive_1_5
114:                   }
115:               }
116:           }
0BAE  0008     RETURN
117:           
118:           void errorLogical(UINT8 codeError) {
0C00  0020     MOVLB 0x0
0C01  00A8     MOVWF add
119:           
120:               Rx_Tx_data[1] = 0b10000000 | Rx_Tx_data[1]; //код функции свид. об ошибке
0C02  0024     MOVLB 0x4
0C03  083F     MOVF 0x23F, W
0C04  3880     IORLW 0x80
0C05  00BF     MOVWF 0x23F
121:               Rx_Tx_data[2] = codeError; //код ошибки
0C06  0020     MOVLB 0x0
0C07  0828     MOVF add, W
0C08  0024     MOVLB 0x4
0C09  00C0     MOVWF 0x240
122:               UINT16 crcTx = crc_chk(Rx_Tx_data, 3);
0C0A  3003     MOVLW 0x3
0C0B  0020     MOVLB 0x0
0C0C  00A0     MOVWF __pcstackBANK0
0C0D  303E     MOVLW 0x3E
0C0E  23AF     CALL 0x3AF
0C0F  0821     MOVF addr, W
0C10  00AA     MOVWF data
0C11  0820     MOVF __pcstackBANK0, W
0C12  00A9     MOVWF crcTx
123:               Rx_Tx_data[3] = crcTx; //младший байт контрольной суммы
0C13  0024     MOVLB 0x4
0C14  00C1     MOVWF 0x241
124:               Rx_Tx_data[4] = crcTx >> 8; //старший байт контрольной суммы
0C15  0020     MOVLB 0x0
0C16  082A     MOVF data, W
0C17  0024     MOVLB 0x4
0C18  00C2     MOVWF 0x242
125:               size_Tx_frame = 5;
0C19  3005     MOVLW 0x5
0C1A  00F7     MOVWF 0x277
126:           }
0C1B  0008     RETURN
127:           
128:           void actCF_write_some() {
129:           #define MSB_adress_write 2
130:           #define LSB_adress_write 3
131:           #define MSB_Number_reg_write 4
132:           #define LSB_Number_reg_write 5
133:               UINT16 adressReg_wr = (Rx_Tx_data[MSB_adress_write] << 8) | Rx_Tx_data[LSB_adress_write];
05FF  0024     MOVLB 0x4
0600  0840     MOVF 0x240, W
0601  0020     MOVLB 0x0
0602  00BE     MOVWF shift_pos
0603  0024     MOVLB 0x4
0604  0841     MOVF 0x241, W
0605  0020     MOVLB 0x0
0606  00BD     MOVWF adressReg_wr
134:               UINT16 Number_reg_wr = (Rx_Tx_data[MSB_Number_reg_write] << 8) | Rx_Tx_data[LSB_Number_reg_write];
0607  0024     MOVLB 0x4
0608  0842     MOVF 0x242, W
0609  0020     MOVLB 0x0
060A  00B8     MOVWF 0x38
060B  0024     MOVLB 0x4
060C  0843     MOVF 0x243, W
060D  0020     MOVLB 0x0
060E  00B7     MOVWF Number_reg_wr
135:               UINT8 i = 0;
136:               UINT8 shift_pos = 0;
060F  01BB     CLRF flag_read
137:               UINT8 error_adr = error_ad(adressReg_wr, 1, Number_reg_wr, &adressReg_wr);
0610  083E     MOVF shift_pos, W
0611  00A7     MOVWF byte
0612  083D     MOVF adressReg_wr, W
0613  00A6     MOVWF index
0614  01A8     CLRF add
0615  0AA8     INCF add, F
0616  0837     MOVF Number_reg_wr, W
0617  00A9     MOVWF crcTx
0618  303D     MOVLW 0x3D
0619  00AA     MOVWF data
061A  26D7     CALL 0x6D7
061B  3185     MOVLP 0x5
061C  00B6     MOVWF error_adr
138:               if (!error_adr)
061D  0836     MOVF error_adr, W
061E  1D03     BTFSS STATUS, 0x2
061F  2E66     GOTO 0x666
139:               {
140:                   for (i = adressReg_wr; i < (adressReg_wr + Number_reg_wr); i++)
0620  083D     MOVF adressReg_wr, W
0621  00BC     MOVWF i
0622  0837     MOVF Number_reg_wr, W
0623  073D     ADDWF adressReg_wr, W
0624  00B2     MOVWF wr_rd
0625  0838     MOVF 0x38, W
0626  3D3E     ADDWFC shift_pos, W
0627  00B3     MOVWF command
0628  083C     MOVF i, W
0629  00B4     MOVWF error_adr
062A  01B5     CLRF adressReg_wr
062B  0833     MOVF command, W
062C  0235     SUBWF adressReg_wr, W
062D  1D03     BTFSS STATUS, 0x2
062E  2E31     GOTO 0x631
062F  0832     MOVF wr_rd, W
0630  0234     SUBWF error_adr, W
0631  1803     BTFSC STATUS, 0x0
0632  2E54     GOTO 0x654
0652  0ABC     INCF i, F
0653  2E22     GOTO 0x622
141:                   {
142:                       Space[i].data = (Rx_Tx_data[7 + shift_pos] << 8) | Rx_Tx_data[8 + shift_pos];
0633  083B     MOVF flag_read, W
0634  3E45     ADDLW 0x45
0635  0084     MOVWF FSR0
0636  3002     MOVLW 0x2
0637  0085     MOVWF FSR0H
0638  0800     MOVF INDF0, W
0639  00B2     MOVWF wr_rd
063A  083B     MOVF flag_read, W
063B  3E46     ADDLW 0x46
063C  0084     MOVWF FSR0
063D  083C     MOVF i, W
063E  274F     CALL 0x74F
063F  318D     MOVLP 0xD
0640  2587     CALL 0x587
0641  3185     MOVLP 0x5
0642  300F     MOVLW 0xF
0643  00B3     MOVWF command
0644  3023     MOVLW 0x23
0645  00B4     MOVWF error_adr
0646  0820     MOVF __pcstackBANK0, W
0647  0733     ADDWF command, W
0648  0086     MOVWF FSR1
0649  0821     MOVF addr, W
064A  3D34     ADDWFC error_adr, W
064B  0087     MOVWF FSR1H
064C  0800     MOVF INDF0, W
064D  3FC0     MOVWI 0[FSR1]
064E  0832     MOVF wr_rd, W
064F  3FC1     MOVWI 1[FSR1]
143:                       shift_pos += 2;
0650  0ABB     INCF flag_read, F
0651  0ABB     INCF flag_read, F
144:                   }
145:                   UINT16 crcTx = crc_chk(Rx_Tx_data, 6);
0654  3006     MOVLW 0x6
0655  00A0     MOVWF __pcstackBANK0
0656  303E     MOVLW 0x3E
0657  318B     MOVLP 0xB
0658  23AF     CALL 0x3AF
0659  0821     MOVF addr, W
065A  00BA     MOVWF S_Number
065B  0820     MOVF __pcstackBANK0, W
065C  00B9     MOVWF crcTx
146:                   Rx_Tx_data[6] = crcTx; //младший байт контрольной суммы
065D  0024     MOVLB 0x4
065E  00C4     MOVWF 0x244
147:                   Rx_Tx_data[7] = crcTx >> 8; //старший байт контрольной суммы
065F  0020     MOVLB 0x0
0660  083A     MOVF S_Number, W
0661  0024     MOVLB 0x4
0662  00C5     MOVWF 0x245
148:                   size_Tx_frame = 8;
0663  3008     MOVLW 0x8
0664  00F7     MOVWF 0x277
149:               } else
0665  0008     RETURN
150:                   errorLogical(0x02); //ошибка адреса
0666  3002     MOVLW 0x2
0667  318C     MOVLP 0xC
0668  2C00     GOTO 0x400
151:           }
152:           
153:           void actCF_write() {
154:           #define MSB_adress_write 2
155:           #define LSB_adress_write 3
156:           #define MSB_write 4
157:           #define LSB_write 5
158:               UINT16 adressReg_wr = (Rx_Tx_data[MSB_adress_write] << 8) | Rx_Tx_data[LSB_adress_write];
0C1C  0024     MOVLB 0x4
0C1D  0840     MOVF 0x240, W
0C1E  0020     MOVLB 0x0
0C1F  00B6     MOVWF error_adr
0C20  0024     MOVLB 0x4
0C21  0841     MOVF 0x241, W
0C22  0020     MOVLB 0x0
0C23  00B5     MOVWF adressReg_wr
159:               UINT8 error_adr = error_ad(adressReg_wr, 1, 1, &adressReg_wr);
0C24  0836     MOVF error_adr, W
0C25  00A7     MOVWF byte
0C26  0835     MOVF adressReg_wr, W
0C27  00A6     MOVWF index
0C28  3035     MOVLW 0x35
0C29  01A8     CLRF add
0C2A  0AA8     INCF add, F
0C2B  01A9     CLRF crcTx
0C2C  0AA9     INCF crcTx, F
0C2D  00AA     MOVWF data
0C2E  3186     MOVLP 0x6
0C2F  26D7     CALL 0x6D7
0C30  3188     MOVLP 0x8
0C31  00B4     MOVWF error_adr
160:               if (!error_adr)
0C32  0834     MOVF error_adr, W
0C33  1D03     BTFSS STATUS, 0x2
0C34  2C4F     GOTO 0x44F
161:               {
162:                   Space[adressReg_wr].data = (Rx_Tx_data[MSB_write] << 8) | Rx_Tx_data[LSB_write];
0C35  0836     MOVF error_adr, W
0C36  00A1     MOVWF addr
0C37  0835     MOVF adressReg_wr, W
0C38  00A0     MOVWF __pcstackBANK0
0C39  3005     MOVLW 0x5
0C3A  00A2     MOVWF multiplicand
0C3B  01A3     CLRF size_Tx
0C3C  2587     CALL 0x587
0C3D  300F     MOVLW 0xF
0C3E  00B2     MOVWF wr_rd
0C3F  3023     MOVLW 0x23
0C40  00B3     MOVWF command
0C41  0820     MOVF __pcstackBANK0, W
0C42  0732     ADDWF wr_rd, W
0C43  0086     MOVWF FSR1
0C44  0821     MOVF addr, W
0C45  3D33     ADDWFC command, W
0C46  0087     MOVWF FSR1H
0C47  0024     MOVLB 0x4
0C48  0843     MOVF 0x243, W
0C49  3FC0     MOVWI 0[FSR1]
0C4A  0842     MOVF 0x242, W
0C4B  3FC1     MOVWI 1[FSR1]
163:                   size_Tx_frame = 8;
0C4C  3008     MOVLW 0x8
0C4D  00F7     MOVWF 0x277
164:               } else
0C4E  0008     RETURN
165:                   errorLogical(0x02);
0C4F  3002     MOVLW 0x2
0C50  2C00     GOTO 0x400
166:           }
167:           
168:           void actCF_read_some() {
169:           #define MSB_adress_read 2
170:           #define LSB_adress_read 3
171:           #define MSB_Number_reg_read 4
172:           #define LSB_Number_reg_read 5
173:               UINT16 adressReg_read = (Rx_Tx_data[MSB_adress_read] << 8) | Rx_Tx_data[LSB_adress_read];
0669  0024     MOVLB 0x4
066A  0840     MOVF 0x240, W
066B  0020     MOVLB 0x0
066C  00BD     MOVWF adressReg_wr
066D  0024     MOVLB 0x4
066E  0841     MOVF 0x241, W
066F  0020     MOVLB 0x0
0670  00BC     MOVWF i
174:               UINT16 Number_reg_read = (Rx_Tx_data[MSB_Number_reg_read] << 8) | Rx_Tx_data[LSB_Number_reg_read];
0671  0024     MOVLB 0x4
0672  0842     MOVF 0x242, W
0673  0020     MOVLB 0x0
0674  00BA     MOVWF S_Number
0675  0024     MOVLB 0x4
0676  0843     MOVF 0x243, W
0677  0020     MOVLB 0x0
0678  00B9     MOVWF crcTx
175:               Rx_Tx_data[2] = 2 * Number_reg_read; //число читаемых байт данных
0679  3539     LSLF crcTx, W
067A  0024     MOVLB 0x4
067B  00C0     MOVWF 0x240
176:               UINT8 i = 0;
177:               UINT8 shift_pos = 0;
067C  0020     MOVLB 0x0
067D  01BE     CLRF shift_pos
178:               UINT8 error_adr = error_ad(adressReg_read, 0, Number_reg_read, &adressReg_read);
067E  083D     MOVF adressReg_wr, W
067F  00A7     MOVWF byte
0680  083C     MOVF i, W
0681  00A6     MOVWF index
0682  01A8     CLRF add
0683  0839     MOVF crcTx, W
0684  00A9     MOVWF crcTx
0685  303C     MOVLW 0x3C
0686  00AA     MOVWF data
0687  26D7     CALL 0x6D7
0688  3185     MOVLP 0x5
0689  00B6     MOVWF error_adr
179:               if (!error_adr)
068A  0836     MOVF error_adr, W
068B  1D03     BTFSS STATUS, 0x2
068C  2ED4     GOTO 0x6D4
180:               {
181:                   for (i = adressReg_read; i < (adressReg_read + Number_reg_read); i++)
068D  083C     MOVF i, W
068E  00BB     MOVWF flag_read
068F  0839     MOVF crcTx, W
0690  073C     ADDWF i, W
0691  00B2     MOVWF wr_rd
0692  083A     MOVF S_Number, W
0693  3D3D     ADDWFC adressReg_wr, W
0694  00B3     MOVWF command
0695  083B     MOVF flag_read, W
0696  00B4     MOVWF error_adr
0697  01B5     CLRF adressReg_wr
0698  0833     MOVF command, W
0699  0235     SUBWF adressReg_wr, W
069A  1D03     BTFSS STATUS, 0x2
069B  2E9E     GOTO 0x69E
069C  0832     MOVF wr_rd, W
069D  0234     SUBWF error_adr, W
069F  1803     BTFSC STATUS, 0x0
06A0  2EBB     GOTO 0x6BB
06B9  0ABB     INCF flag_read, F
06BA  2E8F     GOTO 0x68F
182:                   {
183:                       Rx_Tx_data[3 + shift_pos] = Space[i].data >> 8; //старший байт данных
069E  083E     MOVF shift_pos, W
06A1  3E41     ADDLW 0x41
06A2  2745     CALL 0x745
06A3  318D     MOVLP 0xD
06A4  2587     CALL 0x587
06A5  3185     MOVLP 0x5
06A6  273A     CALL 0x73A
06A7  3185     MOVLP 0x5
06A8  3F00     MOVIW 0[FSR0]
06A9  00B4     MOVWF error_adr
06AA  3F01     MOVIW 1[FSR0]
06AB  00B5     MOVWF adressReg_wr
06AC  0081     MOVWF INDF1
184:                       Rx_Tx_data[4 + shift_pos] = Space[i].data; //младший байт данных
06AD  083E     MOVF shift_pos, W
06AE  3E42     ADDLW 0x42
06AF  2745     CALL 0x745
06B0  318D     MOVLP 0xD
06B1  2587     CALL 0x587
06B2  3185     MOVLP 0x5
06B3  273A     CALL 0x73A
06B4  3185     MOVLP 0x5
06B5  0800     MOVF INDF0, W
06B6  0081     MOVWF INDF1
185:                       shift_pos += 2;
06B7  0ABE     INCF shift_pos, F
06B8  0ABE     INCF shift_pos, F
186:                   }
187:                   UINT16 crcTx = crc_chk(Rx_Tx_data, 3 + shift_pos);
06BB  3E03     ADDLW 0x3
06BC  00A0     MOVWF __pcstackBANK0
06BD  303E     MOVLW 0x3E
06BE  318B     MOVLP 0xB
06BF  23AF     CALL 0x3AF
06C0  0821     MOVF addr, W
06C1  00B8     MOVWF 0x38
06C2  0820     MOVF __pcstackBANK0, W
06C3  00B7     MOVWF Number_reg_wr
188:                   Rx_Tx_data[3 + shift_pos] = crcTx; //младший байт контрольной суммы
06C4  083E     MOVF shift_pos, W
06C5  3E41     ADDLW 0x41
06C6  0086     MOVWF FSR1
06C7  3002     MOVLW 0x2
06C8  0087     MOVWF FSR1H
06C9  0837     MOVF Number_reg_wr, W
06CA  0081     MOVWF INDF1
189:                   Rx_Tx_data[4 + shift_pos] = crcTx >> 8; //старший байт контрольной суммы
06CB  083E     MOVF shift_pos, W
06CC  3E42     ADDLW 0x42
06CD  0086     MOVWF FSR1
06CE  0838     MOVF 0x38, W
06CF  0081     MOVWF INDF1
190:                   size_Tx_frame = 5 + shift_pos;
06D0  083E     MOVF shift_pos, W
06D1  3E05     ADDLW 0x5
06D2  00F7     MOVWF size_Tx_frame
191:               } else
06D3  0008     RETURN
192:                   errorLogical(0x02); //ошибка адреса
06D4  3002     MOVLW 0x2
06D5  318C     MOVLP 0xC
06D6  2C00     GOTO 0x400
193:           }
194:           
195:           void CalculTX9Dbit() {
196:               UINT8 cntTB = 0;
0E6D  0020     MOVLB 0x0
0E6E  01A3     CLRF size_Tx
197:               while (cntTB < size_Tx_frame)
0E6F  0877     MOVF size_Tx_frame, W
0E70  0223     SUBWF size_Tx, W
0E71  1803     BTFSC STATUS, 0x0
0E72  0008     RETURN
0E92  2E6F     GOTO 0x66F
198:               {
199:                   UINT8 cntBit = 0;
0E73  01A2     CLRF multiplicand
200:                   UINT8 TempResult = Rx_Tx_data[cntTB] & 1;
0E74  2736     CALL 0x736
0E75  3188     MOVLP 0x8
0E76  00A1     MOVWF addr
0E77  3001     MOVLW 0x1
0E78  05A1     ANDWF addr, F
201:                   while (cntBit < 7)
0E79  3007     MOVLW 0x7
0E7A  0222     SUBWF multiplicand, W
0E7B  1803     BTFSC STATUS, 0x0
0E7C  2E8A     GOTO 0x68A
0E89  2E79     GOTO 0x679
202:                   {
203:           
204:                       cntBit++;
0E7D  0AA2     INCF multiplicand, F
0E7E  2736     CALL 0x736
0E7F  3188     MOVLP 0x8
205:                       TempResult ^= (Rx_Tx_data[cntTB] >> cntBit & 1);
0E80  00A0     MOVWF __pcstackBANK0
0E81  0A22     INCF multiplicand, W
0E82  2E84     GOTO 0x684
0E83  36A0     LSRF __pcstackBANK0, F
0E84  0B89     DECFSZ WREG, F
0E85  2E83     GOTO 0x683
0E86  0820     MOVF __pcstackBANK0, W
0E87  3901     ANDLW 0x1
0E88  06A1     XORWF addr, F
206:                   }
207:                   TX9Dbit[cntTB] = TempResult;
0E8A  0823     MOVF size_Tx, W
0E8B  3ECA     ADDLW 0xCA
0E8C  0086     MOVWF FSR1
0E8D  3002     MOVLW 0x2
0E8E  0087     MOVWF FSR1H
0E8F  0821     MOVF addr, W
0E90  0081     MOVWF INDF1
208:                   cntTB++;
0E91  0AA3     INCF size_Tx, F
0E92  2E6F     GOTO 0x66F
209:               }
210:           }
0004  147E     BSF 0x7E, 0x0
0005  3180     MOVLP 0x0
211:           
212:           void actCodeFunc() {
213:               switch (Rx_Tx_data[1]) //код функции
0BDA  2BED     GOTO 0x3ED
0BED  0024     MOVLB 0x4
0BEE  083F     MOVF 0x23F, W
0BEF  3A03     XORLW 0x3
0BF0  1903     BTFSC STATUS, 0x2
0BF1  2BDB     GOTO 0x3DB
0BF2  3A05     XORLW 0x5
0BF3  1903     BTFSC STATUS, 0x2
0BF4  2BE2     GOTO 0x3E2
0BF5  3A16     XORLW 0x16
0BF6  1903     BTFSC STATUS, 0x2
0BF7  2BE5     GOTO 0x3E5
0BF8  2BE9     GOTO 0x3E9
214:               {
215:                   case CF_read_some:
216:                       exchange_chip();
0BDB  3180     MOVLP 0x0
0BDC  20C8     CALL 0xC8
0BDD  3188     MOVLP 0x8
217:                       actCF_read_some();
0BDE  3186     MOVLP 0x6
0BDF  2669     CALL 0x669
0BE0  3188     MOVLP 0x8
218:                       break;
0BE1  2BF9     GOTO 0x3F9
219:                   case CF_write:
220:                       actCF_write();
0BE2  241C     CALL 0x41C
0BE3  3188     MOVLP 0x8
221:                       break;
0BE4  2BF9     GOTO 0x3F9
222:                   case CF_write_some:
223:                       actCF_write_some();
0BE5  3185     MOVLP 0x5
0BE6  25FF     CALL 0x5FF
0BE7  3188     MOVLP 0x8
224:                       break;
0BE8  2BF9     GOTO 0x3F9
225:                   default:
226:                       errorLogical(0x01); //ошибка функции
0BE9  3001     MOVLW 0x1
0BEA  2400     CALL 0x400
0BEB  3188     MOVLP 0x8
227:                       break;
0BEC  2BF9     GOTO 0x3F9
228:               }
229:               Number_Tx_Byte = 0;
0BF9  01F8     CLRF 0x278
230:               CalculTX9Dbit();
0BFA  266D     CALL 0x66D
231:               TranssmitOrRecieve = Transsmit;
0BFB  0022     MOVLB 0x2
0BFC  158E     BSF LATC, 0x3
232:               //LED_BLUE = 1;
233:               TXIE = 1;
0BFD  0021     MOVLB 0x1
0BFE  1611     BSF PIE1, 0x4
234:           }
0BFF  0008     RETURN
235:           
236:           UINT16 crc_chk(UINT8* byte, UINT8 length) {
0BAF  00A7     MOVWF 0xA7
237:               UINT8 j;
238:               UINT16 reg_crc = 0xFFFF;
0BB0  30FF     MOVLW 0xFF
0BB1  00A5     MOVWF 0xA5
0BB2  00A6     MOVWF 0xA6
239:               while (length--)
0BB3  2BD2     GOTO 0x3D2
0BD2  03A0     DECF __pcstackBANK1, F
0BD3  0F20     INCFSZ __pcstackBANK1, W
0BD4  2BB4     GOTO 0x3B4
240:               {
241:                   reg_crc ^= *byte++;
0BB4  0827     MOVF 0xA7, W
0BB5  0086     MOVWF FSR1L
0BB6  3002     MOVLW 0x2
0BB7  0087     MOVWF FSR1H
0BB8  0801     MOVF INDF1, W
0BB9  06A5     XORWF 0xA5, F
0BBA  0AA7     INCF 0xA7, F
242:                   for (j = 0; j < 8; j++)
0BBB  01A4     CLRF 0xA4
0BCD  3008     MOVLW 0x8
0BCE  0AA4     INCF 0xA4, F
0BCF  0224     SUBWF 0xA4, W
0BD0  1C03     BTFSS STATUS, 0x0
0BD1  2BBC     GOTO 0x3BC
243:                   {
244:                       if (reg_crc & 0x01)
0BBC  1C25     BTFSS 0xA5, 0x0
0BBD  2BCB     GOTO 0x3CB
245:                           reg_crc = (reg_crc >> 1) ^ 0xA001; // LSB(b0)=1
0BBE  0826     MOVF 0xA6, W
0BBF  00A3     MOVWF 0xA3
0BC0  0825     MOVF 0xA5, W
0BC1  00A2     MOVWF 0xA2
0BC2  3001     MOVLW 0x1
0BC3  36A3     LSRF 0xA3, F
0BC4  0CA2     RRF 0xA2, F
0BC5  0622     XORWF 0xA2, W
0BC6  00A5     MOVWF 0xA5
0BC7  30A0     MOVLW 0xA0
0BC8  0623     XORWF 0xA3, W
0BC9  00A6     MOVWF 0xA6
0BCA  2BCD     GOTO 0x3CD
246:           
247:                       else
248:                           reg_crc = reg_crc >> 1;
0BCB  36A6     LSRF 0xA6, F
0BCC  0CA5     RRF 0xA5, F
249:                   }
250:               }
251:               return reg_crc;
0BD5  0826     MOVF 0xA6, W
0BD6  00A1     MOVWF 0xA1
0BD7  0825     MOVF 0xA5, W
0BD8  00A0     MOVWF __pcstackBANK1
252:           }
0BD9  0008     RETURN
253:           
254:           
255:           
256:           
---  C:/work_Git/VAR_C_NEW/VAR_C_NEW.X/Chip.c  ----------------------------------------------------------
1:             #define CHIP_C_DATA
2:             #include "Chip.h"
3:             
4:             flags_t flags = {0};
5:             INT32 reg_chip[number_read_reg] = {0};
6:             UINT8 exchange_MCP_completed = 0;
7:             
8:             void func_write_chip(UINT8 size_Tx, const UINT8 *comand)
02A9  00A3     MOVWF 0xA3
9:             {
10:                UINT8 cnt_tx_byte = 0;
02AA  01A5     CLRF 0xA5
11:                while (cnt_tx_byte < size_Tx)
02AB  0823     MOVF 0xA3, W
02AC  0225     SUBWF 0xA5, W
02AD  1803     BTFSC STATUS, 0x0
02AE  0008     RETURN
02D2  2AAB     GOTO 0x2AB
12:                {
13:                    if (TXIF)
02AF  1E11     BTFSS PIE1, 0x4
02B0  2AAB     GOTO 0x2AB
14:                    {
15:                        UINT8 bit_odd = 1;
02B1  01A4     CLRF 0xA4
02B2  0AA4     INCF 0xA4, F
16:                        for (UINT8 index = 0; index < 8; index++)
02B3  01A6     CLRF 0xA6
02BF  3008     MOVLW 0x8
02C0  0AA6     INCF 0xA6, F
02C1  0226     SUBWF 0xA6, W
02C2  1C03     BTFSS STATUS, 0x0
02C3  2AB4     GOTO 0x2B4
17:                            bit_odd ^= (comand[cnt_tx_byte] >> index) & 1;
02B4  22F8     CALL 0x2F8
02B5  3180     MOVLP 0x0
02B6  00A2     MOVWF 0xA2
02B7  0A26     INCF 0xA6, W
02B8  2ABA     GOTO 0x2BA
02B9  36A2     LSRF 0xA2, F
02BA  0B89     DECFSZ WREG, F
02BB  2AB9     GOTO 0x2B9
02BC  0822     MOVF 0xA2, W
02BD  3901     ANDLW 0x1
02BE  06A4     XORWF 0xA4, F
18:                        //__delay_us(100 + DELAY_WRITE_BYTE_MCP_MKS);
19:                        TX9D = bit_odd;
02C4  1C24     BTFSS 0xA4, 0x0
02C5  2AC9     GOTO 0x2C9
02C6  0023     MOVLB 0x3
02C7  141E     BSF TXSTA, 0x0
02C8  2ACB     GOTO 0x2CB
02C9  0023     MOVLB 0x3
02CA  101E     BCF TXSTA, 0x0
20:                        TXREG = comand[cnt_tx_byte++];
02CB  0020     MOVLB 0x0
02CC  22F8     CALL 0x2F8
02CD  3180     MOVLP 0x0
02CE  0023     MOVLB 0x3
02CF  009A     MOVWF TXREG
02D0  0020     MOVLB 0x0
02D1  0AA5     INCF flag_read, F
02D2  2AAB     GOTO 0x2AB
21:                    }
22:                }
23:            }
24:            
25:            flag_read_t func_read_chip(UINT8 size_Buff, UINT8 *Buff)
0268  00A4     MOVWF size_Buff
26:            {
27:                RCIE = 0;
0269  0021     MOVLB 0x1
026A  1291     BCF PIE1, 0x5
28:                CREN = 1;
026B  0023     MOVLB 0x3
026C  161D     BSF RCSTA, 0x4
29:                flag_read_t flag_read = {0};
026D  0856     MOVF F3171, W
026E  0020     MOVLB 0x0
026F  00A5     MOVWF flag_read
0270  0023     MOVLB 0x3
0271  0857     MOVF 0x1D7, W
0272  0020     MOVLB 0x0
0273  00A6     MOVWF index
0274  0023     MOVLB 0x3
0275  0858     MOVF 0x1D8, W
0276  0020     MOVLB 0x0
0277  00A7     MOVWF byte
30:                while (!flag_read.cnt_rx_byte || TMR0 < ((UINT32) TIMEOUT_STOPRECIVE_BIT * 1000000 / ((UINT32) SPEED_MCP39F511 * PERIOD_TRM0_MKS) + 1))
0278  0020     MOVLB 0x0
0279  0825     MOVF flag_read, W
027A  1D03     BTFSS STATUS, 0x2
027B  2A99     GOTO 0x299
0298  2A78     GOTO 0x278
0299  3037     MOVLW 0x37
029A  0215     SUBWF TMR0, W
029B  1C03     BTFSS STATUS, 0x0
029C  2A7C     GOTO 0x27C
31:                {
32:                    if (RCIF)
027C  1E91     BTFSS PIR1, 0x5
027D  2A78     GOTO 0x278
33:                    {
34:                        TMR0 = 0;
027E  0195     CLRF TMR0
35:                        if (flag_read.cnt_rx_byte != size_Buff)
027F  0825     MOVF flag_read, W
0280  0624     XORWF size_Buff, W
0281  1903     BTFSC STATUS, 0x2
0282  2A91     GOTO 0x291
36:                        {
37:                            if (FERR)
0283  0023     MOVLB 0x3
0284  1D1D     BTFSS RCSTA, 0x2
0285  2A88     GOTO 0x288
38:                                flag_read.framing_error = 1;
0286  0020     MOVLB 0x0
0287  1427     BSF byte, 0x0
39:                            Buff[flag_read.cnt_rx_byte++] = RCREG;
0288  0020     MOVLB 0x0
0289  0825     MOVF flag_read, W
028A  0720     ADDWF __pcstackBANK0, W
028B  00A3     MOVWF size_Tx
028C  22FF     CALL 0x2FF
028D  3180     MOVLP 0x0
028E  0020     MOVLB 0x0
028F  0AA5     INCF flag_read, F
40:                        } else
0290  2A78     GOTO 0x278
41:                        {
42:                            flag_read.buff_overflow = 1;
0291  14A7     BSF byte, 0x1
43:                            Buff[flag_read.cnt_rx_byte - 1] = RCREG;
0292  0825     MOVF flag_read, W
0293  0720     ADDWF __pcstackBANK0, W
0294  00A3     MOVWF size_Tx
0295  3EFF     ADDLW 0xFF
0296  22FF     CALL 0x2FF
0297  3180     MOVLP 0x0
44:                        }
45:                    }
46:                }
47:                CREN = 0;
029D  0023     MOVLB 0x3
029E  121D     BCF RCSTA, 0x4
48:                RCIE = 1;
029F  0021     MOVLB 0x1
02A0  1691     BSF PIE1, 0x5
49:                return flag_read;
02A1  0020     MOVLB 0x0
02A2  0825     MOVF flag_read, W
02A3  00A0     MOVWF __pcstackBANK0
02A4  0826     MOVF index, W
02A5  00A1     MOVWF addr
02A6  0827     MOVF byte, W
02A7  00A2     MOVWF multiplicand
50:            }
02A8  0008     RETURN
51:            
52:            UINT8 calcul_checksum_chip(UINT8 size, UINT8 *comand)
0220  00A3     MOVWF size_Tx
53:            {
54:                UINT8 temp_sum = 0;
0221  01A4     CLRF size_Buff
55:                for (UINT8 index = 0; index < size - 1; index++)
0222  01A5     CLRF flag_read
0223  0823     MOVF size_Tx, W
0224  3EFF     ADDLW 0xFF
0225  00A1     MOVWF addr
0226  30FF     MOVLW 0xFF
0227  1803     BTFSC STATUS, 0x0
0228  3000     MOVLW 0x0
0229  00A2     MOVWF multiplicand
022A  3A80     XORLW 0x80
022B  3C80     SUBLW 0x80
022C  1D03     BTFSS STATUS, 0x2
022D  2A30     GOTO 0x230
022E  0821     MOVF addr, W
022F  0225     SUBWF flag_read, W
0230  1803     BTFSC STATUS, 0x0
0231  2A3C     GOTO 0x23C
023A  0AA5     INCF flag_read, F
023B  2A23     GOTO 0x223
56:                    temp_sum += comand[index];
0232  0020     MOVLB 0x0
0233  0825     MOVF flag_read, W
0234  0720     ADDWF __pcstackBANK0, W
0235  00A1     MOVWF addr
0236  0086     MOVWF FSR1
0237  0187     CLRF FSR1H
0238  0801     MOVF INDF1, W
0239  07A4     ADDWF size_Buff, F
57:                temp_sum = ~temp_sum;
023C  30FF     MOVLW 0xFF
023D  0020     MOVLB 0x0
023E  06A4     XORWF size_Buff, F
58:                temp_sum += 0x33;
023F  3033     MOVLW 0x33
0240  07A4     ADDWF size_Buff, F
59:                return temp_sum;
0241  0824     MOVF size_Buff, W
60:            }
0242  0008     RETURN
61:            
62:            flag_read_t wtite_reg_chip(UINT8 wr_rd, UINT16 add, UINT32 data, UINT8* buff_read, UINT8 sizebuff)
01C7  00B2     MOVWF wr_rd
63:            {
64:                flag_read_t flag_read = {0};
08B5  307D     MOVLW 0x7D
65:                UINT8 command[8] = {0b01111101};
01C8  3068     MOVLW 0x68
01C9  0086     MOVWF FSR1
01CA  3002     MOVLW 0x2
01CB  0087     MOVWF FSR1H
01CC  3033     MOVLW 0x33
01CD  0084     MOVWF FSR0
01CE  3000     MOVLW 0x0
01CF  0085     MOVWF FSR0H
01D0  3008     MOVLW 0x8
01D1  00B0     MOVWF ad_current
01D2  0016     MOVIW FSR1++
01D3  001A     MOVWI FSR0++
01D4  0BB0     DECFSZ ad_current, F
01D5  29D2     GOTO 0x1D2
66:                command[1] = ((add >> 4) & 0b11110000) | wr_rd;
01D6  0829     MOVF crcTx, W
01D7  00B1     MOVWF 0x31
01D8  0828     MOVF add, W
01D9  00B0     MOVWF ad_current
01DA  3004     MOVLW 0x4
01DB  36B1     LSRF 0x31, F
01DC  0CB0     RRF ad_current, F
01DD  0B89     DECFSZ WREG, F
01DE  29DB     GOTO 0x1DB
01DF  0830     MOVF ad_current, W
01E0  39F0     ANDLW 0xF0
01E1  0432     IORWF wr_rd, W
01E2  00B4     MOVWF error_adr
67:                command[2] = add;
01E3  0828     MOVF add, W
01E4  00B5     MOVWF adressReg_wr
68:                command[3] = GET_BYTE(0, data);
01E5  082A     MOVF data, W
01E6  00B6     MOVWF error_adr
69:                command[4] = GET_BYTE(1, data);
01E7  082B     MOVF eep_add, W
01E8  00B7     MOVWF Number_reg_wr
70:                command[5] = GET_BYTE(2, data);
01E9  082C     MOVF divisor, W
01EA  00B8     MOVWF 0x38
71:                command[6] = GET_BYTE(3, data);
01EB  082D     MOVF cnt_i, W
01EC  00B9     MOVWF crcTx
72:                command[7] = calcul_checksum_chip(sizeof (command), command);
01ED  3033     MOVLW 0x33
01EE  00A0     MOVWF __pcstackBANK0
01EF  3008     MOVLW 0x8
01F0  2220     CALL 0x220
01F1  3180     MOVLP 0x0
01F2  00BA     MOVWF S_Number
73:                func_write_chip(sizeof (command), command);
01F3  3033     MOVLW 0x33
01F4  00A0     MOVWF __pcstackBANK0
01F5  3008     MOVLW 0x8
01F6  22A9     CALL 0x2A9
01F7  3180     MOVLP 0x0
74:                while (!TRMT);
01F8  0023     MOVLB 0x3
01F9  1C9E     BTFSS TXSTA, 0x1
01FA  29F8     GOTO 0x1F8
75:                flag_read = func_read_chip(sizebuff, buff_read);
01FB  0020     MOVLB 0x0
01FC  082E     MOVF buff_read, W
01FD  00A0     MOVWF __pcstackBANK0
01FE  082F     MOVF sizebuff, W
01FF  2268     CALL 0x268
0200  3180     MOVLP 0x0
0201  0820     MOVF __pcstackBANK0, W
0202  00BB     MOVWF flag_read
0203  0821     MOVF addr, W
0204  00BC     MOVWF i
0205  0822     MOVF multiplicand, W
0206  00BD     MOVWF adressReg_wr
76:                if (calcul_checksum_chip(flag_read.cnt_rx_byte, buff_read) != buff_read[flag_read.cnt_rx_byte - 1])
0207  083B     MOVF flag_read, W
0208  072E     ADDWF buff_read, W
0209  00B0     MOVWF ad_current
020A  3EFF     ADDLW 0xFF
020B  0084     MOVWF FSR0
020C  0185     CLRF FSR0H
020D  082E     MOVF buff_read, W
020E  00A0     MOVWF __pcstackBANK0
020F  083B     MOVF flag_read, W
0210  2220     CALL 0x220
0211  3180     MOVLP 0x0
0212  0600     XORWF INDF0, W
0213  1903     BTFSC STATUS, 0x2
0214  2A19     GOTO 0x219
77:                {
78:                    flag_read.error_crc = DEBUG_REG(3) = 1;
0215  3055     MOVLW 0x55
0216  22D3     CALL 0x2D3
0217  3001     MOVLW 0x1
0218  00BC     MOVWF i
79:                }
80:                return flag_read;
0219  083B     MOVF flag_read, W
021A  00A8     MOVWF add
021B  083C     MOVF i, W
021C  00A9     MOVWF crcTx
021D  083D     MOVF adressReg_wr, W
021E  00AA     MOVWF data
81:            }
021F  0008     RETURN
82:            
83:            void exchange_chip()
84:            {
85:                flag_read_t flag_read = {0};
86:                UINT8 buff_read[80] = {0};
00C8  30A0     MOVLW 0xA0
00C9  0086     MOVWF FSR1
00CA  3000     MOVLW 0x0
00CB  0087     MOVWF FSR1H
00CC  3050     MOVLW 0x50
00CD  0020     MOVLB 0x0
00CE  00BE     MOVWF shift_pos
00CF  3000     MOVLW 0x0
00D0  001E     MOVWI FSR1++
00D1  0BBE     DECFSZ shift_pos, F
00D2  28D0     GOTO 0xD0
87:                exchange_MCP_completed = 1;
00D3  0022     MOVLB 0x2
00D5  01E2     CLRF exchange_MCP_completed
00D6  0AE2     INCF exchange_MCP_completed, F
88:                UINT8 temp_CREN = CREN;
00D4  3000     MOVLW 0x0
00D7  0023     MOVLB 0x3
00D8  1A1D     BTFSC RCSTA, 0x4
00D9  3001     MOVLW 0x1
00DA  0020     MOVLB 0x0
00DB  00CC     MOVWF temp_CREN
89:                CREN = 0;
00DC  0023     MOVLB 0x3
00DD  121D     BCF RCSTA, 0x4
90:                //TX9 = 0;
91:                //RX9 = 0;
92:                APFCON0 = 0;
00DE  0022     MOVLB 0x2
00DF  019D     CLRF APFCON0
93:                UINT16 temp_SPBRG = SPBRG;
00E0  0023     MOVLB 0x3
00E1  081C     MOVF SPBRGH, W
00E2  0020     MOVLB 0x0
00E3  00CB     MOVWF sign
00E4  0023     MOVLB 0x3
00E5  081B     MOVF SPBRG, W
00E6  0020     MOVLB 0x0
00E7  00CA     MOVWF temp_SPBRG
94:                SPBRG = CALCUL_SPBRG(SPEED_MCP39F511);
00E8  308A     MOVLW 0x8A
00E9  0023     MOVLB 0x3
00EA  009B     MOVWF SPBRG
00EB  019C     CLRF SPBRGH
95:            
96:            #if DEBUG 
97:                if (COMMAND_REG == 504)
98:                {
99:                    flags.Calibration_key1 = 1;
100:                   COMMAND_REG = 0;
101:               }
102:           #endif
103:               if (!flags.write_const)
00EC  1867     BTFSC flags, 0x0
00ED  2934     GOTO 0x134
104:               {
105:                   wtite_reg_chip(2, 0x180, 0x28800000, buff_read, sizeof (buff_read));
00EE  3080     MOVLW 0x80
00EF  0020     MOVLB 0x0
00F0  00A8     MOVWF add
00F1  3001     MOVLW 0x1
00F2  00A9     MOVWF crcTx
00F3  3028     MOVLW 0x28
00F4  00AD     MOVWF cnt_i
00F5  3080     MOVLW 0x80
00F6  00AC     MOVWF divisor
00F7  30A0     MOVLW 0xA0
00F8  01AB     CLRF eep_add
00F9  01AA     CLRF data
00FA  00AE     MOVWF buff_read
00FB  3050     MOVLW 0x50
00FC  00AF     MOVWF sizebuff
00FD  3002     MOVLW 0x2
00FE  21C7     CALL 0x1C7
00FF  3180     MOVLP 0x0
106:                   wtite_reg_chip(2, 0x107, 0x806764B6, buff_read, sizeof (buff_read));
0100  3007     MOVLW 0x7
0101  00A8     MOVWF add
0102  3001     MOVLW 0x1
0103  00A9     MOVWF crcTx
0104  3080     MOVLW 0x80
0105  00AD     MOVWF cnt_i
0106  3067     MOVLW 0x67
0107  00AC     MOVWF divisor
0108  3064     MOVLW 0x64
0109  00AB     MOVWF eep_add
010A  30B6     MOVLW 0xB6
010B  00AA     MOVWF data
010C  22F3     CALL 0x2F3
010D  3180     MOVLP 0x0
010E  21C7     CALL 0x1C7
010F  3180     MOVLP 0x0
107:                   wtite_reg_chip(2, 0xF7, phase_correct / 5, buff_read, sizeof (buff_read));
0110  30F7     MOVLW 0xF7
0111  00A8     MOVWF add
0112  3005     MOVLW 0x5
0113  01A9     CLRF crcTx
0114  00A0     MOVWF __pcstackBANK0
0115  01A1     CLRF addr
0116  0022     MOVLB 0x2
0117  086A     MOVF 0x16A, W
0118  0020     MOVLB 0x0
0119  00A3     MOVWF size_Tx
011A  0022     MOVLB 0x2
011B  0869     MOVF phase_correct, W
011C  0020     MOVLB 0x0
011D  00A2     MOVWF multiplicand
011E  2243     CALL 0x243
011F  3180     MOVLP 0x0
0120  0820     MOVF __pcstackBANK0, W
0121  00BE     MOVWF shift_pos
0122  0821     MOVF addr, W
0123  00BF     MOVWF 0x3F
0124  01C0     CLRF index
0125  01C1     CLRF index
0126  0841     MOVF index, W
0127  00AD     MOVWF cnt_i
0128  0840     MOVF index, W
0129  00AC     MOVWF divisor
012A  083F     MOVF 0x3F, W
012B  00AB     MOVWF eep_add
012C  083E     MOVF shift_pos, W
012D  00AA     MOVWF data
012E  22F3     CALL 0x2F3
012F  3180     MOVLP 0x0
0130  21C7     CALL 0x1C7
0131  3180     MOVLP 0x0
108:                   flags.write_const = 1;
0132  0023     MOVLB 0x3
0133  1467     BSF flags, 0x0
109:               }
110:               if (COMMAND_REG == 304) //записать данные по выбранному адресу
0134  2305     CALL 0x305
0135  3180     MOVLP 0x0
0136  3A30     XORLW 0x30
0137  0020     MOVLB 0x0
0138  230B     CALL 0x30B
0139  3180     MOVLP 0x0
013A  1D03     BTFSS STATUS, 0x2
013B  296F     GOTO 0x16F
111:               {
112:                   wtite_reg_chip(2, DEBUG_REG(0), ((UINT32) DEBUG_REG(2) << 16) | DEBUG_REG(1), buff_read, sizeof (buff_read));
013C  22DB     CALL 0x2DB
013D  3180     MOVLP 0x0
013E  304B     MOVLW 0x4B
013F  0086     MOVWF FSR1
0140  3F40     MOVIW 0[FSR1]
0141  00BE     MOVWF shift_pos
0142  3F41     MOVIW 1[FSR1]
0143  00BF     MOVWF 0x3F
0144  083E     MOVF shift_pos, W
0145  00C0     MOVWF index
0146  083F     MOVF 0x3F, W
0147  00C1     MOVWF index
0148  3050     MOVLW 0x50
0149  01C2     CLRF lock
014A  01C3     CLRF 0x43
014B  0086     MOVWF FSR1
014C  3F40     MOVIW 0[FSR1]
014D  00C4     MOVWF temp_limit_ind
014E  3F41     MOVIW 1[FSR1]
014F  00C5     MOVWF 0x45
0150  0844     MOVF temp_limit_ind, W
0151  00C6     MOVWF 0x46
0152  0845     MOVF 0x45, W
0153  00C7     MOVWF 0x47
0154  01C8     CLRF Timer_1
0155  01C9     CLRF 0x49
0156  00C9     MOVWF 0x49
0157  0846     MOVF 0x46, W
0158  00C8     MOVWF Timer_1
0159  01C7     CLRF 0x47
015A  01C6     CLRF 0x46
015B  0840     MOVF index, W
015C  0446     IORWF 0x46, W
015D  00AA     MOVWF data
015E  0841     MOVF index, W
015F  0447     IORWF 0x47, W
0160  00AB     MOVWF eep_add
0161  0842     MOVF lock, W
0162  0448     IORWF Timer_1, W
0163  00AC     MOVWF divisor
0164  0843     MOVF 0x43, W
0165  0449     IORWF 0x49, W
0166  00AD     MOVWF cnt_i
0167  22F3     CALL 0x2F3
0168  3180     MOVLP 0x0
0169  21C7     CALL 0x1C7
016A  3180     MOVLP 0x0
113:                   COMMAND_REG = 0;
016B  3078     MOVLW 0x78
016C  242A     CALL 0x42A
016D  3180     MOVLP 0x0
114:               } else if (COMMAND_REG == 404) //прочитать данные по выбранному адресу
016E  29B3     GOTO 0x1B3
016F  2305     CALL 0x305
0170  3180     MOVLP 0x0
0171  3A94     XORLW 0x94
0172  230B     CALL 0x30B
0173  3180     MOVLP 0x0
0174  1D03     BTFSS STATUS, 0x2
0175  2993     GOTO 0x193
0176  22DB     CALL 0x2DB
0177  3180     MOVLP 0x0
115:               {
116:                   flag_read = wtite_reg_chip(1, DEBUG_REG(0), 1, buff_read, sizeof (buff_read));
0178  30A0     MOVLW 0xA0
0179  01AA     CLRF data
017A  0AAA     INCF data, F
017B  22E4     CALL 0x2E4
017C  3180     MOVLP 0x0
017D  21C7     CALL 0x1C7
017E  3180     MOVLP 0x0
017F  22EB     CALL 0x2EB
0180  3180     MOVLP 0x0
117:                   if (!flag_read.general_error)
0181  1D03     BTFSS STATUS, 0x2
0182  296B     GOTO 0x16B
118:                   {
119:                       DEBUG_REG(1) = (buff_read[4] << 8) | buff_read[3];
0183  304B     MOVLW 0x4B
0184  0086     MOVWF FSR1
0185  3023     MOVLW 0x23
0186  0087     MOVWF FSR1H
0187  0021     MOVLB 0x1
0188  0823     MOVF 0xA3, W
0189  3FC0     MOVWI 0[FSR1]
018A  0824     MOVF 0xA4, W
018B  3FC1     MOVWI 1[FSR1]
120:                       DEBUG_REG(2) = (buff_read[6] << 8) | buff_read[5];
018C  3050     MOVLW 0x50
018D  0086     MOVWF FSR1L
018E  0825     MOVF 0xA5, W
018F  3FC0     MOVWI 0[FSR1]
0190  0826     MOVF 0xA6, W
0191  3FC1     MOVWI 1[FSR1]
0192  296B     GOTO 0x16B
121:                   }
122:                   COMMAND_REG = 0;
123:               } else
124:               {
125:                   const UINT16 add_read = 0xD0;
126:                   flag_read = wtite_reg_chip(1, add_read, number_read_reg, buff_read, sizeof (buff_read));
0193  30D0     MOVLW 0xD0
0194  00A8     MOVWF 0xA8
0195  3005     MOVLW 0x5
0196  01A9     CLRF 0xA9
0197  00AA     MOVWF 0xAA
0198  30A0     MOVLW 0xA0
0199  22E4     CALL 0x2E4
019A  3180     MOVLP 0x0
019B  21C7     CALL 0x1C7
019C  3180     MOVLP 0x0
019D  22EB     CALL 0x2EB
019E  3180     MOVLP 0x0
127:                   if (!flag_read.general_error)
019F  1D03     BTFSS STATUS, 0x2
01A0  29B3     GOTO 0x1B3
128:                   {
129:                       for (UINT8 index = 0; index < number_read_reg << 2; index++)
01A1  01D0     CLRF 0xD0
01AE  3014     MOVLW 0x14
01AF  0AD0     INCF 0xD0, F
01B0  0250     SUBWF 0xD0, W
01B1  1C03     BTFSS STATUS, 0x0
01B2  29A2     GOTO 0x1A2
130:                           *((UINT8*) reg_chip + index) = buff_read[3 + index];
01A2  0850     MOVF 0xD0, W
01A3  3EA0     ADDLW 0xA0
01A4  0086     MOVWF FSR1L
01A5  3001     MOVLW 0x1
01A6  0087     MOVWF FSR1H
01A7  0850     MOVF 0xD0, W
01A8  3E03     ADDLW 0x3
01A9  3EA0     ADDLW 0xA0
01AA  0084     MOVWF FSR0L
01AB  0185     CLRF FSR0H
01AC  0800     MOVF INDF0, W
01AD  0081     MOVWF INDF1
131:                   }
132:               }
133:               SPBRG = temp_SPBRG;
01B3  0020     MOVLB 0x0
01B4  084B     MOVF sign, W
01B5  0023     MOVLB 0x3
01B6  009C     MOVWF SPBRGH
01B7  0020     MOVLB 0x0
01B8  084A     MOVF temp_SPBRG, W
01B9  0023     MOVLB 0x3
01BA  009B     MOVWF SPBRG
134:               APFCON0 = 0b10000100;
01BB  3084     MOVLW 0x84
01BC  0022     MOVLB 0x2
01BD  009D     MOVWF APFCON0
135:               //TX9 = 1;
136:               //RX9 = 1;
137:               CREN = temp_CREN;
01BE  0020     MOVLB 0x0
01BF  1C4C     BTFSS temp_CREN, 0x0
01C0  29C4     GOTO 0x1C4
01C1  0023     MOVLB 0x3
01C2  161D     BSF RCSTA, 0x4
01C3  0008     RETURN
01C4  0023     MOVLB 0x3
01C5  121D     BCF RCSTA, 0x4
138:           }
01C6  0008     RETURN
139:           
140:           
141:           
142:           
143:           
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/pic/eewrite.c  ----------------------------------
1:             #include	<htc.h>
2:             
3:             #if	EEPROM_SIZE > 0
4:             
5:             void
6:             eeprom_write(unsigned char addr, unsigned char value)
0B57  00A1     MOVWF 0x1A1
7:             {
8:             	EEPROM_WRITE(addr, value);
0B58  0023     MOVLB 0x3
0B59  1895     BTFSC EECON1, 0x1
0B5A  2B58     GOTO 0x358
0B5B  0020     MOVLB 0x0
0B5C  0821     MOVF addr, W
0B5D  0023     MOVLB 0x3
0B5E  0091     MOVWF EEADR
0B5F  0192     CLRF EEADRH
0B60  0020     MOVLB 0x0
0B61  0820     MOVF __pcstackBANK0, W
0B62  0023     MOVLB 0x3
0B63  0093     MOVWF EEDAT
0B64  303F     MOVLW 0x3F
0B65  0595     ANDWF EECON1, F
0B66  1003     BCF STATUS, 0x0
0B67  1B8B     BTFSC INTCON, 0x7
0B68  1403     BSF STATUS, 0x0
0B69  138B     BCF INTCON, 0x7
0B6A  1515     BSF EECON1, 0x2
0B6B  3055     MOVLW 0x55
0B6C  0096     MOVWF EECON2
0B6D  30AA     MOVLW 0xAA
0B6E  0096     MOVWF EECON2
0B6F  1495     BSF EECON1, 0x1
0B70  1115     BCF EECON1, 0x2
0B71  1803     BTFSC STATUS, 0x0
0B72  178B     BSF INTCON, 0x7
9:             }
0B73  0008     RETURN
10:            #endif
11:            
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/pic/eeread.c  -----------------------------------
1:             #include	<htc.h>
2:             
3:             #if	EEPROM_SIZE > 0
4:             
5:             unsigned char
6:             eeprom_read(unsigned char addr)
0A65  0020     MOVLB 0x0
0A66  00A0     MOVWF __pcstackBANK0
7:             {
8:             	do
9:             		CLRWDT();
0A69  0064     CLRWDT
10:            	while(WR);
0A67  2A69     GOTO 0x269
0A68  0020     MOVLB 0x0
0A6A  0023     MOVLB 0x3
0A6B  1895     BTFSC EECON1, 0x1
0A6C  2A68     GOTO 0x268
11:            	return EEPROM_READ(addr);
0A6D  0020     MOVLB 0x0
0A6E  0820     MOVF __pcstackBANK0, W
0A6F  0023     MOVLB 0x3
0A70  0091     MOVWF EEADR
0A71  0192     CLRF EEADRH
0A72  303F     MOVLW 0x3F
0A73  0595     ANDWF EECON1, F
0A74  1415     BSF EECON1, 0x0
0A75  1003     BCF STATUS, 0x0
0A76  1815     BTFSC EECON1, 0x0
0A77  1403     BSF STATUS, 0x0
0A78  3000     MOVLW 0x0
0A79  3D09     ADDWFC WREG, W
0A7A  0813     MOVF EEDAT, W
12:            }
0A7B  0008     RETURN
13:            #endif
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/lwdiv.c  ---------------------------------
1:             // word unsigned division
2:             
3:             unsigned int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lwdiv(unsigned int divisor, unsigned int dividend)
7:             #else
8:             __lwdiv(unsigned int dividend, unsigned int divisor)
9:             #endif
10:            {
11:            	unsigned int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
0243  01A5     CLRF 0x1A5
0244  01A6     CLRF 0x1A6
15:            	if(divisor != 0) {
0245  0820     MOVF reg_chip, W
0246  0421     IORWF 0x1A1, W
0247  1903     BTFSC STATUS, 0x2
0248  2A63     GOTO 0x263
16:            		counter = 1;
0249  01A4     CLRF 0x1A4
17:            		while((divisor & 0x8000) == 0) {
024B  1BA1     BTFSC 0x1A1, 0x7
024C  2A50     GOTO 0x250
024F  2A4A     GOTO 0x24A
18:            			divisor <<= 1;
024D  35A0     LSLF reg_chip, F
024E  0DA1     RLF 0x1A1, F
19:            			counter++;
024A  0AA4     INCF 0x1A4, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
0250  35A5     LSLF 0x1A5, F
0251  0DA6     RLF 0x1A6, F
23:            			if(divisor <= dividend) {
0252  0821     MOVF 0x1A1, W
0253  0223     SUBWF 0x1A3, W
0254  1D03     BTFSS STATUS, 0x2
0255  2A58     GOTO 0x258
0256  0820     MOVF reg_chip, W
0257  0222     SUBWF 0x1A2, W
0258  1C03     BTFSS STATUS, 0x0
0259  2A5F     GOTO 0x25F
24:            				dividend -= divisor;
025A  0820     MOVF reg_chip, W
025B  02A2     SUBWF 0x1A2, F
025C  0821     MOVF 0x1A1, W
025D  3BA3     SUBWFB 0x1A3, F
25:            				quotient |= 1;
025E  1425     BSF 0x1A5, 0x0
26:            			}
27:            			divisor >>= 1;
025F  36A1     LSRF 0x1A1, F
0260  0CA0     RRF reg_chip, F
28:            		} while(--counter != 0);
0261  0BA4     DECFSZ 0x1A4, F
0262  2A50     GOTO 0x250
29:            	}
30:            	return quotient;
0263  0826     MOVF 0x1A6, W
0264  00A1     MOVWF 0x1A1
0265  0825     MOVF 0x1A5, W
0266  00A0     MOVWF reg_chip
31:            }
0267  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/lldiv.c  ---------------------------------
1:             // long unsigned unsigned division
2:             
3:             unsigned long int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __lldiv(unsigned long int divisor, unsigned long int dividend)
7:             #else
8:             __lldiv(unsigned long int dividend, unsigned long int divisor)
9:             #endif
10:            {
11:            	unsigned long int	quotient;
12:            	unsigned char	counter;
13:            
14:            	quotient = 0;
1669  01A8     CLRF 0x1A8
166A  01A9     CLRF 0x1A9
166B  01AA     CLRF 0x1AA
166C  01AB     CLRF 0x1AB
15:            	if(divisor != 0) {
166D  0823     MOVF 0x1A3, W
166E  0422     IORWF 0x1A2, W
166F  0421     IORWF 0x1A1, W
1670  0420     IORWF reg_chip, W
1671  1903     BTFSC STATUS, 0x2
1672  2E9F     GOTO 0x69F
16:            		counter = 1;
1673  01AC     CLRF 0x1AC
17:            		while((divisor & 0x80000000UL) == 0) {
1675  1BA3     BTFSC 0x1A3, 0x7
1676  2E7C     GOTO 0x67C
167B  2E74     GOTO 0x674
18:            			divisor <<= 1;
1677  35A0     LSLF reg_chip, F
1678  0DA1     RLF 0x1A1, F
1679  0DA2     RLF 0x1A2, F
167A  0DA3     RLF 0x1A3, F
19:            			counter++;
1674  0AAC     INCF 0x1AC, F
20:            		}
21:            		do {
22:            			quotient <<= 1;
167C  35A8     LSLF 0x1A8, F
167D  0DA9     RLF 0x1A9, F
167E  0DAA     RLF 0x1AA, F
167F  0DAB     RLF 0x1AB, F
23:            			if(divisor <= dividend) {
1680  0823     MOVF 0x1A3, W
1681  0227     SUBWF 0x1A7, W
1682  1D03     BTFSS STATUS, 0x2
1683  2E8E     GOTO 0x68E
1684  0822     MOVF 0x1A2, W
1685  0226     SUBWF 0x1A6, W
1686  1D03     BTFSS STATUS, 0x2
1687  2E8E     GOTO 0x68E
1688  0821     MOVF 0x1A1, W
1689  0225     SUBWF 0x1A5, W
168A  1D03     BTFSS STATUS, 0x2
168B  2E8E     GOTO 0x68E
168C  0820     MOVF reg_chip, W
168D  0224     SUBWF 0x1A4, W
168E  1C03     BTFSS STATUS, 0x0
168F  2E99     GOTO 0x699
24:            				dividend -= divisor;
1690  0820     MOVF reg_chip, W
1691  02A4     SUBWF 0x1A4, F
1692  0821     MOVF 0x1A1, W
1693  3BA5     SUBWFB 0x1A5, F
1694  0822     MOVF 0x1A2, W
1695  3BA6     SUBWFB 0x1A6, F
1696  0823     MOVF 0x1A3, W
1697  3BA7     SUBWFB 0x1A7, F
25:            				quotient |= 1;
1698  1428     BSF 0x1A8, 0x0
26:            			}
27:            			divisor >>= 1;
1699  36A3     LSRF 0x1A3, F
169A  0CA2     RRF 0x1A2, F
169B  0CA1     RRF 0x1A1, F
169C  0CA0     RRF reg_chip, F
28:            		} while(--counter != 0);
169D  0BAC     DECFSZ 0x1AC, F
169E  2E7C     GOTO 0x67C
29:            	}
30:            	return quotient;
169F  082B     MOVF 0x1AB, W
16A0  00A3     MOVWF 0x1A3
16A1  082A     MOVF 0x1AA, W
16A2  00A2     MOVWF 0x1A2
16A3  0829     MOVF 0x1A9, W
16A4  00A1     MOVWF 0x1A1
16A5  0828     MOVF 0x1A8, W
16A6  00A0     MOVWF reg_chip
31:            }
16A7  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/aldiv.c  ---------------------------------
1:             // long signed unsigned division
2:             
3:             signed long int
4:             #ifdef __PICC__
5:             #warning TODO: update cgpic and this file to use the other prototype
6:             __aldiv(signed long int divisor, signed long int dividend)
7:             #else
8:             __aldiv(signed long int dividend, signed long int divisor)
9:             #endif
10:            {
11:            	signed long int	quotient;
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
058D  01B5     CLRF 0x1B5
15:            	if(divisor < 0) {
058E  1FAF     BTFSS 0x1AF, 0x7
058F  2D9D     GOTO 0x59D
16:            		divisor = -divisor;
0590  09AC     COMF 0x1AC, F
0591  09AD     COMF 0x1AD, F
0592  09AE     COMF 0x1AE, F
0593  09AF     COMF 0x1AF, F
0594  0AAC     INCF 0x1AC, F
0595  1903     BTFSC STATUS, 0x2
0596  0AAD     INCF 0x1AD, F
0597  1903     BTFSC STATUS, 0x2
0598  0AAE     INCF 0x1AE, F
0599  1903     BTFSC STATUS, 0x2
059A  0AAF     INCF 0x1AF, F
17:            		sign = 1;
059B  01B5     CLRF 0x1B5
059C  0AB5     INCF 0x1B5, F
18:            	}
19:            	if(dividend < 0) {
059D  1FB3     BTFSS 0x1B3, 0x7
059E  2DAC     GOTO 0x5AC
20:            		dividend = -dividend;
059F  09B0     COMF 0x1B0, F
05A0  09B1     COMF 0x1B1, F
05A1  09B2     COMF 0x1B2, F
05A2  09B3     COMF 0x1B3, F
05A3  0AB0     INCF 0x1B0, F
05A4  1903     BTFSC STATUS, 0x2
05A5  0AB1     INCF 0x1B1, F
05A6  1903     BTFSC STATUS, 0x2
05A7  0AB2     INCF 0x1B2, F
05A8  1903     BTFSC STATUS, 0x2
05A9  0AB3     INCF 0x1B3, F
21:            		sign ^= 1;
05AA  3001     MOVLW 0x1
05AB  06B5     XORWF 0x1B5, F
22:            	}
23:            	quotient = 0;
05AC  01B6     CLRF 0x1B6
05AD  01B7     CLRF 0x1B7
05AE  01B8     CLRF 0x1B8
05AF  01B9     CLRF 0x1B9
24:            	if(divisor != 0) {
05B0  082F     MOVF 0x1AF, W
05B1  042E     IORWF 0x1AE, W
05B2  042D     IORWF 0x1AD, W
05B3  042C     IORWF 0x1AC, W
05B4  1903     BTFSC STATUS, 0x2
05B5  2DE2     GOTO 0x5E2
25:            		counter = 1;
05B6  01B4     CLRF cal_const_y
26:            		while((divisor & 0x80000000UL) == 0) {
05B8  1BAF     BTFSC 0x1AF, 0x7
05B9  2DBF     GOTO 0x5BF
05BE  2DB7     GOTO 0x5B7
27:            			divisor <<= 1;
05BA  35AC     LSLF 0x1AC, F
05BB  0DAD     RLF 0x1AD, F
05BC  0DAE     RLF 0x1AE, F
05BD  0DAF     RLF 0x1AF, F
28:            			counter++;
05B7  0AB4     INCF cal_const_y, F
29:            		}
30:            		do {
31:            			quotient <<= 1;
05BF  35B6     LSLF 0x1B6, F
05C0  0DB7     RLF 0x1B7, F
05C1  0DB8     RLF 0x1B8, F
05C2  0DB9     RLF 0x1B9, F
32:            			if((unsigned long)divisor <= (unsigned long)dividend) {
05C3  082F     MOVF 0x1AF, W
05C4  0233     SUBWF 0x1B3, W
05C5  1D03     BTFSS STATUS, 0x2
05C6  2DD1     GOTO 0x5D1
05C7  082E     MOVF 0x1AE, W
05C8  0232     SUBWF 0x1B2, W
05C9  1D03     BTFSS STATUS, 0x2
05CA  2DD1     GOTO 0x5D1
05CB  082D     MOVF 0x1AD, W
05CC  0231     SUBWF 0x1B1, W
05CD  1D03     BTFSS STATUS, 0x2
05CE  2DD1     GOTO 0x5D1
05CF  082C     MOVF 0x1AC, W
05D0  0230     SUBWF 0x1B0, W
05D1  1C03     BTFSS STATUS, 0x0
05D2  2DDC     GOTO 0x5DC
33:            				dividend -= divisor;
05D3  082C     MOVF 0x1AC, W
05D4  02B0     SUBWF 0x1B0, F
05D5  082D     MOVF 0x1AD, W
05D6  3BB1     SUBWFB 0x1B1, F
05D7  082E     MOVF 0x1AE, W
05D8  3BB2     SUBWFB 0x1B2, F
05D9  082F     MOVF 0x1AF, W
05DA  3BB3     SUBWFB 0x1B3, F
34:            				quotient |= 1;
05DB  1436     BSF 0x1B6, 0x0
35:            			}
36:            			*(unsigned long int *)&divisor >>= 1;
05DC  36AF     LSRF 0x1AF, F
05DD  0CAE     RRF 0x1AE, F
05DE  0CAD     RRF 0x1AD, F
05DF  0CAC     RRF 0x1AC, F
37:            		} while(--counter != 0);
05E0  0BB4     DECFSZ cal_const_y, F
05E1  2DBF     GOTO 0x5BF
38:            	}
39:            	if(sign)
05E2  0835     MOVF 0x1B5, W
05E3  1903     BTFSC STATUS, 0x2
05E4  2DF0     GOTO 0x5F0
40:            		quotient = -quotient;
05E5  09B6     COMF 0x1B6, F
05E6  09B7     COMF 0x1B7, F
05E7  09B8     COMF 0x1B8, F
05E8  09B9     COMF 0x1B9, F
05E9  0AB6     INCF 0x1B6, F
05EA  1903     BTFSC STATUS, 0x2
05EB  0AB7     INCF 0x1B7, F
05EC  1903     BTFSC STATUS, 0x2
05ED  0AB8     INCF 0x1B8, F
05EE  1903     BTFSC STATUS, 0x2
05EF  0AB9     INCF 0x1B9, F
41:            	return quotient;
05F0  0839     MOVF 0x1B9, W
05F1  00AF     MOVWF 0x1AF
05F2  0838     MOVF 0x1B8, W
05F3  00AE     MOVWF 0x1AE
05F4  0837     MOVF 0x1B7, W
05F5  00AD     MOVWF 0x1AD
05F6  0836     MOVF 0x1B6, W
05F7  00AC     MOVWF 0x1AC
42:            }
05F8  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/Umul8.c  ---------------------------------
1:             // 8 x 8 bit multiplication with 8 bit result
2:             
3:             unsigned char
4:             __bmul(unsigned char multiplier, unsigned char multiplicand)
0D9C  0020     MOVLB 0x0
0D9D  00A2     MOVWF multiplicand
5:             {
6:             	unsigned char product = 0;
0D9E  01A1     CLRF addr
7:             
8:             #if defined(__OPTIMIZE_SPEED__)
9:             
10:            	if(multiplier & 0x01)
11:            		product = (product + multiplicand) & 0xff;
12:            	multiplicand <<= 1;
13:            
14:            	if(multiplier & 0x02)
15:            		product = (product + multiplicand) & 0xff;
16:            	multiplicand <<= 1;
17:            
18:            	if(multiplier & 0x04)
19:            		product = (product + multiplicand) & 0xff;
20:            	multiplicand <<= 1;
21:            
22:            	if(multiplier & 0x08)
23:            		product = (product + multiplicand) & 0xff;
24:            	multiplicand <<= 1;
25:            
26:            	if(multiplier & 0x10)
27:            		product = (product + multiplicand) & 0xff;
28:            	multiplicand <<= 1;
29:            
30:            	if(multiplier & 0x20)
31:            		product = (product + multiplicand) & 0xff;
32:            	multiplicand <<= 1;
33:            
34:            	if(multiplier & 0x40)
35:            		product = (product + multiplicand) & 0xff;
36:            	multiplicand <<= 1;
37:            
38:            	if(multiplier & 0x80)
39:            		product = (product + multiplicand) & 0xff;
40:            
41:            #else
42:            	do {
43:            		if(multiplier & 1)
0DA0  1822     BTFSC multiplicand, 0x0
44:            			product += multiplicand;
0D9F  0820     MOVF __pcstackBANK0, W
0DA1  07A1     ADDWF addr, F
45:            		multiplicand <<= 1;
0DA2  35A0     LSLF __pcstackBANK0, F
46:            		multiplier >>= 1;
0DA3  36A2     LSRF multiplicand, F
47:            	} while(multiplier != 0);
0DA4  0822     MOVF multiplicand, W
0DA5  1D03     BTFSS STATUS, 0x2
0DA6  2D9F     GOTO 0x59F
48:            
49:            #endif
50:            	return product;
0DA7  0821     MOVF addr, W
51:            }
0DA8  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/Umul32.c  --------------------------------
1:             // 32 x 32 bit multiplication with 32 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned long
15:            __lmul(unsigned long multiplier, unsigned long multiplicand)
16:            {
17:            	unsigned long product;
18:            
19:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:            #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:            #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:            
24:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:            	{
26:            
27:            #define USE_SHRINK
28:            
29:            /*
30:            a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                         a  b  c  d
32:            *            e  f  g  h
33:            -----------------------
34:                       |         dh
35:                       |      ch  0
36:                       |   bh  0  0
37:                       |ah  0  0  0
38:                       |      dg  0
39:                       |   cg  0  0
40:                       |bg  0  0  0
41:                     ag| 0  0  0  0 (we ignore this intermediate product
42:                                     because it does not affect the low 32 bits of the result)
43:                       |   df  0  0
44:                       |cf  0  0  0
45:                     bf| 0  0  0  0 (ignore)
46:                  af  0| 0  0  0  0 (ignore)
47:                       |de  0  0  0
48:                     ce| 0  0  0  0 (ignore)
49:                  be  0| 0  0  0  0 (ignore)
50:            +  ae  0  0| 0  0  0  0 (ignore)
51:            =======================
52:             */
53:            		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:            
55:            #if defined(USE_MASKS)
56:            		product += ((unsigned long)
57:            			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:            			     +
59:            			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:            			<< 8;
61:            
62:            		product += ((unsigned long)
63:            			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:            			    +
65:            			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:            			    +
67:            			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:            			<< 16;
69:            
70:            		/* cast to smaller type to avoid adding high bits just to discard */
71:            		product += ((unsigned long)
72:            			    (unsigned char)
73:            			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:            			    +
75:            			    (unsigned char)
76:            			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:            			    +
78:            			    (unsigned char)
79:            			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:            			    +
81:            			    (unsigned char)
82:            			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:            			<< 24;
84:            
85:            #elif defined(USE_SHRINK)
86:            		/* add direct to upper bytes, rather than shift and add all bytes */
87:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:            			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:            		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:            			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:            
92:            
93:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:            			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:            			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:            			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:            
100:           		*(((unsigned char*)&product)+3) +=
101:           			(unsigned char)
102:           			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:           		*(((unsigned char*)&product)+3) +=
104:           			(unsigned char)
105:           			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:           		*(((unsigned char*)&product)+3) +=
107:           			(unsigned char)
108:           			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:           		*(((unsigned char*)&product)+3) +=
110:           			(unsigned char)
111:           			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:           
113:           #else
114:           #error No method chosen
115:           #endif
116:           	}
117:           #else
118:           
119:           	product = 0;
1644  01A8     CLRF add
1645  01A9     CLRF crcTx
1646  01AA     CLRF data
1647  01AB     CLRF eep_add
120:           	do {
121:           		if(multiplier & 1)
1648  1C20     BTFSS __pcstackBANK0, 0x0
1649  2E52     GOTO 0x652
122:           			product += multiplicand;
164A  0824     MOVF size_Buff, W
164B  07A8     ADDWF add, F
164C  0825     MOVF flag_read, W
164D  3DA9     ADDWFC crcTx, F
164E  0826     MOVF index, W
164F  3DAA     ADDWFC data, F
1650  0827     MOVF byte, W
1651  3DAB     ADDWFC eep_add, F
123:           		multiplicand <<= 1;
1652  35A4     LSLF size_Buff, F
1653  0DA5     RLF flag_read, F
1654  0DA6     RLF index, F
1655  0DA7     RLF byte, F
124:           		multiplier >>= 1;
1656  36A3     LSRF size_Tx, F
1657  0CA2     RRF multiplicand, F
1658  0CA1     RRF addr, F
1659  0CA0     RRF __pcstackBANK0, F
125:           	} while(multiplier != 0);
165A  0823     MOVF size_Tx, W
165B  0422     IORWF multiplicand, W
165C  0421     IORWF addr, W
165D  0420     IORWF __pcstackBANK0, W
165E  1D03     BTFSS STATUS, 0x2
165F  2E48     GOTO 0x648
126:           
127:           #endif
128:           	return product;
1660  082B     MOVF eep_add, W
1661  00A3     MOVWF size_Tx
1662  082A     MOVF data, W
1663  00A2     MOVWF multiplicand
1664  0829     MOVF crcTx, W
1665  00A1     MOVWF addr
1666  0828     MOVF add, W
1667  00A0     MOVWF __pcstackBANK0
129:           }
1668  0008     RETURN
---  C:/Program Files (x86)/Microchip/xc8/v1.45/sources/common/Umul16.c  --------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:            
41:            #else
42:            
43:            	product = 0;
0D87  01A4     CLRF size_Buff
0D88  01A5     CLRF flag_read
44:            	do {
45:            		if(multiplier & 1)
0D89  1C20     BTFSS __pcstackBANK0, 0x0
0D8A  2D8F     GOTO 0x58F
46:            			product += multiplicand;
0D8B  0822     MOVF multiplicand, W
0D8C  07A4     ADDWF size_Buff, F
0D8D  0823     MOVF size_Tx, W
0D8E  3DA5     ADDWFC flag_read, F
47:            		multiplicand <<= 1;
0D8F  35A2     LSLF multiplicand, F
0D90  0DA3     RLF size_Tx, F
48:            		multiplier >>= 1;
0D91  36A1     LSRF addr, F
0D92  0CA0     RRF __pcstackBANK0, F
49:            	} while(multiplier != 0);
0D93  0820     MOVF __pcstackBANK0, W
0D94  0421     IORWF addr, W
0D95  1D03     BTFSS STATUS, 0x2
0D96  2D89     GOTO 0x589
50:            
51:            #endif
52:                    return product;
0D97  0825     MOVF flag_read, W
0D98  00A1     MOVWF addr
0D99  0824     MOVF size_Buff, W
0D9A  00A0     MOVWF __pcstackBANK0
53:            }
0D9B  0008     RETURN
